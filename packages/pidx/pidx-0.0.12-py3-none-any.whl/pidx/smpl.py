# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/40_smpl.ipynb.

# %% auto 0
__all__ = ['sample_grouped', 'sample_indexed', 'generate_categorical_labels', 'generate_categorical_samples',
           'categorical_sample']

# %% ../nbs/40_smpl.ipynb 6
from enum import IntEnum, StrEnum, auto

# %% ../nbs/40_smpl.ipynb 8
from typing import TypeVar, TypeGuard
from typing import overload

# %% ../nbs/40_smpl.ipynb 11
#| export

# %% ../nbs/40_smpl.ipynb 13
try: import numpy as np
except: ...
try: import pandas as pd
except: ...
try: import torch
except: ...

# %% ../nbs/40_smpl.ipynb 15
#| export


# %% ../nbs/40_smpl.ipynb 17
#| export


# %% ../nbs/40_smpl.ipynb 19
from nlit import UNNAMED_CLN, CATEGORY, LABEL, ASTYPE, IGNORE, MPS, CPU
from chck import isdf, isstr, isnone, isnilstr
from quac import boolindex, groupkey, tensor, device, nparray
from asto import to

# %% ../nbs/40_smpl.ipynb 21
from .attr import getname, getindex, getastype, getshape
from .enum import SampleOutput, DataFormat, LocReturn, SampleCategoriesMethod
from .util import extent, choose_indicies
from .flat import drop_named_index, get_categories, drop_column, get_categorical_indexes, get_group

# %% ../nbs/40_smpl.ipynb 23
def sample_grouped(
    df: pd.DataFrame, groupby: str | tuple = LABEL, 
    n: int = 10, replace: bool = False
) -> np.ndarray:
    '''Sample `n` instances from each category within a DataFrame.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to sample from.
    
    groupby : str | tuple, default: 'label'
        Column name(s) to group by and sample within.
    
    n : int, default: 10
        Number of samples to draw from each category.
        
    replace : bool, default: False
        Whether or not to sample with replacement.
        
    Returns
    -------
    np.ndarray
        An array of the sampled instances.
    '''
    return drop_named_index(df).groupby(groupby, observed=False).sample(n, replace)

# %% ../nbs/40_smpl.ipynb 24
def sample_indexed(
    df: pd.DataFrame, idx: np.ndarray | pd.Series | pd.Index, 
    n: int = 10, replace: bool = False
) -> np.ndarray:
    '''Sample `n` instances from the DataFrame using provided indexes.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to sample from.
        
    idx : np.ndarray | pd.Series | pd.Index
        Indexes to use for sampling.
        
    n : int, default: 10
        Number of samples to draw.
        
    replace : bool, default: False
        Whether or not to sample with replacement.

    Returns
    -------
    np.ndarray
        An array of the sampled instances.
    '''
    return drop_named_index(df)[idx].sample(n, replace=replace)

# %% ../nbs/40_smpl.ipynb 26
def _categorical_numpy_labels(df: pd.DataFrame, col: str = LABEL, n: int = 10) -> np.ndarray:
    '''Generate a numpy array of labels for each category repeated `n` times.'''
    cats = get_categories(df, col)
    mn, mx = extent(cats)
    arng = np.arange(mn, mx + 1, 1)
    return np.tile(arng.reshape(-1, 1), (1, n)).reshape(len(arng), -1)

def _categorical_trc_labels(df: pd.DataFrame, col: str = LABEL, n: int = 10, device: str | device = MPS) -> tensor:
    '''Generate a PyTorch tensor of labels for each category repeated `n` times, placed on the specified device.'''
    try: import torch
    except: ...
    return to(torch.tensor(_categorical_numpy_labels(df, col, n)), device=device)

def _categorical_torch_labels(df: pd.DataFrame, col: str = LABEL, n: int = 10, device: str | device = MPS) -> tensor:
    '''Generate a PyTorch tensor of labels for each category repeated `n` times, placed on the specified device.'''
    try: import torch
    except: ...
    cats = get_categories(df, col)
    return to(torch.repeat_interleave(torch.arange(len(cats)).reshape(-1, 1), n, -1), device=device)

# %% ../nbs/40_smpl.ipynb 28
def _categorical_numpy_sample(
    df: pd.DataFrame, col: str = LABEL, n: int = 10, 
    method: int | SampleCategoriesMethod = 1, replace: bool = False
) -> np.ndarray:
    '''Sample `n` instances from each category within a DataFrame using numpy.'''
    cats = get_categories(df, col)
    ncat = len(cats)
    match method:
        case SampleCategoriesMethod.sample_split_stack:
            subs = sample_grouped(df, col, n, replace)
            return np.stack(np.array_split(drop_column(subs, col).values, ncat))
        
        case SampleCategoriesMethod.index_sample_stack:
            idxs = get_categorical_indexes(df, col)
            return np.vstack([
                [drop_column(sample_indexed(df, idx, n, replace), col).values] 
                for _, idx in idxs.items()])
            
        case SampleCategoriesMethod.sample_group_stack:
            subs = sample_grouped(df, col, n, replace)
            return np.vstack([
                [drop_column(get_group(subs, col, cat), col).values] 
                for cat in cats])
        
        case SampleCategoriesMethod.permute_indexes:
            subs = sample_grouped(df, col, n)
            for cat in cats:
                vals = drop_column(get_group(subs, col, cat), col).values
                idxs = choose_indicies(vals, n, replace)
                vals[idxs]
            return np.vstack([[
                drop_column(g, (
                    i := choose_indicies(
                        g := get_group(subs, col, cat), n, replace)
                    ), col).values[i]
            ] for cat in cats])
        case _:
            return _categorical_numpy_sample(df, col, n, 1, replace)

# %% ../nbs/40_smpl.ipynb 29
def _categorical_trc_sample(df: pd.DataFrame, col: str = LABEL, n: int = 10, method: int | SampleCategoriesMethod = 1, replace: bool = False, device: str | device = MPS) -> tensor:
    '''Sample `n` instances from each category within a DataFrame using PyTorch.'''
    sub = _categorical_numpy_sample(df, col, n, method, replace)
    return to(sub, device=device)

# %% ../nbs/40_smpl.ipynb 30
def _categorical_torch_sample(
    df: pd.DataFrame, col: str = LABEL, n: int = 10, 
    method: int | SampleCategoriesMethod = 1, replace: bool = False, device: str | device = MPS
) -> tensor:
    '''Sample `n` instances from each category within a DataFrame using PyTorch.'''
    try: import torch
    except: ...
    cats = get_categories(df, col)
    match method:
        case SampleCategoriesMethod.sample_split_stack:
            subs = sample_grouped(df, col, n, replace)
            return to(torch.stack(
                torch.tensor_split(
                    torch.tensor(
                        drop_column(subs, col).values
                        ), len(cats))), device=device)
        
        case SampleCategoriesMethod.index_sample_stack:
            idxs = get_categorical_indexes(df, col)
            return to(torch.tensor(np.vstack([
                [drop_column(sample_indexed(df, idx, n), col).values]
                for _, idx in idxs.items()
            ])), device=device)
            
        case SampleCategoriesMethod.sample_group_stack:
            subs = sample_grouped(df, col, n, replace)
            return to(torch.tensor([
                drop_column(
                    subs.groupby(col, observed=False).get_group(i), col
                ).values for i in cats
            ]), device=device)
            
        case _:
            return _torch_sample(df, col, n, 1, replace, device)

# %% ../nbs/40_smpl.ipynb 32
def generate_categorical_labels(
    df: pd.DataFrame, col: str = LABEL, n: int = 10,
    format: DataFormat = DataFormat.np, device: str | device = MPS
) -> np.ndarray | tensor:
    '''Generate a numpy array of labels for each category repeated `n` times.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to generate labels from.
        
    col : str, default: 'label'
        Column name to use for label generation.
        
    n : int, default: 10
        Number of times to repeat each label.
        
    format : DataFormat, default: DataFormat.numpy
        The format to return the data in.
    
    device : str | torch.device, default: 'mps'
        The device to try and put the tensor on.
    Returns
    -------
    np.ndarray | torch.tensor
        A numpy array of labels.
    '''
    match format:
        case DataFormat.numpy: return _categorical_numpy_labels(df, col, n)
        case DataFormat.torch: return _categorical_torch_labels(df, col, n, device)
        case _ if device == 'cpu': return _categorical_trc_labels(df, col, n, device)
        case _: return _categorical_numpy_labels(df, col, n)

# %% ../nbs/40_smpl.ipynb 33
def generate_categorical_samples(
    df: pd.DataFrame, 
    col: str = LABEL, 
    n: int = 10, 
    method: int | SampleCategoriesMethod = 1, 
    replace: bool = False,
    format: DataFormat = DataFormat.np,
    device: str | device = MPS
) -> np.ndarray | tensor:
    '''Sample `n` instances from each category within a DataFrame using numpy.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to sample from.
        
    col : str, default: 'label'
        Column name(s) to group by and sample within.
        
    n : int, default: 10
        Number of samples to draw from each category.
        
    method : int | SampleCategoriesMethod, default: 1
        The method to use for sampling, as defined by `SampleCategoriesMethod`.
        - `sample_split_stack`: Group by categories, then sample, split into the 
            number of categories, and stack.
        - `index_sample_stack`: Get each category's indexes, subset, then sample, 
            and stack. More efficient for large datasets.
        - `sample_group_stack`: Group by categories, sample, get each group, and 
            stack. Suitable for datasets with uneven category distribution.
            
    replace : bool, default: False
        Whether or not to sample with replacement.

    format : DataFormat, default: DataFormat.numpy
        The format to return the data in.
        
    device : str | device, default: 'mps'
        The device to try and put the tensor on.
    
    Returns
    -------
    np.ndarray | tensor
        An array of the sampled instances.
        
    Notes
    -----
    - `index_sample_stack` is typically more efficient for large datasets with many categories.
    - `sample_split_stack` is straightforward but may introduce overhead for very large datasets.
    - `sample_group_stack` is recommended for unevenly distributed categories, optimizing memory usage and processing time.
    '''
    match format:
        case DataFormat.numpy: return _categorical_numpy_sample(df, col, n, method, replace)
        case DataFormat.torch: return _categorical_torch_sample(df, col, n, method, replace, device)
        case _ if device == 'cpu': return _categorical_trc_sample(df, col, n, method, replace, device)
        case _: return _categorical_numpy_sample(df, col, n, method, replace)

# %% ../nbs/40_smpl.ipynb 35
def categorical_sample(
    df: pd.DataFrame, col: str = LABEL, n: int = 10, method: int | SampleCategoriesMethod = 1, 
    replace: bool = False, format: DataFormat = DataFormat.np, device: str = MPS, output: SampleOutput = SampleOutput.xy,
) -> tuple[np.ndarray | tensor, np.ndarray | tensor]:
    gcs, gcl = generate_categorical_samples, generate_categorical_labels
    match (output):
        case SampleOutput.x: 
            return gcs(df, col, n, method, replace, format, device)
        case SampleOutput.y: 
            return gcl(df, col, n, format, device)
        case SampleOutput.xy: 
            return gcs(df, col, n, method, replace, format, device), gcl(df, col, n, format, device)
        case _: 
            return gcs(df, col, n, method, replace, format, device), gcl(df, col, n, format, device)

# %% ../nbs/40_smpl.ipynb 37
#| export
