# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_util.ipynb.

# %% auto 0
__all__ = ['choose_indicies', 'reduce_boolean_index', 'extent', 'wrapidx', 'detdf', 'dfds', 'getidx', 'getdfidx', 'getdfloc',
           'getdfiloc', 'getdficat', 'mergebools', 'idxisin', 'safeidx', 'safeloc', 'safeiloc', 'ascat', 'getcol',
           'getcatcodes', 'getcolcodes', 'ascidx']

# %% ../nbs/02_util.ipynb 6
#| export


# %% ../nbs/02_util.ipynb 8
from typing import Union, Tuple, TypeAlias, Optional

# %% ../nbs/02_util.ipynb 11
#| export

# %% ../nbs/02_util.ipynb 13
try: import numpy as np, pandas as pd
except ImportError: ...

# %% ../nbs/02_util.ipynb 15
#| export


# %% ../nbs/02_util.ipynb 17
#| export


# %% ../nbs/02_util.ipynb 19
from quac import dataframe as DataFrame, ptdataset as Dataset, indexlike as IndexLike, bools as IterBool, nparray as NPArray
from chck import (
    isseries, isdf, isdfds, isidxlike, isboolidx,
    isiter, isnone, istuple, iscatidx
)
from atup import vargs, arg1st
from nlit import CATEGORY, CATEGORIES

# %% ../nbs/02_util.ipynb 21
from .mock import dummydf
from .atyp import DataFrameLike, DataFrameLikeQ, T
from pidx.attr import (
    getindex, getcodes, getdf, getloc, getiloc, geticat, getcategories,
    hasindex, hasastype, hascategories, hascat, hascodes
)

# %% ../nbs/02_util.ipynb 24
def choose_indicies(data: np.ndarray | pd.DataFrame | pd.Series | pd.Index, n: int = 10, replace: bool = False) -> NPArray:
    nrow = getattr(data, 'shape', (len(data), ))[0]
    idxs = np.arange(nrow)
    return np.random.choice(idxs, size=(n, ), replace=replace)

# %% ../nbs/02_util.ipynb 25
def reduce_boolean_index(idx: IterBool) -> NPArray:
    '''Merge boolean indexes.'''
    if not isiter(idx): return np.zeros_like(idx, dtype=bool)
    if isboolidx(idx): return np.logical_or.reduce(np.vstack(idx))
    return np.logical_or.reduce(idx)

# %% ../nbs/02_util.ipynb 26
def extent(arr: list | np.ndarray | pd.Series) -> tuple[int, int]:
    '''Find the minimum and maximum of an array, list, or Series.

    Parameters
    ----------
    arr : list | np.ndarray | pd.Series
        The array, list, or Series to find the extent of.

    Returns
    -------
    tuple[int, int]
        A tuple containing the minimum and maximum values.
    '''
    try: return min(arr), max(arr)
    except: return 0, len(arr)

# %% ../nbs/02_util.ipynb 27
def wrapidx(idx: IndexLike | None = None) -> IndexLike:
    '''Wrap idx in a tuple if it's not already a tuple or an index-like object'''
    idxlen = len(vargs(idx))
    if idxlen == 1 and not (isidxlike(idx) or istuple(idx)):
        idx = list((idx, ))
    return idx

# %% ../nbs/02_util.ipynb 28
def detdf(*args: DataFrameLike) -> DataFrame | None:
    '''
    Determine the df from any of the args if the current `arg` is a `df` or `ds.df`

    `dfds` searches for the first pandas DataFrame found in any of the `args` or `arg.df` 
    (if and only if `arg` is a pytorch `Dataset`) and returns it

    Notes
    -----
    df : `pd.DataFrame`
    ds : `torch.utils.data.dataset.Dataset`
    '''
    arg = arg1st(*args, flag=lambda e: isdf(e) or isdfds(e) or isseries(e), default=None)
    if isseries(arg): return arg.to_frame()
    return getdf(arg)

def dfds(df: DataFrame | None = None, ds: Dataset | None = None, *args: DataFrameLike) -> DataFrame | None:
    '''Get the `df` from either `df` or `ds.df` where `df`'''        
    return detdf(df, ds, *args)

# %% ../nbs/02_util.ipynb 29
def getidx(dl: DataFrameLike = None, *args: DataFrameLike) -> IndexLike | None:
    '''Get the df's index from either `df` or `ds.df`'''
    return getindex(dfds(dl, *args))

# %% ../nbs/02_util.ipynb 30
def getdfidx(dl: DataFrameLike = None, *args: DataFrameLike) -> IndexLike | None:
    '''Get the df's index from either `df` or `ds.df`'''
    return getindex(dfds(dl, *args))

def getdfloc(dl: DataFrameLike, *args: DataFrameLike) -> IndexLike | None:
    '''Get the df's `LocIndexer` from either `df` or `ds.df`'''
    return getloc(detdf(dl, *args))

def getdfiloc(dl: DataFrameLike, *args: DataFrameLike) -> IndexLike | None:
    '''Get the df's `iLocIndexer` from either `df` or `ds.df`'''
    return getiloc(detdf(dl, *args))

def getdficat(dl: DataFrameLike, *args: DataFrameLike) -> IndexLike | None:
    '''Get the df's `iLocIndexer` from either `df` or `ds.df`'''
    return geticat(detdf(dl, *args))

# %% ../nbs/02_util.ipynb 31
def mergebools(idx: IterBool, dl: DataFrameLike = None, *args: DataFrameLike) -> NPArray:
    '''Merge boolean indexes.'''
    return reduce_boolean_index(idx if isiter(idx) else getdfidx(dl, *args))

# %% ../nbs/02_util.ipynb 33
def idxisin(idx: IndexLike | None = None, dl: DataFrameLike = None, *args: DataFrameLike, vals: IndexLike | None = None) -> IndexLike:
    '''Filter vals for those in df's index'''
    idx = wrapidx(idx)
    if vals is None: vals = getdfidx(dl, *args)
    return type(idx)(list(filter(lambda x: x in vals, idx)))

# %% ../nbs/02_util.ipynb 35
def safeidx(idx: IndexLike | None = None, dl: DataFrameLike = None, *args: DataFrameLike) -> IndexLike | None:
    '''Check that idx exists or get the df's index from either `df` or `ds.df`'''
    if isnone(idx) or not isidxlike(idx): return getdfidx(dl, *args)
    return idx

def safeloc(idx: IndexLike | None = None, dl: DataFrameLike = None, *args: DataFrameLike) -> IndexLike | None:
    '''Check that idx exists then apply it to the `LocIndexer` from either `df` or `ds.df`'''
    idx = safeidx(idx, dl, *args) if isnone(idx) else idx
    return getdfloc(dl, *args)[idx]

def safeiloc(idx: IndexLike | None = None, dl: DataFrameLike = None, *args: DataFrameLike) -> IndexLike | None:
    '''Check that idx exists then apply it to the `iLocIndexer` from either `df` or `ds.df`'''
    idx = safeidx(idx, dl, *args) if isnone(idx) else idx
    return getdfiloc(dl, *args)[idx]

# %% ../nbs/02_util.ipynb 37
def ascat(il: IndexLike | DataFrameLike) -> pd.Categorical:
    if hasastype(il): return il.astype(CATEGORY)
    if hasindex(il): return getindex(il).astype(CATEGORY)
    if hascategories(il): return il
    try: return pd.Categorical(il)
    except: ...
    return il

# %% ../nbs/02_util.ipynb 38
def getcol(dl: DataFrameLike, col: str, *args: DataFrameLike):
    df = detdf(dl, *args)
    return df.get(col)

def getcatcodes(idx: IndexLike):
    if iscatidx(idx): return idx.codes
    return getcodes(idx)

def getcolcodes(dl: DataFrameLike, col: str, *args: DataFrameLike):
    srs = getcol(dl, col, *args)
    return getcodes(srs)

# %% ../nbs/02_util.ipynb 39
def ascidx(idx: IndexLike | DataFrameLike) -> pd.Categorical:
    if isdf(idx): idx = getindex(idx)    
    if isseries(idx) and hascat(idx): return idx
    if hasastype(idx): return idx.astype(CATEGORY)
    if hascategories(idx): return idx
    return pd.Categorical(idx)

# %% ../nbs/02_util.ipynb 41
#| export
