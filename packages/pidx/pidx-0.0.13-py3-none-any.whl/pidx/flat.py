# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/30_flat.ipynb.

# %% auto 0
__all__ = ['is_not_named', 'is_unnamed', 'drop_named_index', 'drop_column', 'as_categorical', 'column_as_categorical',
           'get_categories', 'get_categorical_indexes', 'get_group', 'len_per_group', 'sample_grouped',
           'sample_indexed']

# %% ../nbs/30_flat.ipynb 6
from enum import IntEnum, StrEnum, auto

# %% ../nbs/30_flat.ipynb 8
from typing import TypeVar, TypeGuard
from typing import overload

# %% ../nbs/30_flat.ipynb 11
#| export

# %% ../nbs/30_flat.ipynb 13
try: import numpy as np
except: ...
try: import pandas as pd
except: ...
try: import torch
except: ...

# %% ../nbs/30_flat.ipynb 15
#| export


# %% ../nbs/30_flat.ipynb 17
#| export


# %% ../nbs/30_flat.ipynb 19
from nlit import UNNAMED_CLN, CATEGORY, LABEL, ASTYPE, IGNORE, MPS, CPU
from chck import isdf, isstr, isnone, isnilstr
from quac import boolindex, groupkey, tensor, device, nparray
from asto import to

# %% ../nbs/30_flat.ipynb 21
from .atyp import T
from .attr import getname, getindex, getastype
from .enum import LocReturn

# %% ../nbs/30_flat.ipynb 24
@overload
def is_not_named(obj: object) -> bool: ...
@overload
def is_not_named(index: pd.Index) -> bool: ...
@overload
def is_not_named(series: pd.Series) -> bool: ...
@overload
def is_not_named(df: pd.DataFrame) -> bool: ...
@overload
def is_not_named(name: str) -> bool: ...
def is_not_named(item: str) -> bool:
    '''Check if a pandas `Index`, `Series`, or `DataFrame`'s index does not have a name, its `name` is `None`, or `''`.
    
    Parameters
    ----------
    item : object, pd.Index, pd.Series, pd.DataFrame, str
        The item to check for a named or unnamed status.

    Returns
    -------
    bool
        True if the item is not named, False otherwise.
    
    Notes
    -----
    `is_not_named` has the following overloaded function signatures:
        - is_not_named(obj: object) -> bool
        - is_not_named(index: pd.Index) -> bool
        - is_not_named(series: pd.Series) -> bool
        - is_not_named(df: pd.DataFrame) -> bool
        - is_not_named(name: str) -> bool
    '''
    if isdf(item): 
        return is_not_named(getindex(item))
    elif isstr(item):
        return isnone(item) or isnilstr(item)
    return isnone(getname(item))

# %% ../nbs/30_flat.ipynb 26
@overload
def is_unnamed(obj: object, include_none: bool = True) -> bool: ...
@overload
def is_unnamed(col: str, include_none: bool = True) -> bool: ...
@overload
def is_unnamed(index: pd.Index, include_none: bool = True) -> bool: ...
@overload
def is_unnamed(series: pd.Series, include_none: bool = True) -> bool: ...
@overload
def is_unnamed(df: pd.DataFrame, include_none: bool = True) -> bool: ...
@overload
def is_unnamed(name: str, include_none: bool = True) -> bool: ...
@overload
def is_unnamed(item: str, include_none: bool = True) -> bool: ...
def is_unnamed(item: pd.DataFrame | pd.Index | str, include_none: bool = True) -> bool:
    '''Check if a column name is an unnamed/auto-generated name in a DataFrame.

    This function is useful when working with pandas DataFrames, as pandas often
    generates column names like 'Unnamed: 0' for unnamed columns when reading files.

    Parameters
    ----------
    item : pd.DataFrame | pd.Index | str
        The DataFrame whose's index should be checked. The pd.Index
        The column name to check.
        
    include_none : bool, default: True
        Whether or not `None` is considered to be unnamed.

    Returns
    -------
    bool
        True if the column name is an unnamed/auto-generated one, False otherwise.

    Examples
    --------
    >>> is_unnamed('Unnamed: 0')
    True

    >>> is_unnamed('my_column')
    False
    
    See Also
    --------
    is_not_named : Check if a pandas `Index`, `Series`, or `DataFrame`'s index does not have a name, its `name` is `None`, or `''`.
    
    Notes
    -----
    `is_unnamed` has the following overloaded function signatures:
        - is_unnamed(obj: object, include_none: bool = True) -> bool
        - is_unnamed(col: str, include_none: bool = True) -> bool
        - is_unnamed(index: pd.Index, include_none: bool = True) -> bool
        - is_unnamed(series: pd.Series, include_none: bool = True) -> bool
        - is_unnamed(df: pd.DataFrame, include_none: bool = True) -> bool
        - is_unnamed(name: str, include_none: bool = True) -> bool
    '''
    if include_none and is_not_named(item): return True
    return item.strip().casefold().startswith(UNNAMED_CLN)

# %% ../nbs/30_flat.ipynb 29
def drop_named_index(df: pd.DataFrame) -> pd.DataFrame:
    '''Reset index of the DataFrame if it is not named.

    Parameters
    ----------
    df : pd.DataFrame
        The DataFrame whose index to potentially drop.

    Returns
    -------
    pd.DataFrame
        DataFrame with the index dropped if it was not named.
    '''
    return df.reset_index(drop=is_not_named(df))

# %% ../nbs/30_flat.ipynb 31
def drop_column(df: pd.DataFrame, col: str = LABEL) -> pd.DataFrame:
    '''Drop the specified column from a DataFrame and reset the index if it is not named.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to modify.
        
    col : str, default: 'label'
        Column name to drop.

    Returns
    -------
    pd.DataFrame
        Modified DataFrame with the specified column dropped.
    '''
    return drop_named_index(df).drop(columns=[col], errors=IGNORE)

# %% ../nbs/30_flat.ipynb 33
@overload
def as_categorical(obj: T) -> T | pd.Categorical: ...
@overload
def as_categorical(index: pd.Index) -> pd.CategoricalIndex: ...
@overload
def as_categorical(series: pd.Series) -> pd.Series | pd.CategoricalIndex: ...
@overload
def as_categorical(column: pd.Series) -> pd.Series | pd.CategoricalIndex: ...
@overload
def as_categorical(df: pd.DataFrame) -> pd.DataFrame: ...
def as_categorical(item: T | pd.Index | pd.Series | pd.DataFrame) -> T | pd.Series | pd.Categorical | pd.CategoricalIndex | pd.DataFrame:
    '''Convert the given item to pandas Categorical type if applicable.

    Parameters
    ----------
    item : T | pd.Index | pd.Series | pd.DataFrame
        The item to convert, can be a variety of pandas objects or other types.

    Returns
    -------
    T | pd.Series | pd.Categorical | pd.CategoricalIndex | pd.DataFrame
        The item converted to a Categorical type, if applicable.
        
    Notes
    -----
    `as_categorical` has the following overloaded function signatures:
        - as_categorical(obj: T) -> T | pd.Categorical
        - as_categorical(index: pd.Index) -> pd.CategoricalIndex
        - as_categorical(series: pd.Series) -> pd.Series | pd.CategoricalIndex
        - as_categorical(df: pd.DataFrame) -> pd.DataFrame
    '''
    return getastype(item)(CATEGORY)
    return getattr(item, ASTYPE, lambda t: item)(CATEGORY)

# %% ../nbs/30_flat.ipynb 34
def column_as_categorical(df: pd.DataFrame, col: str = LABEL) -> pd.Series | pd.Categorical | pd.CategoricalIndex:
    '''Retrieve a column from the DataFrame as a Categorical type.

    Parameters
    ----------
    df : pd.DataFrame
        The DataFrame from which to retrieve the column.
        
    col : str, default: 'label'
        The name of the column to retrieve.

    Returns
    -------
    pd.Series | pd.Categorical | pd.CategoricalIndex
        The specified column converted to a Categorical type.
    '''
    return as_categorical(drop_named_index(df)[col])

# %% ../nbs/30_flat.ipynb 35
def get_categories(df: pd.DataFrame, col: str = LABEL) -> pd.Series:
    '''Retrieve unique categories from a specified column in a DataFrame as a sorted Series.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame from which categories are to be retrieved.
    col : str, default: 'label'
        The column name from which to retrieve unique categories.

    Returns
    -------
    pd.Series
        A Series containing sorted unique categories from the specified column.
    '''
    return pd.Series(sorted(column_as_categorical(df, col).unique()), name=col)

# %% ../nbs/30_flat.ipynb 36
def get_categorical_indexes(
    df: pd.DataFrame, 
    col: str = LABEL, 
    ret: LocReturn = LocReturn.bloc
) -> dict[int, pd.Index | pd.Series | boolindex]:
    '''Retrieve indexes for each category in a specified column of a DataFrame.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to process.
        
    col : str, default: 'label'
        The column name from which to retrieve categories.
        
    ret : LocReturn, default: LocReturn.bloc
        The type of indexes to return: boolean index, integer index, or default pandas index.

    Returns
    -------
    dict
        A dictionary with category codes as keys and indexes as values, 
        according to the specified return type.
    '''

    catcol = column_as_categorical(df, col)
    ccodes = catcol.cat.codes
    boolix = {c: (ccodes == c) for c in sorted(catcol.unique())}
    match ret:
        case LocReturn.bloc: return boolix
        case LocReturn.iloc: return {c: b[b == True].index for c, b in boolix.items()}
        case LocReturn.loc: return boolix
        case _: return boolix

# %% ../nbs/30_flat.ipynb 38
def get_group(
    df: pd.DataFrame, 
    groupby: str | tuple | tuple[groupkey, ...], 
    group: str | tuple | groupkey,
    index: str = LABEL, 
    set_index: bool = False
) -> pd.DataFrame:
    '''Retrieve a specific group from a DataFrame grouped by the specified column(s).

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to group and retrieve from.
    
    groupby : str | tuple | tuple[groupkey, ...]
        Column name(s) to group by.
        
    group : str | tuple | groupkey
        The specific group's name or key to retrieve.
        
    index : str, default: 'LABEL'
        The column name to set as the new index of the subgroup if `set_index` is True.
        
    set_index : bool, default: True
        Determines whether to set the specified column as the new index for the subgroup.

    Returns
    -------
    pd.DataFrame
        The DataFrame containing only the rows belonging to the specified group.
    '''
    sub = drop_named_index(df).groupby(groupby, observed=False).get_group(group)
    if set_index: sub = sub.set_index(index)
    return sub

# %% ../nbs/30_flat.ipynb 39
def len_per_group(df: pd.DataFrame, groupby: str | tuple | tuple[groupkey, ...] = LABEL) -> pd.Series:
    '''Calculate the number of samples per category in a DataFrame.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to process.
        
    groupby : str | tuple, default: 'label'
        Column name(s) to group by.

    Returns
    -------
    pd.Series
        A Series containing the average number of samples per category.
    '''
    return drop_named_index(df).groupby(groupby, observed=False).agg(len).mean(axis=1).astype(int)

# %% ../nbs/30_flat.ipynb 41
def sample_grouped(
    df: pd.DataFrame, groupby: str | tuple = LABEL, 
    n: int = 10, replace: bool = False
) -> np.ndarray:
    '''Sample `n` instances from each category within a DataFrame.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to sample from.
    
    groupby : str | tuple, default: 'label'
        Column name(s) to group by and sample within.
    
    n : int, default: 10
        Number of samples to draw from each category.
        
    replace : bool, default: False
        Whether or not to sample with replacement.
        
    Returns
    -------
    np.ndarray
        An array of the sampled instances.
    '''
    return drop_named_index(df).groupby(groupby, observed=False).sample(n, replace)

# %% ../nbs/30_flat.ipynb 42
def sample_indexed(
    df: pd.DataFrame, idx: np.ndarray | pd.Series | pd.Index, 
    n: int = 10, replace: bool = False
) -> np.ndarray:
    '''Sample `n` instances from the DataFrame using provided indexes.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to sample from.
        
    idx : np.ndarray | pd.Series | pd.Index
        Indexes to use for sampling.
        
    n : int, default: 10
        Number of samples to draw.
        
    replace : bool, default: False
        Whether or not to sample with replacement.

    Returns
    -------
    np.ndarray
        An array of the sampled instances.
    '''
    return drop_named_index(df)[idx].sample(n, replace=replace)

# %% ../nbs/30_flat.ipynb 44
#| export
