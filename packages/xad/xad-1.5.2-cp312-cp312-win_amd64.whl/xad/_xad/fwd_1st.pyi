from __future__ import annotations
import typing
__all__ = ['Real']
class Real:
    """
    active arithmetic type for first order adjoint mode
    """
    __hash__: typing.ClassVar[None] = None
    def __abs__(self) -> Real:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> Real:
        ...
    @typing.overload
    def __add__(self, arg0: Real) -> Real:
        ...
    def __bool__(self) -> bool:
        ...
    def __ceil__(self) -> int:
        ...
    @typing.overload
    def __divmod__(self, arg0: Real) -> tuple[Real, Real]:
        ...
    @typing.overload
    def __divmod__(self, arg0: float) -> tuple[Real, Real]:
        ...
    @typing.overload
    def __divmod__(self, arg0: int) -> tuple[Real, Real]:
        ...
    @typing.overload
    def __eq__(self, arg0: Real) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: float) -> bool:
        ...
    def __floor__(self) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: Real) -> Real:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> Real:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> Real:
        ...
    @typing.overload
    def __ge__(self, arg0: Real) -> bool:
        ...
    @typing.overload
    def __ge__(self, arg0: float) -> bool:
        ...
    @typing.overload
    def __gt__(self, arg0: Real) -> bool:
        ...
    @typing.overload
    def __gt__(self, arg0: float) -> bool:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    def __int__(self) -> int:
        ...
    @typing.overload
    def __le__(self, arg0: Real) -> bool:
        ...
    @typing.overload
    def __le__(self, arg0: float) -> bool:
        ...
    @typing.overload
    def __lt__(self, arg0: Real) -> bool:
        ...
    @typing.overload
    def __lt__(self, arg0: float) -> bool:
        ...
    @typing.overload
    def __mod__(self, arg0: Real) -> Real:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> Real:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> Real:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Real:
        ...
    @typing.overload
    def __mul__(self, arg0: Real) -> Real:
        ...
    @typing.overload
    def __ne__(self, arg0: Real) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: float) -> bool:
        ...
    def __neg__(self) -> Real:
        ...
    def __pos__(self) -> Real:
        ...
    @typing.overload
    def __pow__(self, arg0: Real) -> Real:
        ...
    @typing.overload
    def __pow__(self, arg0: int) -> Real:
        ...
    @typing.overload
    def __pow__(self, arg0: float) -> Real:
        ...
    def __radd__(self, arg0: float) -> Real:
        ...
    @typing.overload
    def __rdivmod__(self, arg0: Real) -> tuple[Real, Real]:
        ...
    @typing.overload
    def __rdivmod__(self, arg0: float) -> tuple[Real, Real]:
        ...
    @typing.overload
    def __rdivmod__(self, arg0: int) -> tuple[Real, Real]:
        ...
    def __repr__(self) -> str:
        ...
    def __req__(self, arg0: float) -> bool:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: Real) -> Real:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> Real:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> Real:
        ...
    def __rge__(self, arg0: float) -> bool:
        ...
    def __rgt__(self, arg0: float) -> bool:
        ...
    def __rle__(self, arg0: float) -> bool:
        ...
    def __rlt__(self, arg0: float) -> bool:
        ...
    @typing.overload
    def __rmod__(self, arg0: Real) -> Real:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> Real:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> Real:
        ...
    def __rmul__(self, arg0: float) -> Real:
        ...
    def __rne__(self, arg0: float) -> bool:
        ...
    @typing.overload
    def __round__(self, arg0: int) -> Real:
        ...
    @typing.overload
    def __round__(self) -> int:
        ...
    @typing.overload
    def __rpow__(self, arg0: Real) -> Real:
        ...
    @typing.overload
    def __rpow__(self, arg0: int) -> Real:
        ...
    @typing.overload
    def __rpow__(self, arg0: float) -> Real:
        ...
    def __rsub__(self, arg0: float) -> Real:
        ...
    def __rtruediv__(self, arg0: float) -> Real:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> Real:
        ...
    @typing.overload
    def __sub__(self, arg0: Real) -> Real:
        ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Real:
        ...
    @typing.overload
    def __truediv__(self, arg0: Real) -> Real:
        ...
    def __trunc__(self) -> int:
        ...
    def conjugate(self) -> Real:
        """
        complex conjugate
        """
    def getDerivative(self) -> float:
        """
        get the adjoint of this variable
        """
    def getValue(self) -> float:
        """
        get the underlying value
        """
    def imag(self) -> Real:
        """
        imaginary part
        """
    def real(self) -> Real:
        """
        real part
        """
    def setDerivative(self, arg0: float) -> None:
        """
        set the adjoint of this variable
        """
