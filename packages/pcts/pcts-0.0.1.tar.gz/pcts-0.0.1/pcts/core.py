# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['WRAPS_ASSIGN_ANNDOCS', 'percent', 'round_percent', 'ipercent', 'integer_percent', 'ipercents', 'integer_percents',
           'pints', 'apercents', 'accumulate_percents', 'asums', 'rpercents', 'perbounds', 'range_percents', 'idxstep',
           'index_step', 'idxperm', 'permute_indicies', 'index_split_by_percents', 'pidxs']

# %% ../nbs/00_core.ipynb 6
import random
from contextlib import redirect_stdout, redirect_stderr
from functools import wraps
from itertools import takewhile, accumulate
from importlib import import_module

# %% ../nbs/00_core.ipynb 8
from types import FunctionType, ModuleType
from numbers import Number

# %% ../nbs/00_core.ipynb 11
#| export

# %% ../nbs/00_core.ipynb 13
#| export


# %% ../nbs/00_core.ipynb 15
#| export


# %% ../nbs/00_core.ipynb 17
#| export


# %% ../nbs/00_core.ipynb 19
from seeder import seedall

# %% ../nbs/00_core.ipynb 21
WRAPS_ASSIGN_ANNDOCS = ('__doc__', '__module__', '__annotations__')

# %% ../nbs/00_core.ipynb 23
def percent(p: float, ndigits: int = 3) -> float:
    '''Converts a percentage `p` to a decimal, rounding to `ndigits` decimal places.
    
    Parameters
    ----------
    p : float
        The percentage to convert.
        
    ndigits : int, default 3
        The number of decimal places to round to.
        
    Returns
    -------
    float
        The converted decimal percentage.
        
    See Also
    --------
    round_percent : Alias for percent
        
    '''
    return round(p if (p := abs(p)) < 1 else p / 100, ndigits)

@wraps(percent, assigned=WRAPS_ASSIGN_ANNDOCS)
def round_percent(p: float, ndigits: int = 3) -> float:
    '''Alias for `percent`.'''
    return percent(p, ndigits)

# %% ../nbs/00_core.ipynb 25
def ipercent(total: int = 1, p: float = 1., ndigits: int = 3) -> int:
    '''Calculates the integer part of `p` percent of `total`, 
    rounded to `ndigits` decimal places.
    
    Parameters
    ----------
    total : int, default: 1
        The total amount to calculate the percentage of.
        
    p : float, default: 1.0
        The percentage to calculate.

    ndigits : int, default: 3
        The number of decimal places to round to.
        
    Returns
    -------
    int
        The integer part of the calculated percentage.
        
    See Also
    --------
    integer_percent : Alias for ipercent
    '''
    return int(total * percent(p, ndigits))

@wraps(ipercent, assigned=WRAPS_ASSIGN_ANNDOCS)
def integer_percent(*args, **kwargs):
    '''Alias for `ipercent`.'''
    return ipercent(*args, **kwargs)

# %% ../nbs/00_core.ipynb 27
def ipercents(
    total: int, 
    *percents: float, 
    ndigits: int = 3, 
    useall: bool = True, 
    overflow: bool = False,
) -> tuple[int, ...]:
    '''Divides total into the corresponding integer values given the
    percents in `*percents` and ensures that all values are used
    
    Parameters
    ----------
    total : int
        The total amount to divide according to `percents`.
        
    *percents : float
        Percentages to divide `total` into.
        
    ndigits : int, default: 3
        The number of decimal places to round percentages to.
        
    useall : bool, default: True
        Whether to ensure that the sum of values is equal to `total`.

    overflow : bool, default: False
        Whether to allow overflowing the total amount. If `False`, the last value will be
        less than or equal to the total amount.
    
    Returns
    -------
    tuple[int, ...]
        The integer values corresponding to the percentages in `percents`.
        
    See Also
    --------
    pints : Alias for `ipercents`
    integer_percents : Alias for `ipercents`
    '''
    pints = [ipercent(total, pct, ndigits) for pct in percents]    
    if not overflow and sum(pints) > total: pints.pop()
    if useall and sum(pints) < total: pints.append(total - sum(pints))
    return pints

@wraps(ipercents, assigned=WRAPS_ASSIGN_ANNDOCS)
def integer_percents(*args, **kwargs):
    '''Alias for `ipercents`.'''
    return ipercents(*args, **kwargs)

@wraps(ipercents, assigned=WRAPS_ASSIGN_ANNDOCS)
def pints(*args, **kwargs):
    '''Alias for `ipercents`.'''
    return ipercents(*args, **kwargs)

# %% ../nbs/00_core.ipynb 29
def apercents(
    total: int, 
    *percents: float, 
    ndigits: int = 3,
    useall: bool = True, 
    overflow: bool = False,
) -> tuple[int, ...]:
    '''Accumulate the integer values of the corresponding percentages for `total`.
    
    Parameters
    ----------
    total : int
        The total amount to divide according to `percents`.
        
    *percents : float
        Percentages to divide `total` into.
        
    ndigits : int, default: 3
        The number of decimal places to round percentages to.
        
    useall : bool, default: True
        Whether to ensure that the sum of values is equal to `total`.

    overflow : bool, default: False
        Whether to allow overflowing the total amount. If `False`, the last value will be
        less than or equal to the total amount.
    
    Returns
    -------
    tuple[tuple[int, int], ...]
        Tuples of start and end indices for each percentage of `total`.
        
    See Also
    --------
    accumulate_percents : Alias for `apercents`
    asums : Alias for `apercents`
    '''
    pints = ipercents(total, *percents, ndigits=ndigits, useall=useall, overflow=overflow)
    asums = takewhile(lambda s: s <= total, accumulate(pints))
    return list(asums)

@wraps(apercents, assigned=WRAPS_ASSIGN_ANNDOCS)
def accumulate_percents(*args, **kwargs):
    '''Alias for `apercents`.'''
    return apercents(*args, **kwargs)

@wraps(apercents, assigned=WRAPS_ASSIGN_ANNDOCS)
def asums(*args, **kwargs):
    '''Alias for `apercents`.'''
    return apercents(*args, **kwargs)

# %% ../nbs/00_core.ipynb 31
def rpercents(
    total: int, 
    *percents: float, 
    ndigits: int = 3,
    useall: bool = True, 
    overflow: bool = False,
) -> tuple[tuple[int, int], ...]:
    '''Generates tuples representing ranges based on percentages of `total`.
    
    Parameters
    ----------
    total : int
        The total amount to divide according to `percents`.
        
    *percents : float
        Percentages to divide `total` into.
        
    ndigits : int, default: 3
        The number of decimal places to round percentages to.
        
    Returns
    -------
    tuple[tuple[int, int], ...]
        Tuples of start and end indices for each percentage of `total`.
        
    See Also
    --------
    range_percents : Alias for `rpercents`
    perbounds : Alias for `rpercents`
    idxstep : Alias for `rpercents`
    index_step : Alias for `rpercents`
    '''
    pints = ipercents(total, *percents, ndigits=ndigits, useall=useall, overflow=overflow)
    asums = apercents(total, *percents, ndigits=ndigits, useall=useall, overflow=overflow)
    return list((idx-off, idx) for off, idx in zip(pints, asums))

@wraps(rpercents, assigned=WRAPS_ASSIGN_ANNDOCS)
def perbounds(*args, **kwargs):
    '''Alias for `rpercents`.'''
    return rpercents(*args, **kwargs)

@wraps(rpercents, assigned=WRAPS_ASSIGN_ANNDOCS)
def range_percents(*args, **kwargs):
    '''Alias for `rpercents`.'''
    return rpercents(*args, **kwargs)

@wraps(rpercents, assigned=WRAPS_ASSIGN_ANNDOCS)
def idxstep(*args, **kwargs):
    '''Alias for `rpercents`.'''
    return rpercents(*args, **kwargs)


@wraps(rpercents, assigned=WRAPS_ASSIGN_ANNDOCS)
def index_step(*args, **kwargs):
    '''Alias for `rpercents`.'''
    return rpercents(*args, **kwargs)

# %% ../nbs/00_core.ipynb 33
def idxperm(total: int, *percents: float, seed: int = 3) -> tuple[tuple[Number, ...], ...]:
    '''Generates a permutation of indices divided into segments based on `percents` of `total`.
    
    Parameters
    ----------
    total : int
        The total number of indices to permute.
        
    *percents : float
        The percentages to divide the total indices into.
        
    seed : int, default 3
        The seed for the random number generator.
        
    Returns
    -------
    tuple[ints, ...]
        nums of indices for each segment based on `percents`.
        
    See Also
    --------
    idxstep : Generates a step of indices based on `percents` of `total`.
    permute_indicies : Alias for `idxperm`.
    index_split_by_percents : Alias for `idxperm`.
    pidxs : Alias for `idxperm`.
    '''
    idx = list(range(total))
    seedall(seed)
    random.shuffle(idx)
    return tuple(idx[a:b] for a, b in range_percents(total, *percents))

@wraps(idxperm, assigned=WRAPS_ASSIGN_ANNDOCS)
def permute_indicies(total: int, *percents: float, seed: int = 3) -> tuple[tuple[Number, ...], ...]:
    '''Alias for `idxperm`.'''
    return idxperm(total, *percents, seed=seed)

@wraps(idxperm, assigned=WRAPS_ASSIGN_ANNDOCS)
def index_split_by_percents(total: int, *percents: float, seed: int = 3) -> tuple[tuple[Number, ...], ...]:
    '''Alias for `idxperm`.'''
    return idxperm(total, *percents, seed=seed)


@wraps(idxperm, assigned=WRAPS_ASSIGN_ANNDOCS)
def pidxs(total: int, *percents: float, seed: int = 3) -> tuple[tuple[Number, ...], ...]:
    '''Alias for `idxperm`.'''
    return idxperm(total, *percents, seed=seed)

# %% ../nbs/00_core.ipynb 35
#| export
