# This file was auto-generated by Fern from our API Definition.

import os
import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .core.remove_none_from_dict import remove_none_from_dict
from .core.request_options import RequestOptions
from .environment import MixpeekEnvironment
from .errors.bad_request_error import BadRequestError
from .errors.forbidden_error import ForbiddenError
from .errors.internal_server_error import InternalServerError
from .errors.not_found_error import NotFoundError
from .errors.unauthorized_error import UnauthorizedError
from .errors.unprocessable_entity_error import UnprocessableEntityError
from .pipeline.client import AsyncPipelineClient, PipelineClient
from .storage.client import AsyncStorageClient, StorageClient
from .types.audio_params import AudioParams
from .types.configs_response import ConfigsResponse
from .types.csv_params import CsvParams
from .types.embedding_response import EmbeddingResponse
from .types.error_response import ErrorResponse
from .types.extract_response import ExtractResponse
from .types.generation_response import GenerationResponse
from .types.html_params import HtmlParams
from .types.http_validation_error import HttpValidationError
from .types.image_params import ImageParams
from .types.message import Message
from .types.modality import Modality
from .types.model import Model
from .types.models import Models
from .types.pdf_params import PdfParams
from .types.ppt_params import PptParams
from .types.pptx_params import PptxParams
from .types.settings import Settings
from .types.txt_params import TxtParams
from .types.video_params import VideoParams
from .types.xlsx_params import XlsxParams
from .user.client import AsyncUserClient, UserClient
from .workflow.client import AsyncWorkflowClient, WorkflowClient

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class BaseMixpeek:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propogate to these functions.

    Parameters:
        - base_url: typing.Optional[str]. The base url to use for requests from the client.

        - environment: MixpeekEnvironment. The environment to use for requests from the client. from .environment import MixpeekEnvironment

                                           Defaults to MixpeekEnvironment.DEFAULT

        - authorization: typing.Optional[str].

        - index_id: typing.Optional[str].

        - api_key: typing.Optional[typing.Union[str, typing.Callable[[], str]]].

        - timeout: typing.Optional[float]. The timeout to be used, in seconds, for requests by default the timeout is 60 seconds, unless a custom httpx client is used, in which case a default is not set.

        - httpx_client: typing.Optional[httpx.Client]. The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.
    ---
    from mixpeek.client import Mixpeek

    client = Mixpeek(
        authorization="YOUR_AUTHORIZATION",
        index_id="YOUR_INDEX_ID",
        api_key="YOUR_API_KEY",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: MixpeekEnvironment = MixpeekEnvironment.DEFAULT,
        authorization: typing.Optional[str] = None,
        index_id: typing.Optional[str] = None,
        api_key: typing.Optional[typing.Union[str, typing.Callable[[], str]]] = os.getenv("MIXPEEK_API_KEY"),
        timeout: typing.Optional[float] = None,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        _defaulted_timeout = timeout if timeout is not None else 60 if httpx_client is None else None
        if api_key is None:
            raise ApiError(
                body="The client must be instantiated be either passing in api_key or setting MIXPEEK_API_KEY"
            )
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            authorization=authorization,
            index_id=index_id,
            api_key=api_key,
            httpx_client=httpx.Client(timeout=_defaulted_timeout) if httpx_client is None else httpx_client,
            timeout=_defaulted_timeout,
        )
        self.user = UserClient(client_wrapper=self._client_wrapper)
        self.pipeline = PipelineClient(client_wrapper=self._client_wrapper)
        self.workflow = WorkflowClient(client_wrapper=self._client_wrapper)
        self.storage = StorageClient(client_wrapper=self._client_wrapper)

    def extract(
        self,
        *,
        file_url: typing.Optional[str] = OMIT,
        contents: typing.Optional[str] = OMIT,
        should_chunk: typing.Optional[bool] = OMIT,
        clean_text: typing.Optional[bool] = OMIT,
        max_characters_per_chunk: typing.Optional[int] = OMIT,
        extract_tags: typing.Optional[bool] = OMIT,
        summarize: typing.Optional[bool] = OMIT,
        pdf_settings: typing.Optional[PdfParams] = OMIT,
        html_settings: typing.Optional[HtmlParams] = OMIT,
        csv_settings: typing.Optional[CsvParams] = OMIT,
        ppt_settings: typing.Optional[PptParams] = OMIT,
        pptx_settings: typing.Optional[PptxParams] = OMIT,
        xlsx_settings: typing.Optional[XlsxParams] = OMIT,
        txt_settings: typing.Optional[TxtParams] = OMIT,
        audio_settings: typing.Optional[AudioParams] = OMIT,
        image_settings: typing.Optional[ImageParams] = OMIT,
        video_settings: typing.Optional[VideoParams] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ExtractResponse:
        """
        Parameters:
            - file_url: typing.Optional[str].

            - contents: typing.Optional[str].

            - should_chunk: typing.Optional[bool].

            - clean_text: typing.Optional[bool].

            - max_characters_per_chunk: typing.Optional[int].

            - extract_tags: typing.Optional[bool].

            - summarize: typing.Optional[bool].

            - pdf_settings: typing.Optional[PdfParams].

            - html_settings: typing.Optional[HtmlParams].

            - csv_settings: typing.Optional[CsvParams].

            - ppt_settings: typing.Optional[PptParams].

            - pptx_settings: typing.Optional[PptxParams].

            - xlsx_settings: typing.Optional[XlsxParams].

            - txt_settings: typing.Optional[TxtParams].

            - audio_settings: typing.Optional[AudioParams].

            - image_settings: typing.Optional[ImageParams].

            - video_settings: typing.Optional[VideoParams].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mixpeek.client import Mixpeek

        client = Mixpeek(
            authorization="YOUR_AUTHORIZATION",
            index_id="YOUR_INDEX_ID",
            api_key="YOUR_API_KEY",
        )
        client.extract()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if file_url is not OMIT:
            _request["file_url"] = file_url
        if contents is not OMIT:
            _request["contents"] = contents
        if should_chunk is not OMIT:
            _request["should_chunk"] = should_chunk
        if clean_text is not OMIT:
            _request["clean_text"] = clean_text
        if max_characters_per_chunk is not OMIT:
            _request["max_characters_per_chunk"] = max_characters_per_chunk
        if extract_tags is not OMIT:
            _request["extract_tags"] = extract_tags
        if summarize is not OMIT:
            _request["summarize"] = summarize
        if pdf_settings is not OMIT:
            _request["pdf_settings"] = pdf_settings
        if html_settings is not OMIT:
            _request["html_settings"] = html_settings
        if csv_settings is not OMIT:
            _request["csv_settings"] = csv_settings
        if ppt_settings is not OMIT:
            _request["ppt_settings"] = ppt_settings
        if pptx_settings is not OMIT:
            _request["pptx_settings"] = pptx_settings
        if xlsx_settings is not OMIT:
            _request["xlsx_settings"] = xlsx_settings
        if txt_settings is not OMIT:
            _request["txt_settings"] = txt_settings
        if audio_settings is not OMIT:
            _request["audio_settings"] = audio_settings
        if image_settings is not OMIT:
            _request["image_settings"] = image_settings
        if video_settings is not OMIT:
            _request["video_settings"] = video_settings
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "extract"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ExtractResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def base_generate(
        self,
        *,
        model: Model,
        response_format: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        context: typing.Optional[str] = OMIT,
        messages: typing.Sequence[Message],
        settings: typing.Optional[Settings] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GenerationResponse:
        """
        Parameters:
            - model: Model. The model to be used.

            - response_format: typing.Optional[typing.Dict[str, typing.Any]].

            - context: typing.Optional[str].

            - messages: typing.Sequence[Message]. The messages for the generation.

            - settings: typing.Optional[Settings].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mixpeek import Message, Model
        from mixpeek.client import Mixpeek

        client = Mixpeek(
            authorization="YOUR_AUTHORIZATION",
            index_id="YOUR_INDEX_ID",
            api_key="YOUR_API_KEY",
        )
        client.base_generate(
            model=Model(
                provider="provider",
                model="gpt-3.5-turbo",
            ),
            messages=[
                Message(
                    role="role",
                    content="content",
                )
            ],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"model": model, "messages": messages}
        if response_format is not OMIT:
            _request["response_format"] = response_format
        if context is not OMIT:
            _request["context"] = context
        if settings is not OMIT:
            _request["settings"] = settings
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "generate/text"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GenerationResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_model_config(
        self,
        *,
        modality: typing.Optional[Modality] = OMIT,
        model: typing.Optional[Models] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ConfigsResponse:
        """
        Parameters:
            - modality: typing.Optional[Modality].

            - model: typing.Optional[Models].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mixpeek.client import Mixpeek

        client = Mixpeek(
            authorization="YOUR_AUTHORIZATION",
            index_id="YOUR_INDEX_ID",
            api_key="YOUR_API_KEY",
        )
        client.get_model_config()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if modality is not OMIT:
            _request["modality"] = modality
        if model is not OMIT:
            _request["model"] = model
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "embed/config"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConfigsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def embed(
        self,
        *,
        input: str,
        modality: typing.Optional[Modality] = OMIT,
        model: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EmbeddingResponse:
        """
        Parameters:
            - input: str. The input data to be processed.

            - modality: typing.Optional[Modality].

            - model: typing.Optional[str].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mixpeek.client import Mixpeek

        client = Mixpeek(
            authorization="YOUR_AUTHORIZATION",
            index_id="YOUR_INDEX_ID",
            api_key="YOUR_API_KEY",
        )
        client.embed(
            input="input",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"input": input}
        if modality is not OMIT:
            _request["modality"] = modality
        if model is not OMIT:
            _request["model"] = model
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "embed"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EmbeddingResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncBaseMixpeek:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propogate to these functions.

    Parameters:
        - base_url: typing.Optional[str]. The base url to use for requests from the client.

        - environment: MixpeekEnvironment. The environment to use for requests from the client. from .environment import MixpeekEnvironment

                                           Defaults to MixpeekEnvironment.DEFAULT

        - authorization: typing.Optional[str].

        - index_id: typing.Optional[str].

        - api_key: typing.Optional[typing.Union[str, typing.Callable[[], str]]].

        - timeout: typing.Optional[float]. The timeout to be used, in seconds, for requests by default the timeout is 60 seconds, unless a custom httpx client is used, in which case a default is not set.

        - httpx_client: typing.Optional[httpx.AsyncClient]. The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.
    ---
    from mixpeek.client import AsyncMixpeek

    client = AsyncMixpeek(
        authorization="YOUR_AUTHORIZATION",
        index_id="YOUR_INDEX_ID",
        api_key="YOUR_API_KEY",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: MixpeekEnvironment = MixpeekEnvironment.DEFAULT,
        authorization: typing.Optional[str] = None,
        index_id: typing.Optional[str] = None,
        api_key: typing.Optional[typing.Union[str, typing.Callable[[], str]]] = os.getenv("MIXPEEK_API_KEY"),
        timeout: typing.Optional[float] = None,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        _defaulted_timeout = timeout if timeout is not None else 60 if httpx_client is None else None
        if api_key is None:
            raise ApiError(
                body="The client must be instantiated be either passing in api_key or setting MIXPEEK_API_KEY"
            )
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            authorization=authorization,
            index_id=index_id,
            api_key=api_key,
            httpx_client=httpx.AsyncClient(timeout=_defaulted_timeout) if httpx_client is None else httpx_client,
            timeout=_defaulted_timeout,
        )
        self.user = AsyncUserClient(client_wrapper=self._client_wrapper)
        self.pipeline = AsyncPipelineClient(client_wrapper=self._client_wrapper)
        self.workflow = AsyncWorkflowClient(client_wrapper=self._client_wrapper)
        self.storage = AsyncStorageClient(client_wrapper=self._client_wrapper)

    async def extract(
        self,
        *,
        file_url: typing.Optional[str] = OMIT,
        contents: typing.Optional[str] = OMIT,
        should_chunk: typing.Optional[bool] = OMIT,
        clean_text: typing.Optional[bool] = OMIT,
        max_characters_per_chunk: typing.Optional[int] = OMIT,
        extract_tags: typing.Optional[bool] = OMIT,
        summarize: typing.Optional[bool] = OMIT,
        pdf_settings: typing.Optional[PdfParams] = OMIT,
        html_settings: typing.Optional[HtmlParams] = OMIT,
        csv_settings: typing.Optional[CsvParams] = OMIT,
        ppt_settings: typing.Optional[PptParams] = OMIT,
        pptx_settings: typing.Optional[PptxParams] = OMIT,
        xlsx_settings: typing.Optional[XlsxParams] = OMIT,
        txt_settings: typing.Optional[TxtParams] = OMIT,
        audio_settings: typing.Optional[AudioParams] = OMIT,
        image_settings: typing.Optional[ImageParams] = OMIT,
        video_settings: typing.Optional[VideoParams] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ExtractResponse:
        """
        Parameters:
            - file_url: typing.Optional[str].

            - contents: typing.Optional[str].

            - should_chunk: typing.Optional[bool].

            - clean_text: typing.Optional[bool].

            - max_characters_per_chunk: typing.Optional[int].

            - extract_tags: typing.Optional[bool].

            - summarize: typing.Optional[bool].

            - pdf_settings: typing.Optional[PdfParams].

            - html_settings: typing.Optional[HtmlParams].

            - csv_settings: typing.Optional[CsvParams].

            - ppt_settings: typing.Optional[PptParams].

            - pptx_settings: typing.Optional[PptxParams].

            - xlsx_settings: typing.Optional[XlsxParams].

            - txt_settings: typing.Optional[TxtParams].

            - audio_settings: typing.Optional[AudioParams].

            - image_settings: typing.Optional[ImageParams].

            - video_settings: typing.Optional[VideoParams].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mixpeek.client import AsyncMixpeek

        client = AsyncMixpeek(
            authorization="YOUR_AUTHORIZATION",
            index_id="YOUR_INDEX_ID",
            api_key="YOUR_API_KEY",
        )
        await client.extract()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if file_url is not OMIT:
            _request["file_url"] = file_url
        if contents is not OMIT:
            _request["contents"] = contents
        if should_chunk is not OMIT:
            _request["should_chunk"] = should_chunk
        if clean_text is not OMIT:
            _request["clean_text"] = clean_text
        if max_characters_per_chunk is not OMIT:
            _request["max_characters_per_chunk"] = max_characters_per_chunk
        if extract_tags is not OMIT:
            _request["extract_tags"] = extract_tags
        if summarize is not OMIT:
            _request["summarize"] = summarize
        if pdf_settings is not OMIT:
            _request["pdf_settings"] = pdf_settings
        if html_settings is not OMIT:
            _request["html_settings"] = html_settings
        if csv_settings is not OMIT:
            _request["csv_settings"] = csv_settings
        if ppt_settings is not OMIT:
            _request["ppt_settings"] = ppt_settings
        if pptx_settings is not OMIT:
            _request["pptx_settings"] = pptx_settings
        if xlsx_settings is not OMIT:
            _request["xlsx_settings"] = xlsx_settings
        if txt_settings is not OMIT:
            _request["txt_settings"] = txt_settings
        if audio_settings is not OMIT:
            _request["audio_settings"] = audio_settings
        if image_settings is not OMIT:
            _request["image_settings"] = image_settings
        if video_settings is not OMIT:
            _request["video_settings"] = video_settings
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "extract"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ExtractResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def base_generate(
        self,
        *,
        model: Model,
        response_format: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        context: typing.Optional[str] = OMIT,
        messages: typing.Sequence[Message],
        settings: typing.Optional[Settings] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GenerationResponse:
        """
        Parameters:
            - model: Model. The model to be used.

            - response_format: typing.Optional[typing.Dict[str, typing.Any]].

            - context: typing.Optional[str].

            - messages: typing.Sequence[Message]. The messages for the generation.

            - settings: typing.Optional[Settings].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mixpeek import Message, Model
        from mixpeek.client import AsyncMixpeek

        client = AsyncMixpeek(
            authorization="YOUR_AUTHORIZATION",
            index_id="YOUR_INDEX_ID",
            api_key="YOUR_API_KEY",
        )
        await client.base_generate(
            model=Model(
                provider="provider",
                model="gpt-3.5-turbo",
            ),
            messages=[
                Message(
                    role="role",
                    content="content",
                )
            ],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"model": model, "messages": messages}
        if response_format is not OMIT:
            _request["response_format"] = response_format
        if context is not OMIT:
            _request["context"] = context
        if settings is not OMIT:
            _request["settings"] = settings
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "generate/text"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GenerationResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_model_config(
        self,
        *,
        modality: typing.Optional[Modality] = OMIT,
        model: typing.Optional[Models] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ConfigsResponse:
        """
        Parameters:
            - modality: typing.Optional[Modality].

            - model: typing.Optional[Models].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mixpeek.client import AsyncMixpeek

        client = AsyncMixpeek(
            authorization="YOUR_AUTHORIZATION",
            index_id="YOUR_INDEX_ID",
            api_key="YOUR_API_KEY",
        )
        await client.get_model_config()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if modality is not OMIT:
            _request["modality"] = modality
        if model is not OMIT:
            _request["model"] = model
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "embed/config"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConfigsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def embed(
        self,
        *,
        input: str,
        modality: typing.Optional[Modality] = OMIT,
        model: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EmbeddingResponse:
        """
        Parameters:
            - input: str. The input data to be processed.

            - modality: typing.Optional[Modality].

            - model: typing.Optional[str].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mixpeek.client import AsyncMixpeek

        client = AsyncMixpeek(
            authorization="YOUR_AUTHORIZATION",
            index_id="YOUR_INDEX_ID",
            api_key="YOUR_API_KEY",
        )
        await client.embed(
            input="input",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"input": input}
        if modality is not OMIT:
            _request["modality"] = modality
        if model is not OMIT:
            _request["model"] = model
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "embed"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EmbeddingResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


def _get_base_url(*, base_url: typing.Optional[str] = None, environment: MixpeekEnvironment) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception("Please pass in either base_url or environment to construct the client")
