# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_misc.ipynb.

# %% auto 0
__all__ = ['pair', 'steps', 'increment_pairs', 'generate_steps', 'calcgrid', 'grididx', 'pad4grid', 'takekeys']

# %% ../nbs/10_misc.ipynb 6
import math
from functools import wraps, singledispatch
from itertools import takewhile, count

# %% ../nbs/10_misc.ipynb 8
from numbers import Number
from typing import Generator, Iterator, Iterable, overload

# %% ../nbs/10_misc.ipynb 11
#| export

# %% ../nbs/10_misc.ipynb 13
#| export


# %% ../nbs/10_misc.ipynb 15
#| export


# %% ../nbs/10_misc.ipynb 17
#| export


# %% ../nbs/10_misc.ipynb 19
from atup import fillnone
from quac import nums, rect, xypos
from chck import isdict

# %% ../nbs/10_misc.ipynb 21
from .cons import WRAPS_ASSIGN_ANNDOCS

# %% ../nbs/10_misc.ipynb 23
def pair(a: nums, n: int = 2, i: int = 1) -> tuple[nums, ...]:
    '''Pair numbers in an array
    
    Parameters
    ----------
    a: ints
        array iterable of numbers to pair
        
    n: int
        The number to of elements pair in each tuple
        
    i: int
        The number to increment between elements in `a`
        
    Returns
    -------
    tuple[ints, ...]
        tuple of paired numbers each containing `n` paired elements from `a`.
        
    Examples
    --------
    >>> pair(np.arange(1, 6), 2)
    [(1, 2), (2, 3), (3, 4), (4, 5)]
    
    >>> pair(np.arange(1, 6), 3)
    [(1, 2, 3), (2, 3, 4), (3, 4, 5)]
    
    >>> pair(np.arange(1, 6), 2, 2)
    [(1, 3), (2, 4), (3, 5)]
    
    See Also
    --------
    steps: Alias for `pair`.
    '''
    if not isinstance(a, Iterable): a = [a]
    return tuple(zip(a, *(a[(i * _):] for _ in range(1, n))))

@wraps(pair, assigned=WRAPS_ASSIGN_ANNDOCS)
def steps(*args, **kwargs):
    '''Alias for `pair`.'''
    return pair(*args, **kwargs)

@wraps(pair, assigned=WRAPS_ASSIGN_ANNDOCS)
def increment_pairs(*args, **kwargs):
    return pair(*args, **kwargs)

# %% ../nbs/10_misc.ipynb 26
def generate_steps(incr, step, stop):
    '''
    Generate a list of tuples representing step intervals from 0 up to stop,
    incrementing by incr and ensuring each step interval does not exceed step.
    
    Parameters
    ----------
    incr : int
        The increment between each start of the step intervals.
    step : int
        The maximum allowed difference between the start and end of each interval.
    stop : int
        The stopping point for the generation of intervals.
    
    Returns
    -------
    list of tuples
        A list of tuples, where each tuple contains the start and end of each step interval.
        
    Examples
    --------
    >>> incr = 3
    ... step = 2
    ... stop = 10
    ... vals = generate_steps(incr, step, stop)

    ... firstvals = [v[0] for v in vals]
    ... firstdiff = tuple(b - a for a, b in zip(firstvals, firstvals[1:]))

    ... step_diff = tuple(b - a for a, b in vals)
    ... good_step = all(e <= step for e in step_diff)

    ... good_end = vals[-1][-1] == stop
    ... good_inc = all(e == incr for e in firstdiff)

    ... # each tuple increments by +incr, has a (a, b) diff of <= step and ends at stop
    ... all_valid = good_inc and good_step and good_end
    ... vals, all_valid

    '''
    # Use takewhile to generate values up to the stop condition
    vals_gen = takewhile(lambda x: x < stop, count(0, incr))
    
    # Generate the list of tuples with the specified conditions
    vals = [(i, min(i + step, stop)) for i in vals_gen]
    
    return vals

# %% ../nbs/10_misc.ipynb 32
def calcgrid(n: int) -> rect:
    '''
    Find the closest rectangle layout that accommodates n elements.

    Parameters
    ----------
    n : int
        The number of elements to accommodate in the grid.

    Returns
    -------
    Grid
        A tuple representing the dimensions (rows, cols) of the grid.
    '''
    x = math.isqrt(n)
    while n % x != 0: x -= 1
    y = n // x
    return x, y

# %% ../nbs/10_misc.ipynb 34
def grididx(pos: xypos, grid: rect) -> int:
    '''
    Calculate the linear index of an element in a `grid` given its `(row, col)` position (`pos`).

    Parameters
    ----------
    pos : XYPos
        A tuple representing the row and column position of the element in the grid.
    grid : Grid
        A tuple representing the dimensions of the grid (rows, columns).

    Returns
    -------
    int
        The linear index of the element in the grid.
    '''
    nrows, ncols = grid
    cur_r, cur_c = pos
    return cur_r * ncols + cur_c

# %% ../nbs/10_misc.ipynb 36
@overload
def pad4grid(arr: list, rows: int, cols: int) -> list: ...
@overload
def pad4grid(arr: list, n: int) -> list: ...
def pad4grid(arr: list, *args) -> list:
    '''
    Pad the list of objects to the closest grid layout that accommodates a specified number of elements.

    Parameters
    ----------
    arr : list
        The list to be padded.
    args : int
        The dimensions of the grid `(rows, cols)` or the total number of elements `n`.

    Returns
    -------
    list
        The padded list.
    '''
    rows, cols = args[0], (1 if len(args) <= 1 else args[1])
    return list(fillnone(arr, rows * cols))

# %% ../nbs/10_misc.ipynb 38
def takekeys(d: dict, keys: list | dict) -> dict:
    keys = keys or []
    if isdict(keys): keys = keys.keys()
    return {k: d.get(k, None) for k in keys if k in d}

# %% ../nbs/10_misc.ipynb 40
#| export
