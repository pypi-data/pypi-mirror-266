# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['OS', 'JOBLIB', 'MULTIPROCESSING', 'CPU_COUNT', 'SCHED_GETAFFINITY', 'P', 'Module', 'Method', 'mod_cpu_count',
           'getaffinity0', 'os_cpu_count', 'jl_cpu_count', 'mp_cpu_count', 'numcores', 'ncpus', 'ncores', 'nworkers',
           'getcores', 'getcpus', 'getworkers', 'numcpus', 'numworkers']

# %% ../nbs/00_core.ipynb 6
# import os, joblib, multiprocessing
from importlib import import_module
from inspect import signature
from enum import StrEnum, auto
from functools import wraps

# %% ../nbs/00_core.ipynb 8
from types import ModuleType
from typing import ParamSpec

# %% ../nbs/00_core.ipynb 10
#| export


# %% ../nbs/00_core.ipynb 12
#| export


# %% ../nbs/00_core.ipynb 16
OS = 'os'
'''Module name for the `os` module, typically used for system operations.''';

JOBLIB = 'joblib'
'''Module name for the `joblib` library, often used for parallel computing.''';

MULTIPROCESSING = 'multiprocessing'
'''Module name for the `multiprocessing` module, enables concurrent programming.''';

CPU_COUNT = 'cpu_count'
'''Method name within modules to get the count of available CPUs.''';

SCHED_GETAFFINITY = 'sched_getaffinity'
'''Method name within the `os` module to get the set of CPUs available to the current process.''';

# %% ../nbs/00_core.ipynb 17
__DOC__ = '__doc__'
__MODULE__ = '__module__'
__ANNOTATIONS__ = '__annotations__'

_ASSIGNED = (__DOC__, __MODULE__, __ANNOTATIONS__)

# %% ../nbs/00_core.ipynb 19
class Module(StrEnum):
    '''
    Enum class representing different modules that can be used to determine CPU counts
    or system-specific details. These modules include standard libraries and third-party
    libraries known for their utility in parallel and system programming.

    Attributes
    ----------
    os : str
        Represents the built-in `os` module.
    joblib : str
        Represents the `joblib` module, a popular library for easy parallel computing.
    multiprocessing : str
        Represents the `multiprocessing` module, a built-in library for concurrent programming.
    jl : str    
        Alias for the `joblib` module, a popular library for easy parallel computing.
    mp : str    
        Alias for the `multiprocessing` module, a built-in library for concurrent programming.
    '''
    os = OS
    joblib = JOBLIB
    multiprocessing = MULTIPROCESSING
    jl = joblib
    mp = multiprocessing
    
class Method(StrEnum):
    '''
    Enum class representing different method names that are commonly used across various
    modules to determine CPU counts or process-specific CPU affinities. These methods
    provide interfaces to system-level queries about hardware and process capabilities.

    Attributes
    ----------
    cpu_count : str
        Method name used to retrieve the number of available CPUs or cores.
    sched_getaffinity : str
        Method name specific to the `os` module for getting CPU affinity of the current process.
    '''
    cpu_count = CPU_COUNT
    sched_getaffinity = SCHED_GETAFFINITY

# %% ../nbs/00_core.ipynb 21
P = ParamSpec('P')

# %% ../nbs/00_core.ipynb 23
def mod_cpu_count(module: str | Module | ModuleType, method: str | Method = CPU_COUNT, *args: P.args, **kwargs: P.kwargs) -> int:
    '''
    Dynamically loads a module and executes a specified method within it, typically used
    to determine the number of CPU cores.

    Parameters
    ----------
    module : str | Module | ModuleType
        The module to load, either as a string module name or `ModuleType` instance.
        
    method : str | Method, default: Method.cpu_count
        The method within the module to execute, by default `cpu_count`.
    *args
        Variable length argument list to be passed to the method.
    **kwargs
        Arbitrary keyword arguments to be passed to the method.

    Returns
    -------
    int
        The return value of the executed method, often the number of CPU cores.
    '''
    if isinstance(module, (str, Method)): 
        module = import_module(str(module))
        
    func = getattr(module, method)
    fsig = signature(func)
    barg = fsig.bind(*args, **kwargs)
    return func(*barg.args, **barg.kwargs)

# %% ../nbs/00_core.ipynb 24
def getaffinity0() -> int:
    '''
    Determines the number of available CPUs by checking the CPU affinity of the current process.

    Returns
    -------
    int
        The number of CPUs available to the current process, or 0 if unable to determine.
    '''
    import os
    if hasattr(os, SCHED_GETAFFINITY):
        cpus = os.sched_getaffinity(0)
        return len(cpus)
    return 0

def os_cpu_count() -> int:
    '''
    Attempts to determine the number of CPU cores available using OS-specific methods.

    Returns
    -------
    int
        The number of CPU cores determined, falling back to alternative methods if necessary.
    '''
    return getaffinity0() or mod_cpu_count(OS)

def jl_cpu_count() -> int:
    '''
    Determines the number of CPU cores available using the `joblib` library.

    Returns
    -------
    int
        The number of CPU cores as determined by the `joblib` library.
    '''
    return mod_cpu_count(JOBLIB)

def mp_cpu_count() -> int:
    '''
    Determines the number of CPU cores available using the `multiprocessing` library.

    Returns
    -------
    int
        The number of CPU cores as determined by the `multiprocessing` library.
    '''
    return mod_cpu_count(MULTIPROCESSING)

# %% ../nbs/00_core.ipynb 25
def numcores(module: str | Module | ModuleType = OS) -> int:
    '''
    Generic function to determine the number of CPU cores available, supporting multiple
    methods based on the input module name or object.

    Parameters
    ----------
    module : str | Module | ModuleType, default: `os`
        The module to use for determining the CPU count, by default 'os'.

    Returns
    -------
    int
        The determined number of CPU cores.
        
    See Also
    --------
    ncpus : Alias for `numcores`.
    ncores : Alias for `numcores`.
    numcpus : Alias for `numcores`.
    getcpus : Alias for `numcores`.
    nworkers : Alias for `numcores`.
    getcores : Alias for `numcores`.
    getworkers : Alias for `numcores`.
    numworkers : Alias for `numcores`.
    '''
    if isinstance(module, ModuleType): module = module.__name__
    match module:
        case 'os': return os_cpu_count()
        case 'jl': return jl_cpu_count()
        case 'mp': return mp_cpu_count()
        case 'joblib': return jl_cpu_count()
        case 'multiprocessing': return mp_cpu_count()
        case _: return os_cpu_count()
    return 0


@wraps(numcores, assigned=_ASSIGNED)
def ncpus(module: str | Module | ModuleType = OS) -> int:
    return numcores(module)
    
@wraps(numcores, assigned=_ASSIGNED)
def ncores(module: str | Module | ModuleType = OS) -> int:
    return numcores(module)
    
@wraps(numcores, assigned=_ASSIGNED)
def nworkers(module: str | Module | ModuleType = OS) -> int:
    return numcores(module)
    

@wraps(numcores, assigned=_ASSIGNED)
def getcores(module: str | Module | ModuleType = OS) -> int:
    return numcores(module)
    
@wraps(numcores, assigned=_ASSIGNED)
def getcpus(module: str | Module | ModuleType = OS) -> int:
    return numcores(module)
    
@wraps(numcores, assigned=_ASSIGNED)
def getworkers(module: str | Module | ModuleType = OS) -> int:
    return numcores(module)
    

@wraps(numcores, assigned=_ASSIGNED)
def numcpus(module: str | Module | ModuleType = OS) -> int:
    return numcores(module)
    
@wraps(numcores, assigned=_ASSIGNED)
def numworkers(module: str | Module | ModuleType = OS) -> int:
    return numcores(module)
    

# %% ../nbs/00_core.ipynb 27
#| export
