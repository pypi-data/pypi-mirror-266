// Generated by QCompiler on Sat 04/06/2024 20:55:35

#include "Python.h"
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <algorithm>
#include "structmember.h"

// EXCEPTIONS

PyObject *PException;

class CException {
public:
    CException(const char *_message) : message(_message) {}
    const char *message;
};

void abort(const char *_message) {
    throw CException(_message);
}

void abortInternal() {
    abort("QPLEX internal error");
}

void abortImport() {
    abort("Invalid value");
}

double checkDenominator(double x) {
    if (x == 0)
        abort("Divide by zero");
    else
        return x;
}

// SCALAR TYPES

typedef int Int;
typedef double Real;
typedef bool Boolean;

enum PmfType { SIMPLE, JOINT, COMPOUND };

// STRUCT TYPES

#define sizeOfStructWithArraySize(type, array, length) (offsetof(type, array[0]) + (length) * (offsetof(type, array[1]) - offsetof(type, array[0])))

typedef struct MemHeader {
    MemHeader *next;
    size_t size;
    bool flag;
} MemHeader;

typedef struct {
} SimplePmfConfigOverlay;

typedef struct {
    int depth;
} JointPmfConfigOverlay;

typedef struct {
    int length;
    int depths[];
} CompoundPmfConfigOverlay;

typedef struct PmfConfig {
    MemHeader memHeader;
    PmfType pmfType;
    union {
        SimplePmfConfigOverlay simple;
        JointPmfConfigOverlay joint;
        CompoundPmfConfigOverlay compound;
    };
} PmfConfig;

struct Pmf;
typedef struct {
    int offset, length;
    Real elements[1];
} SimplePmfOverlay;

typedef struct {
    int depth;
    Pmf *marginal;
    Pmf *elements[1];
} JointPmfOverlay;

typedef struct {
    int length;
    Pmf *elements[1];
} CompoundPmfOverlay;

typedef struct Pmf {
    MemHeader memHeader;
    PmfType pmfType;
    union {
        SimplePmfOverlay simple;
        JointPmfOverlay joint;
        CompoundPmfOverlay compound;
    };
} Pmf;

typedef struct {
    MemHeader memHeader;
    int length;
    Int elements[1];
} IntArray;

typedef struct {
    MemHeader memHeader;
    int length;
    Real elements[1];
} RealArray;

typedef struct {
    MemHeader memHeader;
    int length;
    Boolean elements[1];
} BooleanArray;

typedef struct {
    MemHeader memHeader;
    int length;
    IntArray *elements[1];
} IntMatrix;

typedef struct {
    MemHeader memHeader;
    int length;
    RealArray *elements[1];
} RealMatrix;

typedef struct {
    MemHeader memHeader;
    int length;
    BooleanArray *elements[1];
} BooleanMatrix;

typedef struct {
    MemHeader memHeader;
    int length;
    Pmf *elements[1];
} PmfArray;

typedef struct {
    MemHeader memHeader;
    int length;
    PmfArray *elements[1];
} PmfMatrix;

typedef struct {
    MemHeader memHeader;
    int length;
    void *elements[1];
} InterfaceArray;

typedef struct {
    MemHeader memHeader;
    int length;
    InterfaceArray *elements[1];
} InterfaceMatrix;

// Q OBJECT AND MEMORY ALLOCATION

typedef struct {
    PyObject_HEAD
    bool isMemModified;
    MemHeader *memList;
    int functionCount;
    void **functionPointers;
    const char **functionNames;
    int *functionSignatureIndexes;
    unsigned long long currentMemoryUse;
    unsigned long long peakMemoryUse;
} QObject;

void *qmalloc(QObject *obj, size_t size) {
    obj->isMemModified = true;
    obj->currentMemoryUse += size;
    if (obj->currentMemoryUse > obj->peakMemoryUse)
        obj->peakMemoryUse = obj->currentMemoryUse;

    MemHeader *ptr = (MemHeader *) malloc(size);
    if (!ptr)
        abort("Out of memory");

    memset(ptr, 0, size);
    
    MemHeader *memHeader = (MemHeader *) ptr;
    memHeader->next = obj->memList;
    obj->memList = memHeader;
    
    ptr->size = size;
    return ptr;
}

void release(QObject *obj) {
    MemHeader *p = obj->memList;
    obj->memList = NULL;
    
    while (p) {
        MemHeader *next = p->next;
        
        if (p->flag) {
            p->flag = false;
            MemHeader *memHeader = (MemHeader *) p;
            memHeader->next = obj->memList;
            obj->memList = memHeader;
        } else {
            obj->currentMemoryUse -= p->size;
            free(p);
        }
        
        p = next;
     }
            
     obj->isMemModified = false;
}

void dealloc(QObject *obj) {
    release(obj);
    Py_TYPE(obj)->tp_free((PyObject *) obj);
}

void _flag(void *ptr0) {
    if (!ptr0)
        return;
    MemHeader *ptr = (MemHeader *) ptr0;
    ptr->flag = true;
}

void flag(Pmf *pmf) {
    if (!pmf)
        return;
    _flag(pmf);
    switch(pmf->pmfType) {
    case SIMPLE:
        break;
    case JOINT: {
        flag(pmf->joint.marginal);
        for (int i=0; i<pmf->joint.marginal->simple.length; i++)
            flag(pmf->joint.elements[i]);   
        break;
    }
    case COMPOUND:
        for (int i=0; i<pmf->compound.length; i++)
            flag(pmf->compound.elements[i]);   
        break;
    }
}

void flag(IntArray *a) {
    _flag(a);
}

void flag(RealArray *a) {
    _flag(a);
}

void flag(BooleanArray *a) {
    _flag(a);
}

void flag(PmfArray *a) {
    _flag(a);
    for (int i=0; i<a->length; i++)
      flag(a->elements[i]);
}

void flag(InterfaceArray *a) {
    _flag(a);
}

void flag(IntMatrix *m) {
    _flag(m);
    for (int i=0; i<m->length; i++)
      flag(m->elements[i]);
}

void flag(RealMatrix *m) {
    _flag(m);
    for (int i=0; i<m->length; i++)
      flag(m->elements[i]);
}

void flag(BooleanMatrix *m) {
    _flag(m);
    for (int i=0; i<m->length; i++)
      flag(m->elements[i]);
}

void flag(PmfMatrix *m) {
    _flag(m);
    for (int i=0; i<m->length; i++)
      flag(m->elements[i]);
}

void flag(InterfaceMatrix *m) {
    _flag(m);
    for (int i=0; i<m->length; i++)
      flag(m->elements[i]);
}

// SAMPLE ENUMERATOR

typedef struct {
    Int value;
    Real probability;
    Pmf *pmf;
} SampleEnumeratorRecord;

class SampleEnumerator {
public:
    bool isPrevious;
    int depth, level;
    SampleEnumeratorRecord *records;
    SampleEnumerator(Pmf *_pmf);
    virtual ~SampleEnumerator();
    void run();
    virtual void recordSample() = 0;
};

SampleEnumerator::SampleEnumerator(Pmf *pmf) : isPrevious(false) {
    switch (pmf->pmfType) {
        case SIMPLE:
            depth = 1;
            break;
        case JOINT:
            depth = pmf->joint.depth;
            break;
        case COMPOUND:
            abortInternal();
    }
    
    records = (SampleEnumeratorRecord *) malloc((depth+1) * sizeof(SampleEnumeratorRecord));
    records[0].probability = 1;
    records[0].pmf = pmf;
    level = 0;
}

SampleEnumerator::~SampleEnumerator() {
    free(records);
}

void SampleEnumerator::run() {
    if (level == depth) {
        recordSample();
        return;
    }
    
    Pmf *marginal;
    switch (records[level].pmf->pmfType) {
        case SIMPLE:
            marginal = records[level].pmf;
            break;
        case JOINT:
            marginal = records[level].pmf->joint.marginal;
            break;
        case COMPOUND:
            abortInternal();
    }
    
    level++;
    for (int i=0; i<marginal->simple.length; i++) {
        Real branchProbability = marginal->simple.elements[i];
        if (branchProbability <= 0)
            continue;
        records[level].value = i + marginal->simple.offset;
        records[level].probability = records[level-1].probability * branchProbability;
        records[level].pmf = records[level-1].pmf->joint.elements[i];
        run();
    }
    level--;
}

// ALLOCATE

Pmf *allocateSimplePmf(QObject *obj, int offset, int length) {
    size_t size = sizeOfStructWithArraySize(Pmf, simple.elements, length);
    Pmf *pmf = (Pmf *) qmalloc(obj, size);
    pmf->pmfType = SIMPLE;
    pmf->simple.offset = offset;
    pmf->simple.length = length;
    return pmf;
}

Pmf *allocateJointPmf(QObject *obj, Pmf *marginal, int depth) {
    size_t size = sizeOfStructWithArraySize(Pmf, joint.elements, marginal->simple.length);
    Pmf *pmf = (Pmf *) qmalloc(obj, size);
    pmf->pmfType = JOINT;
    pmf->joint.marginal = marginal;
    pmf->joint.depth = depth;
    return pmf;
}

Pmf *allocateEmptyJointPmf(QObject *obj, int depth) {
    Pmf *marginal = allocateSimplePmf(obj, 0, 0);
    return allocateJointPmf(obj, marginal, depth);
}

Pmf *allocateCompoundPmf(QObject *obj, int length) {
    size_t size = sizeOfStructWithArraySize(Pmf, compound.elements, length);
    Pmf *pmf = (Pmf *) qmalloc(obj, size);
    pmf->pmfType = COMPOUND;
    pmf->compound.length = length;
    return pmf;
}

PmfArray *allocatePmfArray(QObject *obj, int length) {
    if (length <= 0)
        abort("Invalid array size");

    size_t size = sizeOfStructWithArraySize(PmfArray, elements, length);
    PmfArray *a = (PmfArray *) qmalloc(obj, size);
    a->length = length;
    return a;
}

PmfMatrix *allocatePmfMatrix(QObject *obj, int rowCount, int columnCount) {
    size_t size = sizeOfStructWithArraySize(PmfMatrix, elements, rowCount);
    PmfMatrix *m = (PmfMatrix *) qmalloc(obj, size);
    m->length = rowCount;

    if (columnCount)
        for (int i=0; i<rowCount; i++)
            m->elements[i] = allocatePmfArray(obj, columnCount);

    return m;
}

InterfaceArray *allocateInterfaceArray(QObject *obj, int length) {
    if (length <= 0)
        abort("Invalid array size");

    size_t size = sizeOfStructWithArraySize(InterfaceArray, elements, length);
    InterfaceArray *a = (InterfaceArray *) qmalloc(obj, size);
    a->length = length;
    return a;
}

InterfaceMatrix *allocateInterfaceMatrix(QObject *obj, int rowCount, int columnCount) {
    size_t size = sizeOfStructWithArraySize(InterfaceMatrix, elements, rowCount);
    InterfaceMatrix *m = (InterfaceMatrix *) qmalloc(obj, size);
    m->length = rowCount;

    if (columnCount)
        for (int i=0; i<rowCount; i++)
            m->elements[i] = allocateInterfaceArray(obj, columnCount);

    return m;
}

// CREATE

PmfConfig *createSimplePmfConfig(QObject *obj) {
    size_t size = offsetof(PmfConfig, simple);
    PmfConfig *pmfConfig = (PmfConfig *) qmalloc(obj, size);
    pmfConfig->pmfType = SIMPLE;
    return pmfConfig;
}

PmfConfig *createJointPmfConfig(QObject *obj, int depth) {
    size_t size = offsetof(PmfConfig, joint) + sizeof(JointPmfConfigOverlay);
    PmfConfig *pmfConfig = (PmfConfig *) qmalloc(obj, size);
    pmfConfig->pmfType = JOINT;
    pmfConfig->joint.depth = depth;
    return pmfConfig;
}

PmfConfig *createCompoundPmfConfig(QObject *obj, int length, ...) {
    size_t size = sizeOfStructWithArraySize(PmfConfig, compound.depths, length);
    PmfConfig *pmfConfig = (PmfConfig *) qmalloc(obj, size);
    pmfConfig->pmfType = COMPOUND;
    pmfConfig->compound.length = length;
    va_list valist;
    va_start(valist, length);
    for (int i = 0; i < length; i++) {
        int depth = va_arg(valist, int);
        pmfConfig->compound.depths[i] = depth;
    }
    va_end(valist);
    return pmfConfig;
}

Pmf *createCompoundPmf(QObject *obj, int length, ...) {
    Pmf *pmf = allocateCompoundPmf(obj, length);
    va_list valist;
    va_start(valist, length);
    for (int i = 0; i < length; i++) {
        Pmf *innerPmf = va_arg(valist, Pmf *);
        pmf->compound.elements[i] = innerPmf;
    }
    va_end(valist);
    return pmf;
}

IntArray *createIntArray(QObject *obj, int length) {
    if (length <= 0)
        abort("Invalid array size");
    size_t size = sizeOfStructWithArraySize(IntArray, elements, length);
    IntArray *a = (IntArray *) qmalloc(obj, size);
    a->length = length;
    return a;
}

RealArray *createRealArray(QObject *obj, int length) {
    if (length <= 0)
        abort("Invalid array size");
    size_t size = sizeOfStructWithArraySize(RealArray, elements, length);
    RealArray *a = (RealArray *) qmalloc(obj, size);
    a->length = length;
    return a;
}

BooleanArray *createBooleanArray(QObject *obj, int length) {
    if (length <= 0)
        abort("Invalid array size");
    size_t size = sizeOfStructWithArraySize(BooleanArray, elements, length);
    BooleanArray *a = (BooleanArray *) qmalloc(obj, size);
    a->length = length;
    return a;
}

Pmf *defaultPmf(QObject *obj, PmfConfig *);

PmfArray *createPmfArray(QObject *obj, PmfConfig *pmfConfig, int length) {
    if (length <= 0)
        abort("Invalid array dimensions");
    PmfArray *a = allocatePmfArray(obj, length);
    if (pmfConfig) 
        for (int i=0; i<length; i++)
            a->elements[i] = defaultPmf(obj, pmfConfig);
    return a;
}

InterfaceArray *createInterfaceArray(QObject *obj, void *defaultImplementation, int length) {
    if (length <= 0)
        abort("Invalid array dimensions");
    InterfaceArray *a = allocateInterfaceArray(obj, length);
    if (defaultImplementation)
        for (int i=0; i<length; i++)
            a->elements[i] = defaultImplementation;
    return a;
}

IntMatrix *createIntMatrix(QObject *obj, int rowCount, int columnCount) {
    if (rowCount <= 0 || columnCount < 0)
        abort("Invalid matrix dimensions");

    size_t size = sizeOfStructWithArraySize(IntMatrix, elements, rowCount);
    IntMatrix *m = (IntMatrix *) qmalloc(obj, size);
    m->length = rowCount;

    if (columnCount) 
        for (int i=0; i<rowCount; i++)
            m->elements[i] = createIntArray(obj, columnCount);
    return m;
}

RealMatrix *createRealMatrix(QObject *obj, int rowCount, int columnCount) {
    if (rowCount <= 0 || columnCount < 0)
        abort("Invalid matrix dimensions");

    size_t size = sizeOfStructWithArraySize(RealMatrix, elements, rowCount);
    RealMatrix *m = (RealMatrix *) qmalloc(obj, size);
    m->length = rowCount;

    if (columnCount) 
        for (int i=0; i<rowCount; i++)
            m->elements[i] = createRealArray(obj, columnCount);

    return m;
}

BooleanMatrix *createBooleanMatrix(QObject *obj, int rowCount, int columnCount) {
    if (rowCount <= 0 || columnCount < 0)
        abort("Invalid matrix dimensions");

    size_t size = sizeOfStructWithArraySize(BooleanMatrix, elements, rowCount);
    BooleanMatrix *m = (BooleanMatrix *) qmalloc(obj, size);
    m->length = rowCount;

    if (columnCount) 
        for (int i=0; i<rowCount; i++)
            m->elements[i] = createBooleanArray(obj, columnCount);

    return m;
}

PmfMatrix *createPmfMatrix(QObject *obj, PmfConfig *pmfConfig, int rowCount, int columnCount) {
    if (rowCount <= 0 || columnCount < 0)
        abort("Invalid matrix dimensions");

    PmfMatrix *m = allocatePmfMatrix(obj, rowCount, columnCount);
    m->length = rowCount;

    if (columnCount) 
        for (int i=0; i<rowCount; i++)
            m->elements[i] = createPmfArray(obj, pmfConfig, columnCount);

    return m;
}

InterfaceMatrix *createInterfaceMatrix(QObject *obj, void *defaultImplementation, int rowCount, int columnCount) {
    if (rowCount <= 0 || columnCount < 0)
        abort("Invalid matrix dimensions");
    
    InterfaceMatrix *m = allocateInterfaceMatrix(obj, rowCount, columnCount);
    m->length = rowCount;

    if (columnCount)
        for (int i=0; i<rowCount; i++)
            m->elements[i] = createInterfaceArray(obj, defaultImplementation, columnCount);

    return m;
}

Pmf *createAtomicSimplePmf(QObject *obj, Int value) {
    Pmf *pmf = allocateSimplePmf(obj, value, 1);
    pmf->simple.elements[0] = 1;
    return pmf;
}

// DEFAULT

Int defaultInt() {
    return 0;
}

Real defaultReal() {
    return 0;
}

Boolean defaultBoolean() {
    return false;
}

Pmf *defaultJointPmf(QObject *obj, int depth) {
    Pmf *defaultSimplePmf = createAtomicSimplePmf(obj, 0);
    Pmf *pmf = defaultSimplePmf;
    for (int i=2; i<=depth; i++) {
        Pmf *newPmf = allocateJointPmf(obj, defaultSimplePmf, i);
        newPmf->joint.elements[0] = pmf;
        pmf = newPmf;
    }
    return pmf;
}

Pmf *defaultPmf(QObject *obj, PmfConfig *pmfConfig) {
    switch(pmfConfig->pmfType) {
        case SIMPLE:
            return createAtomicSimplePmf(obj, 0);
        case JOINT:
            return defaultJointPmf(obj, pmfConfig->joint.depth);
        case COMPOUND: {
            int length = pmfConfig->compound.length;
            Pmf *pmf = allocateCompoundPmf(obj, pmfConfig->compound.length);
            for (int i=0; i<length; i++) {
                int depth = pmfConfig->compound.depths[i];
                if (depth == 1)
                    pmf->compound.elements[i] = createAtomicSimplePmf(obj, 0);
                else
                    pmf->compound.elements[i] = defaultJointPmf(obj, depth);
            }
            return pmf;
        }
    }
}

IntArray *defaultIntArray(QObject *obj) {
    return createIntArray(obj, 1);
}

RealArray *defaultRealArray(QObject *obj) {
    return createRealArray(obj, 1);
}

BooleanArray *defaultBooleanArray(QObject *obj) {
    return createBooleanArray(obj, 1);
}

PmfArray *defaultPmfArray(QObject *obj, PmfConfig *pmfConfig) {
    PmfArray *a = allocatePmfArray(obj, 1);
    a->elements[0] = defaultPmf(obj, pmfConfig);
    return a;
}

IntMatrix *defaultIntMatrix(QObject *obj) {
    return createIntMatrix(obj, 1,1);
}

RealMatrix *defaultRealMatrix(QObject *obj) {
    return createRealMatrix(obj, 1,1);
}

BooleanMatrix *defaultBooleanMatrix(QObject *obj) {
    return createBooleanMatrix(obj, 1,1);
}

PmfMatrix *defaultPmfMatrix(QObject *obj, PmfConfig *pmfConfig) {
    PmfMatrix *m = allocatePmfMatrix(obj, 1, 1);
    m->elements[0]->elements[0] = defaultPmf(obj, pmfConfig);
    return m;
}

// INITIALIZE

IntArray *initializeIntArray(QObject *obj, int length, ...) {
    va_list valist;
    va_start(valist, length);
    IntArray *a = createIntArray(obj, length);
    for (int i = 0; i < length; i++)
        a->elements[i] = va_arg(valist, Int);
    va_end(valist);
    return a;
}

RealArray *initializeRealArray(QObject *obj, int length, ...) {
    va_list valist;
    va_start(valist, length);
    RealArray *a = createRealArray(obj, length);
    for (int i = 0; i < length; i++)
        a->elements[i] = va_arg(valist, Real);
    va_end(valist);
    return a;
}

BooleanArray *initializeBooleanArray(QObject *obj, int length, ...) {
    va_list valist;
    va_start(valist, length);
    BooleanArray *a = createBooleanArray(obj, length);
    for (int i = 0; i < length; i++)
        a->elements[i] = va_arg(valist, int);
    va_end(valist);
    return a;
}

PmfArray *initializePmfArray(QObject *obj, int length, ...) {
    va_list valist;
    va_start(valist, length);
    PmfArray *a = allocatePmfArray(obj, length);
    for (int i = 0; i < length; i++)
        a->elements[i] = va_arg(valist, Pmf *);
    va_end(valist);
    return a;
}

InterfaceArray *initializeInterfaceArray(QObject *obj, int length, ...) {
    va_list valist;
    va_start(valist, length);
    InterfaceArray *a = allocateInterfaceArray(obj, length);
    for (int i = 0; i < length; i++)
        a->elements[i] = va_arg(valist, void *);
    va_end(valist);
    return a;
}

IntMatrix *initializeIntMatrix(QObject *obj, int rowCount, ...) {
    va_list valist;
    va_start(valist, rowCount);
    IntMatrix *m = createIntMatrix(obj, rowCount, 0);
    for (int i = 0; i < rowCount; i++) {
        int length = va_arg(valist, Int);
        IntArray *a = createIntArray(obj, length);
        for (int j = 0; j < length; j++)
            a->elements[j] = va_arg(valist, Int);
        m->elements[i] = a;
    }
    va_end(valist);
    return m;
}

RealMatrix *initializeRealMatrix(QObject *obj, int rowCount, ...) {
    va_list valist;
    va_start(valist, rowCount);
    RealMatrix *m = createRealMatrix(obj, rowCount, 0);
    for (int i = 0; i < rowCount; i++) {
        int length = va_arg(valist, Int);
        RealArray *a = createRealArray(obj, length);
        for (int j = 0; j < length; j++)
            a->elements[j] = va_arg(valist, Real);
        m->elements[i] = a;
    }
    va_end(valist);
    return m;
}

BooleanMatrix *initializeBooleanMatrix(QObject *obj, int rowCount, ...) {
    va_list valist;
    va_start(valist, rowCount);
    BooleanMatrix *m = createBooleanMatrix(obj, rowCount, 0);
    for (int i = 0; i < rowCount; i++) {
        int length = va_arg(valist, Int);
        BooleanArray *a = createBooleanArray(obj, length);
        for (int j = 0; j < length; j++)
            a->elements[j] = va_arg(valist, Boolean);
        m->elements[i] = a;
    }
    va_end(valist);
    return m;
}

PmfMatrix *initializePmfMatrix(QObject *obj, int rowCount, ...) {
    va_list valist;
    va_start(valist, rowCount);
    PmfMatrix *m = createPmfMatrix(obj, NULL, rowCount, 0);
    for (int i = 0; i < rowCount; i++) {
        int length = va_arg(valist, Int);
        PmfArray *a = createPmfArray(obj, NULL, length);
        for (int j = 0; j < length; j++)
            a->elements[j] = va_arg(valist, Pmf *);
        m->elements[i] = a;
    }
    va_end(valist);
    return m;
}

InterfaceMatrix *initializeInterfaceMatrix(QObject *obj, int rowCount, ...) {
    va_list valist;
    va_start(valist, rowCount);
    InterfaceMatrix *m = createInterfaceMatrix(obj, NULL, rowCount, 0);
    for (int i = 0; i < rowCount; i++) {
        int length = va_arg(valist, Int);
        InterfaceArray *a = createInterfaceArray(obj, NULL, length);
        for (int j = 0; j < length; j++)
            a->elements[j] = va_arg(valist, void *);
        m->elements[i] = a;
    }
    va_end(valist);
    return m;
}

// ARRAY LOOKUP

Int &lookup(IntArray *a, Int i) {
    if (i >= 0 && i < a->length)
        return a->elements[i];
    else
        abort("Lookup index out of range");
}

Real &lookup(RealArray *a, Int i) {
    if (i >= 0 && i < a->length)
        return a->elements[i];
    else
        abort("Lookup index out of range");
}

Boolean &lookup(BooleanArray *a, Int i) {
    if (i >= 0 && i < a->length)
        return a->elements[i];
    else
        abort("Lookup index out of range");
}

Pmf *&lookup(PmfArray *a, Int i) {
    if (i >= 0 && i < a->length)
        return a->elements[i];
    else
        abort("Lookup index out of range");
}

void *&lookup(InterfaceArray *a, Int i) {
    if (i >= 0 && i < a->length)
        return a->elements[i];
    else
        abort("Lookup index out of range");
}

IntArray *&lookup(IntMatrix *m, Int i) {
    if (i >= 0 && i < m->length)
        return m->elements[i];
    else
        abort("Lookup index out of range");
}


RealArray *&lookup(RealMatrix *m, Int i) {
    if (i >= 0 && i < m->length)
        return m->elements[i];
    else
        abort("Lookup index out of range");
}

BooleanArray *&lookup(BooleanMatrix *m, Int i) {
    if (i >= 0 && i < m->length)
        return m->elements[i];
    else
        abort("Lookup index out of range");
}

PmfArray *&lookup(PmfMatrix *m, Int i) {
    if (i >= 0 && i < m->length)
        return m->elements[i];
    else
        abort("Lookup index out of range");
}

InterfaceArray *&lookup(InterfaceMatrix *m, Int i) {
    if (i >= 0 && i < m->length)
        return m->elements[i];
    else
        abort("Lookup index out of range");
}

// PMF LOOKUP

Real lookupProbability(Pmf *pmf, Int i) {
    if (i >= pmf->simple.offset && i < pmf->simple.offset+pmf->simple.length)
        return pmf->simple.elements[i-pmf->simple.offset];
    else
        return 0;
}

Pmf *lookupMarginalPmf(Pmf *pmf) { 
    return pmf->joint.marginal;
}

Pmf *lookupConditionalPmf(Pmf *pmf, Int length, ...)  { 
    va_list valist;
    va_start(valist, length);
    for (int i=0; i<length; i++) {
        int k = va_arg(valist, int);
        if (lookupProbability(pmf->joint.marginal, k) == 0)
            abort("Attempt to condition on a value of probability zero");
        pmf = pmf->joint.elements[k - pmf->joint.marginal->simple.offset];
    }
    va_end(valist);
    return pmf;
}

Pmf *lookupCompoundPmf(Pmf *pmf, Int i) {
    return pmf->compound.elements[i];
}

// ACCUMULATORS

class Accumulator {
public:
    Accumulator(QObject *_obj) : obj(_obj) {}
    virtual ~Accumulator() {};
    static Real sum;
    QObject *obj;
    virtual bool isEmpty() = 0;
    virtual Accumulator *putSingle(Real probability, Int value) { abortInternal(); return this; }
    virtual Accumulator *putDouble(Real probability, Int value1, Int value2) { abortInternal(); return this; }
    virtual Accumulator *put(Real probability, ...);
    virtual Accumulator *vput(Real probability, va_list &valist) = 0;
    virtual Pmf *toPmf() = 0;
    Pmf *toPmfAndDelete();
};

Real Accumulator::sum;

Accumulator *Accumulator::put(Real probability, ...) {
    if (probability <= 0)
        return this;
    if (probability > 1)
       probability = 1;

    va_list valist;
    va_start(valist, probability);
    vput(probability, valist);
    va_end(valist);
    return this;
}

Pmf *Accumulator::toPmfAndDelete() {
    Pmf *pmf = toPmf();
    delete this;
    return pmf;
}

class SimpleAccumulator : public Accumulator {
public:
    Int offset, length;
    Real *elements;
    SimpleAccumulator(QObject *obj) : Accumulator(obj), offset(0), length(0), elements(NULL) {}
    ~SimpleAccumulator();
    virtual bool isEmpty() { return elements == NULL; }
    virtual SimpleAccumulator *putSingle(Real probability, Int value);
    virtual Accumulator *vput(Real probability, va_list &valist);
    Pmf *toPmf();
};

SimpleAccumulator::~SimpleAccumulator() {
    if (elements)
        free(elements);
}

// Bottleneck for execution speed.  Minimize ifs when range does not change.
SimpleAccumulator *SimpleAccumulator::putSingle(Real probability, Int value) {
    if (probability <= 0)
        return this;
    if (probability > 1)
       probability = 1;
    
    if (value < offset) {
        if (value < 0)
            abort("Negative integer in pmf support");
    
        if (length == 0) {
            elements = (Real *) malloc(sizeof(Real));
            elements[0] = probability;
            offset = value;
            length = 1;
            return this;
        }
        
        int newLength = 2 * (offset + length - value);
        int newOffset = std::max(offset + length - newLength, 0);
        Real *newElements = (Real *) malloc(newLength * sizeof(Real));
        memset(newElements, 0, newLength * sizeof(Real));
        memcpy(
               &newElements[offset - newOffset],
               elements,
               length * sizeof(Real)
        );
        free(elements);
        elements = newElements;
        offset = newOffset;
        length = newLength;
    } else if (value >= offset + length) {
        if (length == 0) {
            elements = (Real *) malloc(sizeof(Real));
            elements[0] = probability;
            offset = value;
            length = 1;
            return this;
        }
        
        int newLength = 2 * (1 + value - offset);
        Real *newElements = (Real *) malloc(newLength * sizeof(Real));
        memset(newElements, 0, newLength * sizeof(Real));
        memcpy(
               newElements,
               elements,
               length * sizeof(Real)
        );
        free(elements);
        elements = newElements;
        length = newLength;
    }
    
    elements[value - offset] += probability;
    return this;
}

Accumulator *SimpleAccumulator::vput(Real probability, va_list &valist) {
    Int value = va_arg(valist, Int);
    putSingle(probability, value);
    return this;
}

Pmf *SimpleAccumulator::toPmf() {
   if (length == 0)
        abort("Empty pmf");
    
    int minValue = offset;
    int maxValue = offset + length - 1;
    while (elements[minValue - offset] == 0 && minValue <= maxValue)
        minValue++;
    while (elements[maxValue - offset] == 0 && maxValue >= minValue)
        maxValue--;
        
    if (maxValue < minValue)
        return allocateSimplePmf(obj, 0, 0);
    
    Pmf *newPmf = allocateSimplePmf(obj, minValue, 1 + maxValue - minValue);
    memcpy(
           newPmf->simple.elements,
           &elements[minValue - offset],
           (1 + maxValue - minValue) * sizeof(Real)
    );
    
    sum = 0;
    for (int i=0; i<newPmf->simple.length; i++)
        sum += newPmf->simple.elements[i];
    for (int i=0; i<newPmf->simple.length; i++)
        newPmf->simple.elements[i] /= sum;
    
    return newPmf;
}

class JointAccumulator : public Accumulator {
public:
    int depth, offset, length;
    Accumulator **elements;
    JointAccumulator(QObject *obj, int _depth) : Accumulator(obj), depth(_depth), offset(0), length(0), elements(NULL) {}
    ~JointAccumulator();
    virtual bool isEmpty() { return elements == NULL; }
    void include(Int value);
    virtual Accumulator *putDouble(Real probability, Int value1, Int value2);
    virtual Accumulator *vput(Real probability, va_list &valist);
    void put_fromPy(Real probability, PyObject *pyValues);
    Pmf *toPmf();
};

JointAccumulator::~JointAccumulator() {
    if (elements) {
        for (int i = 0; i<length; i++) {
            delete elements[i];
        }
        free(elements);
    }
}

Accumulator *JointAccumulator::vput(Real probability, va_list &valist) {
    switch(depth) {
        case 1:
            abort();
            break;
        case 2: {
            Int value1 = va_arg(valist, Int);
            Int value2 = va_arg(valist, Int);
            putDouble(probability, value1, value2);
            break;
        }
        default: {
            Accumulator *accumulator = this;
            for (int i=depth; i>=2; i--) {
                Int value = va_arg(valist, Int);
                JointAccumulator *jointAccumulator = (JointAccumulator *) accumulator;
                jointAccumulator->include(value);
                accumulator = jointAccumulator->elements[value - jointAccumulator->offset];
            }
            
            Int value = va_arg(valist, Int);
            accumulator->putSingle(probability, value);
            break;
        }
    }
    return this;
}

// Bottleneck for execution speed.  Minimize ifs when range does not change.
void JointAccumulator::include(Int value) {
    if (value < offset) {
        if (value < 0)
            abort("Samples must be nonnegative integers");
    
        if (length == 0) {
            offset = value;
            length = 1;
            elements = (Accumulator **) malloc(sizeof(Accumulator *));
            elements[0] = depth > 2 ? (Accumulator *) new JointAccumulator(obj, depth-1) : (Accumulator *) new SimpleAccumulator(obj);
            return;
        }

        int newLength = 2 * (offset + length - value);
        int newOffset = std::max(offset + length - newLength, 0);
        Accumulator **newElements = (Accumulator **) malloc(newLength * sizeof(Accumulator *));
        memset(newElements, 0, newLength * sizeof(Accumulator *));
        memcpy(
               &newElements[offset - newOffset],
               elements,
               length * sizeof(Accumulator *)
        );
        free(elements);
        elements = newElements;
        offset = newOffset;
        length = newLength;
        for (int i=0; i<length; i++)
            if (elements[i] == NULL)
                elements[i] = depth > 2 ? (Accumulator *) new JointAccumulator(obj, depth-1) : (Accumulator *) new SimpleAccumulator(obj);
    } else if (value >= offset + length) {
        if (length == 0) {
            offset = value;
            length = 1;
            elements = (Accumulator **) malloc(sizeof(Accumulator *));
            elements[0] = depth > 2 ? (Accumulator *) new JointAccumulator(obj, depth-1) : (Accumulator *) new SimpleAccumulator(obj);
            return;
        }
        
        int newLength = 2 * (value + 1 - offset);
        Accumulator **newElements = (Accumulator **) malloc(newLength * sizeof(Accumulator *));
        memset(newElements, 0, newLength * sizeof(Accumulator *));
        memcpy(
               newElements,
               elements,
               length * sizeof(Accumulator *)
        );
        free(elements);
        elements = newElements;
        length = newLength;
        for (int i=0; i<length; i++)
            if (elements[i] == NULL)
                elements[i] = depth > 2 ? (Accumulator *) new JointAccumulator(obj, depth-1) : (Accumulator *) new SimpleAccumulator(obj);
    }
}

Accumulator *JointAccumulator::putDouble(Real probability, Int value1, Int value2) {
    if (probability <= 0)
        return this;
    if (probability > 1)
       probability = 1;

    include(value1);
    SimpleAccumulator *accumulator = (SimpleAccumulator *) elements[value1 - offset];
    accumulator->putSingle(probability, value2);
    return this;
}

Int Int_fromPy(QObject *obj, PyObject *pyObj);
void JointAccumulator::put_fromPy(Real probability, PyObject *pyValues) {
    if (probability <= 0)
        return;
    if (probability > 1)
       probability = 1;

    if (!PyTuple_Check(pyValues))
        abortImport();
    if (PyTuple_Size(pyValues) != depth)
        abortImport();

    Accumulator *accumulator = this;
    for (int i=depth; i>=2; i--) {
        Int value = Int_fromPy(obj, PyTuple_GET_ITEM(pyValues, depth-i));
        JointAccumulator *jointAccumulator = (JointAccumulator *) accumulator;
        jointAccumulator->include(value);
        accumulator = jointAccumulator->elements[value - jointAccumulator->offset];
    }
    
    Int value = Int_fromPy(obj, PyTuple_GET_ITEM(pyValues, depth-1));
    SimpleAccumulator *simpleAccumulator = (SimpleAccumulator *) accumulator;
    simpleAccumulator->putSingle(probability, value);
}

Pmf *JointAccumulator::toPmf() {
    if (length == 0)
        abort("Empty pmf");
   
    int minValue = offset;
    int maxValue = offset + length - 1;
    while (elements[minValue - offset]->isEmpty() && minValue <= maxValue)
        minValue++;
    while (elements[maxValue - offset]->isEmpty() && maxValue >= minValue)
        maxValue--;
        
    if (maxValue < minValue)
        return allocateEmptyJointPmf(obj, depth);
   
    Pmf *marginal = allocateSimplePmf(obj, minValue, maxValue+1-minValue);
    Pmf *jointPmf = allocateJointPmf(obj, marginal, depth);
    for (int value=minValue; value<=maxValue; value++) {
         if (!elements[value-offset]->isEmpty()) {
            jointPmf->joint.elements[value-minValue] = elements[value-offset]->toPmf();
            marginal->simple.elements[value-minValue] = elements[value-offset]->sum;
        }
    }
    sum = 0;
    for (int i=0; i<marginal->simple.length; i++)
        sum += marginal->simple.elements[i];
    for (int i=0; i<marginal->simple.length; i++)
        marginal->simple.elements[i] /= sum;
    
    return jointPmf;
}

class CompoundAccumulator : public Accumulator {
public:
    PmfConfig *pmfConfig;
    Accumulator **elements;
    CompoundAccumulator(QObject *obj, PmfConfig *pmfConfig);
    ~CompoundAccumulator();
    bool isEmpty() { return elements[0]->isEmpty(); }
    virtual Accumulator *vput(Real probability, va_list &valist);
    Pmf *toPmf();
};

CompoundAccumulator::CompoundAccumulator(QObject *obj, PmfConfig *_pmfConfig) : Accumulator(obj), pmfConfig(_pmfConfig) {
    int length = pmfConfig->compound.length;
    elements = (Accumulator **) malloc(length * sizeof(Accumulator *));
    for (int i=0; i<length; i++) {
        int depth = pmfConfig->compound.depths[i];
        if (depth == 1)
            elements[i] = new SimpleAccumulator(obj);
        else
            elements[i] = new JointAccumulator(obj, depth);
    }
}

CompoundAccumulator::~CompoundAccumulator() {
    int length = pmfConfig->compound.length;
    for (int i=0; i<length; i++)
        delete elements[i];
    free(elements);
}

 Accumulator *CompoundAccumulator::vput(Real probability, va_list &valist) {
    int length = pmfConfig->compound.length;
    for (int i=0; i<length; i++)
        elements[i]->vput(probability, valist);
    return this;
}

Pmf *CompoundAccumulator::toPmf() {
    if (isEmpty())
        abort("Empty pmf");
    
    int length = pmfConfig->compound.length;
    Pmf *pmf = allocateCompoundPmf(obj, length);
    
    for (int i=0; i<length; i++)
        pmf->compound.elements[i] = elements[i]->toPmf();
    
    return pmf;
}

// BUILT-IN FUNCTIONS

Int ifloor(Real x) {
    return (int) floor(x);
}

Int iceiling(Real x) {
    return (int) ceil(x);
}

Real safeSqrt(Real x) {
    if (x < 0)
        abort("Attempt to take square root of negative number");    
    return sqrt(x);
}

Real safeLog(Real x) {
    if (x < 0)
        abort("Attempt to take log of negative number");    
    return log(x);
}

Real safePow(Real x, Real y) {
    Real z = pow(x, y);

    // std::isnan is unavailable on some platforms.  
    // Use this trick:  
    // If z is nan or infinite, then z - z is nan.
    // If e is nan, then e != e is true.    
    Real e = z - z;
    if (e != e)
        abort("Invalid pow operation"); 

    return z;
}

Real randomReal() {
    return rand() / (Real) RAND_MAX;
}

Int randomInt(int n) {
    return rand() % n;
}

Pmf *createPmfFromRealArray(QObject *obj, RealArray *realArray) {
    SimpleAccumulator a(obj);
    for (int i=0; i<realArray->length; i++)
        a.putSingle(realArray->elements[i], i);
    return a.toPmf();
}

Int computeLeftTail(Pmf *pmf, Real epsilon) {
    if (pmf->pmfType != SIMPLE)
        abort("computeLeftTail requires simple pmf");

    int offset = pmf->simple.offset;
    int n = pmf->simple.length;
    Real sum = 0;

    for (int i=0; i<n; i++) {
        sum += pmf->simple.elements[i];
        if (sum >= epsilon)
            return i + offset;
    }

    return n + offset;
}   

Int computeRightTail(Pmf *pmf, Real epsilon) {
    if (pmf->pmfType != SIMPLE)
        abort("computeRightTail requires simple pmf");

    int offset = pmf->simple.offset;
    int n = pmf->simple.length;
    Real sum = 0;

    for (int i=n-1; i>=0; i--) {
        sum += pmf->simple.elements[i];
        if (sum >= epsilon)
            return i + offset;
    }

    return offset;
}   

Boolean isSamePmfInstance(Pmf *p, Pmf *q) {
    return p == q;
}

Pmf *bernoulli(QObject *obj, Real p) {
    if (p <= 0)
        return (Pmf *) createAtomicSimplePmf(obj, 0);
    if (p >= 1)
        return (Pmf *) createAtomicSimplePmf(obj, 1);
    Pmf *pmf = allocateSimplePmf(obj, 0, 2);
    pmf->simple.elements[0] = 1-p;
    pmf->simple.elements[1] = p;
    return pmf;
}

Pmf *binomial(QObject *obj, int n, Real p) {
    if (p <= 0)
        return (Pmf *) createAtomicSimplePmf(obj, 0);
    if (p >= 1)
        return (Pmf *) createAtomicSimplePmf(obj, n);
    Pmf *pmf = allocateSimplePmf(obj, 0, n+1);

    Real logP = log(p);
    Real logQ = log(1-p);
    Real logR = logP - logQ;
    Real x = n * logQ;
    pmf->simple.elements[0] = exp(x);
    for (int i=1; i<=n; i++) {
        x += logR + log(n-(i-1)) - log(i);
        pmf->simple.elements[i] = exp(x);
    }
    return pmf;
}

Pmf *multinomialLayer(QObject *obj, int n, int k, Real *gamma) {
    if (k == 1)
        return createAtomicSimplePmf(obj, n);
    
    Pmf *marginal = binomial(obj, n, gamma[0]);
    Pmf *joint = allocateJointPmf(obj, marginal, k);
    for (int i=0; i<=n; i++)
        joint->joint.elements[i] = multinomialLayer(obj, n-i, k-1, gamma+1);
    return joint;
}

Pmf *multinomial(QObject *obj, int n, int k, Pmf *p) {
    if (p->pmfType != SIMPLE || p->simple.offset || p->simple.length != k)
        abort("Invalid multinomial parameters");
    Real *gamma = (Real *) malloc(sizeof(Real) * k);
    Real r = 1;
    for (int i=0; i<k-1; i++) {
        Real q = p->simple.elements[i];
        gamma[i] = q/r;
        r -= q;
    }
    gamma[k-1] = 1;

    Pmf *pmf = multinomialLayer(obj, n, k, gamma);
    free(gamma);
    return pmf;
}

double *createLogFactorialArrayForHypergeometric(int N) {
    double *a = (double *) malloc((N+1) * sizeof(double));
    double x = a[0] = 0;
    for (int i=1; i<=N; i++)
        x = a[i] = log(i) + x;
    return a;
}

Pmf *hypergeometricHelper(QObject *obj, int N, int K, int n, double *logFactorialArray) {
    int kMin = std::max(0, n + K - N);
    int kMax = std::min(K, n);
    int length = kMax + 1 - kMin;
    
    double fixedPart
        = logFactorialArray[K] + logFactorialArray[N-K] - (logFactorialArray[N] - logFactorialArray[n] - logFactorialArray[N-n]);
    
    Pmf *pmf = allocateSimplePmf(obj, kMin, length);
    for (int k = kMin; k <= kMax; k++)
        pmf->simple.elements[k-kMin]
            = exp(fixedPart - logFactorialArray[k] - logFactorialArray[K-k] - logFactorialArray[n-k] - logFactorialArray[N-K-(n-k)]);
    
    return pmf;
}

Pmf *hypergeometric(QObject *obj, int N, int K, int n) {
    if (N < 0 || K < 0 || n < 0 || K > N || n > N)
        abort("Invalid hypergeometric parameters");
    double *logFactorialArray = createLogFactorialArrayForHypergeometric(N);
    Pmf *pmf = hypergeometricHelper(obj, N, K, n, logFactorialArray);
    free(logFactorialArray);
    return pmf;
}

Pmf *multivariateHypergeometricLayer(QObject *obj, int N, int n, int d, int *b, double *logFactorialArray) {
    if (d == 1)
        return createAtomicSimplePmf(obj, n);
    Pmf *marginal = hypergeometricHelper(obj, N, b[0], n, logFactorialArray);
    Pmf *joint = allocateJointPmf(obj, marginal, d);
    for (int i=0; i<marginal->simple.length; i++) {
        int k = marginal->simple.offset+i;
        joint->joint.elements[i]
            = multivariateHypergeometricLayer(obj, N-b[0], n-k, d-1, b+1, logFactorialArray);
    }
    return joint;
}

Pmf *multivariateHypergeometric(QObject *obj, int N, int n, int d, IntArray *b) {
   if (N < 0 || n < 0 || n > N || d != b->length)
        abort("Invalid multivariateHypergeometric parameters");
   
   int checkN = 0;
   for (int i=0; i<d; i++) {
       int bb = b->elements[i];
       if (bb < 0)
           abort("Invalid multivariateHypergeometric parameters");
       checkN += bb;
   }
   if (N != checkN)
        abort("Invalid multivariateHypergeometric parameters");

    double *logFactorialArray = createLogFactorialArrayForHypergeometric(N);
    Pmf *pmf = multivariateHypergeometricLayer(obj, N, n, d, b->elements, logFactorialArray);
    free(logFactorialArray);
    return pmf;
}

// SAMPLING STACK

class SamplingStack {
private:
    Real *a;
public:
    SamplingStack(int capacity) {
        a = (Real *) malloc(capacity * sizeof(Real));
    }
    ~SamplingStack() {
        free(a);
    }
    void set(int i, Real p) {
        a[i] = p;
    }
    void branch(int i, Real p) {
        a[i] = p * a[i-1];
    }
    Real branchProbability(int i) {
        return a[i];
    }
};

// PMF CONFIRMATION

Pmf *confirmSimplePmf(Pmf *pmf) {
    if (pmf->pmfType != SIMPLE)
        abortImport();
    
    return pmf;
}

PmfArray *confirmSimplePmfArray(PmfArray *a) {
    for (int i=0; i<a->length; i++)
        confirmSimplePmf(a->elements[i]);
    
    return a;
}

PmfMatrix *confirmSimplePmfMatrix(PmfMatrix *m) {
    for (int i=0; i<m->length; i++)
        confirmSimplePmfArray(m->elements[i]);
    
    return m;
}

Pmf *confirmJointPmf(Pmf *pmf, int depth) {
    if (pmf->pmfType != JOINT)
        abortImport();
    else if (pmf->joint.depth != depth)
        abortImport();
    
    return pmf;
}

PmfArray *confirmJointPmfArray(PmfArray *a, int depth) {
    for (int i=0; i<a->length; i++)
        confirmJointPmf(a->elements[i], depth);
    
    return a;
}

PmfMatrix *confirmJointPmfMatrix(PmfMatrix *m, int depth) {
    for (int i=0; i<m->length; i++)
        confirmJointPmfArray(m->elements[i], depth);
    return m;
}

Pmf *confirmCompoundPmf(Pmf *pmf, int length, ...) {
    if (pmf->pmfType != COMPOUND)
        abortImport();
    else if (pmf->compound.length != length)
        abortImport();
    else {
        va_list valist;
        va_start(valist, length);
        
        for (int i=0; i<length; i++) {
            Pmf *q = pmf->compound.elements[i];
            int depth = va_arg(valist, int);
            
            if (depth == 1)
                confirmSimplePmf(q);
            else
                confirmJointPmf(q, depth);
        }
        
        va_end(valist);
    }

    return pmf;
}

PmfArray *confirmCompoundPmfArray(PmfArray *a, int length, ...) {
    for (int i=0; i<a->length; i++) {
        Pmf *pmf = a->elements[i];
        
        if (pmf->pmfType != COMPOUND)
            abortImport();
        else if (pmf->compound.length != length)
            abortImport();
        else {
            va_list valist;
            va_start(valist, length);
            
            for (int j=0; j<length; j++) {
                Pmf *q = pmf->compound.elements[j];
                int depth = va_arg(valist, int);
                
                if (depth == 1)
                    confirmSimplePmf(q);
                else
                    confirmJointPmf(q, depth);
            }
            
            va_end(valist);
        }
    }
    
    return a;
}

PmfMatrix *confirmCompoundPmfMatrix(PmfMatrix *m, int length, ...) {
    for (int i=0; i<m->length; i++) {
        PmfArray *a = m->elements[i];
        
        for (int j=0; j<a->length; j++) {
            Pmf *pmf = a->elements[j];
            if (pmf->pmfType != COMPOUND)
                abortImport();
            if (pmf->compound.length != length)
                abortImport();
            
            va_list valist;
            va_start(valist, length);
            
            for (int k=0; k<length; k++) {
                Pmf *q = pmf->compound.elements[k];
                int depth = va_arg(valist, int);
                
                if (depth == 1)
                    confirmSimplePmf(q);
                else
                    confirmJointPmf(q, depth);
            }
            
            va_end(valist);
        }
    }
    
    return m;
}

// PMF IMPORT/EXPORT

PyObject *Int_toPy(QObject * obj, Int i) {
    return PyLong_FromLong(i);
}

Int Int_fromPy(QObject * obj, PyObject *pyObj) {
    if (!PyLong_Check(pyObj))
        abortImport();
    return PyLong_AsLong(pyObj);
}

PyObject *Real_toPy(QObject * obj, Real x) {
    return PyFloat_FromDouble(x);
}

Real Real_fromPy(QObject * obj, PyObject *pyObj) {
    if (PyFloat_Check(pyObj))
        return PyFloat_AsDouble(pyObj);
    if (PyLong_Check(pyObj))
        return PyLong_AsDouble(pyObj);
    abortImport();
}

PyObject *Boolean_toPy(QObject * obj, Boolean b) {
    return PyBool_FromLong(b);
}

Boolean Boolean_fromPy(QObject * obj, PyObject *pyObj) {
    return PyLong_AsLong(pyObj) != 0L;
}

class SampleEnumeratorFor_toPy : public SampleEnumerator {
public:
    QObject *obj;
    PyObject *pyDict;
    SampleEnumeratorFor_toPy(QObject *_obj, Pmf *pmf, PyObject *_pyDict) : obj(_obj), SampleEnumerator(pmf), pyDict(_pyDict) {}
    void recordSample();
};

void SampleEnumeratorFor_toPy::recordSample() {
    if (depth == 1) {
        PyObject *key = Int_toPy(obj, records[1].value);
        PyObject *value = Real_toPy(obj, records[depth].probability);
        PyDict_SetItem(pyDict, key, value);
        Py_DECREF(key);
        Py_DECREF(value);
    } else {
        PyObject *key = PyTuple_New(depth);
        for (int i=0; i<depth; i++)
            PyTuple_SET_ITEM(key, i, Int_toPy(obj, records[i+1].value));
        PyObject *value = Real_toPy(obj, records[depth].probability);
        PyDict_SetItem(pyDict, key, value);
        Py_DECREF(key);
        Py_DECREF(value);
    }
}

PyObject *Pmf_toPy(QObject *obj, Pmf *pmf) {
     switch (pmf->pmfType) {
        case SIMPLE:
        case JOINT: {
            PyObject *pyDict = PyDict_New();
            SampleEnumeratorFor_toPy enumerator(obj, pmf, pyDict);
            enumerator.run();
            return pyDict;
            break;
        }
        case COMPOUND: {
            int n = pmf->compound.length;
            PyObject *pyTuple = PyTuple_New(n);
            for (int i=0; i<n; i++) {
                PyObject *pyPmf = Pmf_toPy(obj, pmf->compound.elements[i]);
                PyTuple_SET_ITEM(pyTuple, i, pyPmf);
            }
            return pyTuple;
            break;
        }
    }
}

Pmf *Pmf_fromPy(QObject * obj, PyObject *pyObj) {
    PmfType pmfType;
    int depth = -1;
    
    if (PyTuple_Check(pyObj))
        pmfType = COMPOUND;
    else if (PyDict_Check(pyObj)) {
        PyObject *key, *value;
        Py_ssize_t pos = 0;
        if (!PyDict_Next(pyObj, &pos, &key, &value))
           abort("Empty dictionary");
        if (PyLong_Check(key))
            pmfType = SIMPLE;
        else if (PyTuple_Check(key)) {
            pmfType = JOINT;
            depth = PyTuple_Size(key);
        } else
            abortImport();
     } else
        abortImport();
        
    switch(pmfType) {
        case SIMPLE: {
            SimpleAccumulator a(obj);
            PyObject *key, *value;
            Py_ssize_t pos = 0;
            while (PyDict_Next(pyObj, &pos, &key, &value))
                a.putSingle(Real_fromPy(obj, value), Int_fromPy(obj, key));
            return a.toPmf();
        }
        case JOINT: {
            JointAccumulator a(obj, depth);
            PyObject *key, *value;
            Py_ssize_t pos = 0;
            while (PyDict_Next(pyObj, &pos, &key, &value))
                a.put_fromPy(Real_fromPy(obj, value), key);
            return a.toPmf();
        }
        case COMPOUND: {
            int n = PyTuple_Size(pyObj);
            Pmf *pmf = allocateCompoundPmf(obj, n);
            for (int i=0; i<n; i++)
                pmf->compound.elements[i] = Pmf_fromPy(obj, PyTuple_GET_ITEM(pyObj, i));
            return pmf;
        }
    }
}
PyObject *IntArray_toPy(QObject * obj, IntArray *a) {
    int n = a->length;
    PyObject *pyList = PyList_New(n);
    
    for (int i=0; i<n; i++)
        PyList_SET_ITEM(pyList, i, Int_toPy(obj, a->elements[i]));
    
    return pyList;
}

IntArray *IntArray_fromPy(QObject * obj, PyObject *pyObj) {
    if (!PyList_Check(pyObj))
        abortImport();
    
    int n = (int) PyList_Size(pyObj);
    if (n <= 0)
        abortImport();

    IntArray *a = createIntArray(obj, n);
    
    for (int i=0; i<n; i++)
        a->elements[i] = Int_fromPy(obj, PyList_GET_ITEM(pyObj, i));
    
    return a;
}

PyObject *RealArray_toPy(QObject * obj, RealArray *a) {
    int n = a->length;
    PyObject *pyList = PyList_New(n);
    
    for (int i=0; i<n; i++)
        PyList_SET_ITEM(pyList, i, Real_toPy(obj,a->elements[i]));
    
    return pyList;
}

RealArray *RealArray_fromPy(QObject * obj, PyObject *pyObj) {
    if (!PyList_Check(pyObj))
        abortImport();
    
    int n = (int) PyList_Size(pyObj);
    if (n <= 0)
        abortImport();
    
    RealArray *a = createRealArray(obj, n);
    
    for (int i=0; i<n; i++)
        a->elements[i] = Real_fromPy(obj, PyList_GET_ITEM(pyObj, i));
    
    return a;
}

PyObject *BooleanArray_toPy(QObject * obj, BooleanArray *a) {
    int n = a->length;
    PyObject *pyList = PyList_New(n);
    
    for (int i=0; i<n; i++)
        PyList_SET_ITEM(pyList, i, Boolean_toPy(obj, a->elements[i]));
    
    return pyList;
}

BooleanArray *BooleanArray_fromPy(QObject * obj, PyObject *pyObj) {
    if (!PyList_Check(pyObj))
        abortImport();
    
    int n = (int) PyList_Size(pyObj);
    if (n <= 0)
        abortImport();

    BooleanArray *a = createBooleanArray(obj, n);
    
    for (int i=0; i<n; i++)
        a->elements[i] = Boolean_fromPy(obj, PyList_GET_ITEM(pyObj, i));
    
    return a;
}

PyObject *PmfArray_toPy(QObject * obj, PmfArray *a) {
    int n = a->length;
    PyObject *pyList = PyList_New(n);
    
    for (int i=0; i<n; i++)
        PyList_SET_ITEM(pyList, i, Pmf_toPy(obj, a->elements[i]));
    
    return pyList;
}

PmfArray *PmfArray_fromPy(QObject *obj, PyObject *pyObj) {
    if (!PyList_Check(pyObj))
        abortImport();
    
    int length = (int) PyList_Size(pyObj);
    if (length <= 0)
        abortImport();

    PmfArray *a = allocatePmfArray(obj, length);
    for (int i=0; i<length; i++)
        a->elements[i] = Pmf_fromPy(obj, PyList_GET_ITEM(pyObj, i));
    
    return a;
}

IntMatrix *IntMatrix_fromPy(QObject *obj, PyObject *pyObj) {
    if (!PyList_Check(pyObj))
        abortImport();
    
    int rowCount = (int) PyList_Size(pyObj);
    if (!rowCount)
        abortImport();
  
    IntMatrix *m = createIntMatrix(obj, rowCount, 0);
    
    for (int i=0; i<rowCount; i++) {
        PyObject *pyRow = PyList_GET_ITEM(pyObj, i);
        m->elements[i] = IntArray_fromPy(obj, pyRow);
    }    

    return m;
}

PyObject *IntMatrix_toPy(QObject * obj, IntMatrix *m) {
    int n = m->length;
    PyObject *pyList = PyList_New(n);
    
    for (int i=0; i<n; i++)
        PyList_SetItem(pyList, i, IntArray_toPy(obj, m->elements[i]));
    
    return pyList;
}

PyObject *RealMatrix_toPy(QObject * obj, RealMatrix *m) {
    int n = m->length;
    PyObject *pyList = PyList_New(n);
    
    for (int i=0; i<n; i++)
        PyList_SetItem(pyList, i, RealArray_toPy(obj, m->elements[i]));
    
    return pyList;
}

RealMatrix *RealMatrix_fromPy(QObject * obj, PyObject *pyObj) {
    if (!PyList_Check(pyObj))
        abortImport();
    
    int rowCount = (int) PyList_Size(pyObj);
    if (!rowCount)
        abortImport();
  
    RealMatrix *m = createRealMatrix(obj, rowCount, 0);
    
    for (int i=0; i<rowCount; i++) {
        PyObject *pyRow = PyList_GET_ITEM(pyObj, i);
        m->elements[i] = RealArray_fromPy(obj, pyRow);
    }    

    return m;
}

PyObject *BooleanMatrix_toPy(QObject * obj, BooleanMatrix *m) {
    int n = m->length;
    PyObject *pyList = PyList_New(n);
    
    for (int i=0; i<n; i++)
        PyList_SetItem(pyList, i, BooleanArray_toPy(obj, m->elements[i]));
    
    return pyList;
}

BooleanMatrix *BooleanMatrix_fromPy(QObject *obj, PyObject *pyObj) {
    if (!PyList_Check(pyObj))
        abortImport();
    
    int rowCount = (int) PyList_Size(pyObj);
    if (!rowCount)
        abortImport();
  
    BooleanMatrix *m = createBooleanMatrix(obj, rowCount, 0);
    
    for (int i=0; i<rowCount; i++) {
        PyObject *pyRow = PyList_GET_ITEM(pyObj, i);
        m->elements[i] = BooleanArray_fromPy(obj, pyRow);
    }    

    return m;
}

PyObject *PmfMatrix_toPy(QObject * obj, PmfMatrix *m) {
    int n = m->length;
    PyObject *pyList = PyList_New(n);
    
    for (int i=0; i<n; i++)
        PyList_SetItem(pyList, i, PmfArray_toPy(obj, m->elements[i]));
    
    return pyList;
}

PmfMatrix *PmfMatrix_fromPy(QObject *obj, PyObject *pyObj) {
    if (!PyList_Check(pyObj))
        abortImport();
    
    int rowCount = (int) PyList_Size(pyObj);
    if (!rowCount)
        abortImport();
  
    PmfMatrix *m = allocatePmfMatrix(obj, rowCount, 0);
    
    for (int i=0; i<rowCount; i++) {
        PyObject *pyRow = PyList_GET_ITEM(pyObj, i);
        m->elements[i] = PmfArray_fromPy(obj, pyRow);
    }    

    return m;
}

const char *functionNameFromPointer(QObject *obj, void *fp) {
    for (int i=0; i<obj->functionCount; i++) {
        if (obj->functionPointers[i] == fp)
            return obj->functionNames[i];
    }
    return "0";
}

void *functionPointerFromName(QObject *obj, int signatureIndex, const char *name) {
    for (int i=0; i<obj->functionCount; i++) {
        if (obj->functionSignatureIndexes[i] == signatureIndex && !strcmp(obj->functionNames[i], name))
            return obj->functionPointers[i];
    }
    return NULL;
}

PyObject *Interface_toPy(QObject *obj, void *functionPtr) {
    const char *name = functionNameFromPointer(obj, functionPtr);
    return PyUnicode_FromString(name);
}

const char *Interface_fromPy(QObject *obj, PyObject *pyObj, int signatureIndex) {
    if (!PyUnicode_Check(pyObj))
        abortImport();
    const char *name = PyUnicode_AsUTF8(pyObj);
    if (!(functionPointerFromName(obj, signatureIndex, name)))
        abortImport();
    return name;
}

PyObject *InterfaceArray_toPy(QObject * obj, InterfaceArray *a) {
    int n = a->length;
    PyObject *pyList = PyList_New(n);
    
    for (int i=0; i<n; i++)
        PyList_SET_ITEM(pyList, i, Interface_toPy(obj, a->elements[i]));
    
    return pyList;
}

InterfaceArray *InterfaceArray_fromPy(QObject *obj, PyObject *pyObj, int signatureIndex) {
    if (!PyList_Check(pyObj))
        abortImport();
    
    int length = (int) PyList_Size(pyObj);
    if (length <= 0)
         abortImport();

    InterfaceArray *a = allocateInterfaceArray(obj, length);
    for (int i=0; i<length; i++)
        a->elements[i] = functionPointerFromName(
            obj,
            signatureIndex,
            Interface_fromPy(
                obj,
                PyList_GET_ITEM(pyObj, i),
                signatureIndex
            )
        );
    
    return a;
}

PyObject *InterfaceMatrix_toPy(QObject * obj, InterfaceMatrix *m) {
    int n = m->length;
    PyObject *pyList = PyList_New(n);
    
    for (int i=0; i<n; i++)
        PyList_SetItem(pyList, i, InterfaceArray_toPy(obj, m->elements[i]));
    
    return pyList;
}

InterfaceMatrix *InterfaceMatrix_fromPy(QObject *obj, PyObject *pyObj, int signatureIndex) {
    if (!PyList_Check(pyObj))
        abortImport();
    
    int rowCount = (int) PyList_Size(pyObj);
    if (!rowCount)
        abortImport();
  
    InterfaceMatrix *m = allocateInterfaceMatrix(obj, rowCount, 0);
    
    for (int i=0; i<rowCount; i++) {
        PyObject *pyRow = PyList_GET_ITEM(pyObj, i);
        m->elements[i] = InterfaceArray_fromPy(obj, pyRow, signatureIndex);
    }    

    return m;
}

// StandardMultiserver

#define _StandardMultiserver_IMPLEMENTATION_COUNT 0
typedef struct _StandardMultiserver_object _StandardMultiserver_object;

typedef struct _StandardMultiserver_object {
    PyObject_HEAD
    bool isMemModified;
    MemHeader *memList;
    int functionCount;
    void **functionPointers;
    const char **functionNames;
    int *functionSignatureIndexes;
    unsigned long long currentMemoryUse;
    unsigned long long peakMemoryUse;
    Pmf * _numberOfArrivalsPmf;
    Pmf * _serviceDurationPmf;
    Int _numberOfServers;
    Pmf * _internalState;
    Int _time;
    Pmf * _markNumberOfArrivalsPmf;
    Pmf * _markServiceDurationPmf;
    Int _markNumberOfServers;
    Pmf * _markInternalState;
    Int _markTime;
} _StandardMultiserver_object;

void _StandardMultiserver_memRelease(_StandardMultiserver_object *self) {
    flag(self->_numberOfArrivalsPmf);
    flag(self->_serviceDurationPmf);
    flag(self->_internalState);
    flag(self->_markNumberOfArrivalsPmf);
    flag(self->_markServiceDurationPmf);
    flag(self->_markInternalState);
    release((QObject *) self);
}

PyObject *_StandardMultiserver_get_numberOfArrivalsPmf(_StandardMultiserver_object *self, PyObject *args) { 
    try {
        return Pmf_toPy((QObject *) self, self->_numberOfArrivalsPmf);
    } catch(CException x) {
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

int _StandardMultiserver_set_numberOfArrivalsPmf(_StandardMultiserver_object *self, PyObject *arg) { 
    try {
        Pmf * value = Pmf_fromPy((QObject *) self, arg);         
        confirmSimplePmf(value);
        self->_numberOfArrivalsPmf = value; 
       if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
         return 0;
    } catch(CException x) {
       if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
         PyErr_SetString(PException, x.message);
        return -1;
    }
}

PyObject *_StandardMultiserver_get_serviceDurationPmf(_StandardMultiserver_object *self, PyObject *args) { 
    try {
        return Pmf_toPy((QObject *) self, self->_serviceDurationPmf);
    } catch(CException x) {
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

int _StandardMultiserver_set_serviceDurationPmf(_StandardMultiserver_object *self, PyObject *arg) { 
    try {
        Pmf * value = Pmf_fromPy((QObject *) self, arg);         
        confirmSimplePmf(value);
        self->_serviceDurationPmf = value; 
       if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
         return 0;
    } catch(CException x) {
       if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
         PyErr_SetString(PException, x.message);
        return -1;
    }
}

PyObject *_StandardMultiserver_get_internalState(_StandardMultiserver_object *self, PyObject *args) { 
    try {
        return Pmf_toPy((QObject *) self, self->_internalState);
    } catch(CException x) {
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

int _StandardMultiserver_set_internalState(_StandardMultiserver_object *self, PyObject *arg) { 
    try {
        Pmf * value = Pmf_fromPy((QObject *) self, arg);         
        confirmJointPmf(value,2);
        self->_internalState = value; 
       if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
         return 0;
    } catch(CException x) {
       if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
         PyErr_SetString(PException, x.message);
        return -1;
    }
}

void _StandardMultiserver_init(_StandardMultiserver_object * self) {
    self->_serviceDurationPmf = (new SimpleAccumulator((QObject *)self))->putSingle(1.0,1)->toPmfAndDelete();
}

PyObject *_StandardMultiserver_init_Py(PyObject *pyObj, PyObject *args) {
    _StandardMultiserver_object *self = (_StandardMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 0)
            throw CException("Expected 0 parameters");
        
        _StandardMultiserver_init(self);
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

Pmf * _StandardMultiserver_relabel(_StandardMultiserver_object * self, Int _z) {
    SamplingStack samplingStack(1);
    SimpleAccumulator accumulator((QObject *) self);
    Pmf *dist_ell = lookupConditionalPmf(self->_internalState,1,_z);
    Int min_ell = dist_ell->simple.offset;
    Int max_ell = dist_ell->simple.offset+dist_ell->simple.length - 1;
    for (Int _ell = min_ell; _ell <= max_ell; _ell++) {
        Real prob_ell = dist_ell->simple.elements[_ell-dist_ell->simple.offset];
        if (prob_ell <= 0)
            continue;
        samplingStack.set(0, prob_ell);
        if (_ell==1) {
            ;
            continue;
        }
        Int sample = _ell-1;
        Real prob = samplingStack.branchProbability(0);
        accumulator.putSingle(prob, sample);
        continue;
    }
    Pmf *retPmf = accumulator.toPmf();
    return retPmf;
}

Pmf * _StandardMultiserver_partialQplexMap(_StandardMultiserver_object * self) {
    SamplingStack samplingStack(3);
    SimpleAccumulator accumulator((QObject *) self);
    Pmf *dist_z = lookupMarginalPmf(self->_internalState);
    Int min_z = dist_z->simple.offset;
    Int max_z = dist_z->simple.offset+dist_z->simple.length - 1;
    for (Int _z = min_z; _z <= max_z; _z++) {
        Real prob_z = dist_z->simple.elements[_z-dist_z->simple.offset];
        if (prob_z <= 0)
            continue;
        samplingStack.set(0, prob_z);
        Pmf *dist_d = binomial((QObject *) self,std::min(_z,self->_numberOfServers),lookupProbability(lookupConditionalPmf(self->_internalState,1,_z),1));
        Int min_d = dist_d->simple.offset;
        Int max_d = dist_d->simple.offset+dist_d->simple.length - 1;
        for (Int _d = min_d; _d <= max_d; _d++) {
            Real prob_d = dist_d->simple.elements[_d-dist_d->simple.offset];
            if (prob_d <= 0)
                continue;
            samplingStack.branch(1, prob_d);
            Pmf *dist_a = self->_numberOfArrivalsPmf;
            Int min_a = dist_a->simple.offset;
            Int max_a = dist_a->simple.offset+dist_a->simple.length - 1;
            for (Int _a = min_a; _a <= max_a; _a++) {
                Real prob_a = dist_a->simple.elements[_a-dist_a->simple.offset];
                if (prob_a <= 0)
                    continue;
                samplingStack.branch(2, prob_a);
                Int sample = _z-_d+_a;
                Real prob = samplingStack.branchProbability(2);
                accumulator.putSingle(prob, sample);
                continue;
            }
        }
    }
    Pmf *retPmf = accumulator.toPmf();
    return retPmf;
}

Pmf * _StandardMultiserver_qplexMap(_StandardMultiserver_object * self, Int _leftTail, Int _rightTail) {
    SamplingStack samplingStack(5);
    JointAccumulator accumulator((QObject *) self, 2);
    Pmf *dist_z = lookupMarginalPmf(self->_internalState);
    Int min_z = dist_z->simple.offset;
    Int max_z = dist_z->simple.offset+dist_z->simple.length - 1;
    for (Int _z = min_z; _z <= max_z; _z++) {
        Real prob_z = dist_z->simple.elements[_z-dist_z->simple.offset];
        if (prob_z <= 0)
            continue;
        samplingStack.set(0, prob_z);
        Pmf *dist_d = binomial((QObject *) self,std::min(_z,self->_numberOfServers),lookupProbability(lookupConditionalPmf(self->_internalState,1,_z),1));
        Int min_d = dist_d->simple.offset;
        Int max_d = dist_d->simple.offset+dist_d->simple.length - 1;
        for (Int _d = min_d; _d <= max_d; _d++) {
            Real prob_d = dist_d->simple.elements[_d-dist_d->simple.offset];
            if (prob_d <= 0)
                continue;
            samplingStack.branch(1, prob_d);
            Pmf *dist_a = self->_numberOfArrivalsPmf;
            Int min_a = dist_a->simple.offset;
            Int max_a = dist_a->simple.offset+dist_a->simple.length - 1;
            for (Int _a = min_a; _a <= max_a; _a++) {
                Real prob_a = dist_a->simple.elements[_a-dist_a->simple.offset];
                if (prob_a <= 0)
                    continue;
                samplingStack.branch(2, prob_a);
                Int _zprime = _z-_d+_a;
                if ((_zprime<_leftTail)||(_zprime>_rightTail)) {
                    ;
                    continue;
                }
                if (_zprime==0||self->_numberOfServers==0) {
                    Pmf *dist_ellprime = self->_serviceDurationPmf;
                    Int min_ellprime = dist_ellprime->simple.offset;
                    Int max_ellprime = dist_ellprime->simple.offset+dist_ellprime->simple.length - 1;
                    for (Int _ellprime = min_ellprime; _ellprime <= max_ellprime; _ellprime++) {
                        Real prob_ellprime = dist_ellprime->simple.elements[_ellprime-dist_ellprime->simple.offset];
                        if (prob_ellprime <= 0)
                            continue;
                        samplingStack.branch(3, prob_ellprime);
                        Int sample1 = _zprime;
                        Int sample2 = _ellprime;
                        Real prob = samplingStack.branchProbability(3);
                        accumulator.putDouble(prob,sample1,sample2);
                        continue;
                    }
                    continue;
                }
                Pmf *dist_entityIsOld = bernoulli((QObject *) self,(std::min(_z,self->_numberOfServers)-_d)/checkDenominator(std::min(_zprime,self->_numberOfServers)));
                Int min_entityIsOld = dist_entityIsOld->simple.offset;
                Int max_entityIsOld = dist_entityIsOld->simple.offset+dist_entityIsOld->simple.length - 1;
                for (Int _entityIsOld = min_entityIsOld; _entityIsOld <= max_entityIsOld; _entityIsOld++) {
                    Real prob_entityIsOld = dist_entityIsOld->simple.elements[_entityIsOld-dist_entityIsOld->simple.offset];
                    if (prob_entityIsOld <= 0)
                        continue;
                    samplingStack.branch(3, prob_entityIsOld);
                    if (_entityIsOld==1) {
                        Pmf *dist_ellprime = _StandardMultiserver_relabel(self,_z);
                        Int min_ellprime = dist_ellprime->simple.offset;
                        Int max_ellprime = dist_ellprime->simple.offset+dist_ellprime->simple.length - 1;
                        for (Int _ellprime = min_ellprime; _ellprime <= max_ellprime; _ellprime++) {
                            Real prob_ellprime = dist_ellprime->simple.elements[_ellprime-dist_ellprime->simple.offset];
                            if (prob_ellprime <= 0)
                                continue;
                            samplingStack.branch(4, prob_ellprime);
                            Int sample1 = _zprime;
                            Int sample2 = _ellprime;
                            Real prob = samplingStack.branchProbability(4);
                            accumulator.putDouble(prob,sample1,sample2);
                            continue;
                        }
                        continue;
                    } else {
                        Pmf *dist_ellprime = self->_serviceDurationPmf;
                        Int min_ellprime = dist_ellprime->simple.offset;
                        Int max_ellprime = dist_ellprime->simple.offset+dist_ellprime->simple.length - 1;
                        for (Int _ellprime = min_ellprime; _ellprime <= max_ellprime; _ellprime++) {
                            Real prob_ellprime = dist_ellprime->simple.elements[_ellprime-dist_ellprime->simple.offset];
                            if (prob_ellprime <= 0)
                                continue;
                            samplingStack.branch(4, prob_ellprime);
                            Int sample1 = _zprime;
                            Int sample2 = _ellprime;
                            Real prob = samplingStack.branchProbability(4);
                            accumulator.putDouble(prob,sample1,sample2);
                            continue;
                        }
                        continue;
                    }
                }
            }
        }
    }
    Pmf *retPmf = accumulator.toPmf();
    return retPmf;
}

Pmf * _StandardMultiserver_observationMapRange(_StandardMultiserver_object * self, Int _z0, Int _z1) {
    SamplingStack samplingStack(2);
    JointAccumulator accumulator((QObject *) self, 2);
    Pmf *dist_z = self->_internalState;
    Int min_z = dist_z->joint.marginal->simple.offset;
    Int max_z = dist_z->joint.marginal->simple.offset+dist_z->joint.marginal->simple.length - 1;
    for (Int _z = min_z; _z <= max_z; _z++) {
        Real prob_z = dist_z->joint.marginal->simple.elements[_z-dist_z->joint.marginal->simple.offset];
        if (prob_z <= 0)
            continue;
        samplingStack.set(0, prob_z);
        Pmf *dist_ell = lookupConditionalPmf(dist_z, 1, _z);
        Int min_ell = dist_ell->simple.offset;
        Int max_ell = dist_ell->simple.offset+dist_ell->simple.length - 1;
        for (Int _ell = min_ell; _ell <= max_ell; _ell++) {
            Real prob_ell = dist_ell->simple.elements[_ell-dist_ell->simple.offset];
            if (prob_ell <= 0)
                continue;
            samplingStack.branch(1, prob_ell);
            if (_z<_z0||_z>=_z1) {
                ;
                continue;
            }
            Int sample1 = _z;
            Int sample2 = _ell;
            Real prob = samplingStack.branchProbability(1);
            accumulator.putDouble(prob,sample1,sample2);
            continue;
        }
    }
    Pmf *retPmf = accumulator.toPmf();
    return retPmf;
}

Pmf * _StandardMultiserver_resetMap(_StandardMultiserver_object * self, Int _z0) {
    SamplingStack samplingStack(1);
    JointAccumulator accumulator((QObject *) self, 2);
    Pmf *dist_ell = self->_serviceDurationPmf;
    Int min_ell = dist_ell->simple.offset;
    Int max_ell = dist_ell->simple.offset+dist_ell->simple.length - 1;
    for (Int _ell = min_ell; _ell <= max_ell; _ell++) {
        Real prob_ell = dist_ell->simple.elements[_ell-dist_ell->simple.offset];
        if (prob_ell <= 0)
            continue;
        samplingStack.set(0, prob_ell);
        Int sample1 = _z0;
        Int sample2 = _ell;
        Real prob = samplingStack.branchProbability(0);
        accumulator.putDouble(prob,sample1,sample2);
        continue;
    }
    Pmf *retPmf = accumulator.toPmf();
    return retPmf;
}

void _StandardMultiserver_step(_StandardMultiserver_object * self) {
    if (self->_numberOfServers<0) {
        throw CException("Invalid number of servers. The number of servers must be nonnegative.");
    }
    if (self->_serviceDurationPmf->simple.offset==0) {
        throw CException("Invalid service duration pmf. Service durations must be strictly positive.");
    }
    Real _tolerance = 1e-8;
    Pmf * _p = _StandardMultiserver_partialQplexMap(self);
    Int _leftTail = computeLeftTail(_p,_tolerance/checkDenominator(2));
    Int _rightTail = computeRightTail(_p,_tolerance/checkDenominator(2));
    self->_internalState = _StandardMultiserver_qplexMap(self,_leftTail,_rightTail);
    self->_time = self->_time+1;
}

PyObject *_StandardMultiserver_step_Py(PyObject *pyObj, PyObject *args) {
    _StandardMultiserver_object *self = (_StandardMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 0)
            throw CException("Expected 0 parameters");
        
        _StandardMultiserver_step(self);
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardMultiserver_applyObservationRange(_StandardMultiserver_object * self, Int _startOfRange, Int _endOfRange) {
    self->_internalState = _StandardMultiserver_observationMapRange(self,_startOfRange,_endOfRange);
}

PyObject *_StandardMultiserver_applyObservationRange_Py(PyObject *pyObj, PyObject *args) {
    _StandardMultiserver_object *self = (_StandardMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 2)
            throw CException("Expected 2 parameters");
        
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        
        Int arg1 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 1));
        
        _StandardMultiserver_applyObservationRange(self, arg0, arg1);
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardMultiserver_applyObservationValue(_StandardMultiserver_object * self, Int _observedNumberOfEntitiesInSystem) {
    self->_internalState = _StandardMultiserver_observationMapRange(self,_observedNumberOfEntitiesInSystem,_observedNumberOfEntitiesInSystem+1);
}

PyObject *_StandardMultiserver_applyObservationValue_Py(PyObject *pyObj, PyObject *args) {
    _StandardMultiserver_object *self = (_StandardMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 1)
            throw CException("Expected 1 parameters");
        
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        
        _StandardMultiserver_applyObservationValue(self, arg0);
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardMultiserver_mark(_StandardMultiserver_object * self) {
    self->_markNumberOfArrivalsPmf = self->_numberOfArrivalsPmf;
    self->_markServiceDurationPmf = self->_serviceDurationPmf;
    self->_markNumberOfServers = self->_numberOfServers;
    self->_markInternalState = self->_internalState;
    self->_markTime = self->_time;
}

PyObject *_StandardMultiserver_mark_Py(PyObject *pyObj, PyObject *args) {
    _StandardMultiserver_object *self = (_StandardMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 0)
            throw CException("Expected 0 parameters");
        
        _StandardMultiserver_mark(self);
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardMultiserver_restore(_StandardMultiserver_object * self) {
    self->_numberOfArrivalsPmf = self->_markNumberOfArrivalsPmf;
    self->_serviceDurationPmf = self->_markServiceDurationPmf;
    self->_numberOfServers = self->_markNumberOfServers;
    self->_internalState = self->_markInternalState;
    self->_time = self->_markTime;
}

PyObject *_StandardMultiserver_restore_Py(PyObject *pyObj, PyObject *args) {
    _StandardMultiserver_object *self = (_StandardMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 0)
            throw CException("Expected 0 parameters");
        
        _StandardMultiserver_restore(self);
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

Pmf * _StandardMultiserver_getNumberOfEntitiesInSystemPmf(_StandardMultiserver_object * self) {
    Pmf * returnValue = lookupMarginalPmf(self->_internalState);
    return returnValue;
}

PyObject *_StandardMultiserver_getNumberOfEntitiesInSystemPmf_Py(PyObject *pyObj, PyObject *args) {
    _StandardMultiserver_object *self = (_StandardMultiserver_object *) pyObj;
    try {
        self->isMemModified = false;
        if (PyTuple_Size(args) != 0)
            throw CException("Expected 0 parameter(s)");
        PyObject *returnValue = Pmf_toPy((QObject *) self, _StandardMultiserver_getNumberOfEntitiesInSystemPmf(self));
            if (self->isMemModified)
                _StandardMultiserver_memRelease(self);
        return returnValue;
    } catch (CException x) {
    if (self->isMemModified)
        _StandardMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardMultiserver_resetWithNumberOfEntitiesInSystem(_StandardMultiserver_object * self, Int _numberOfEntitiesInSystem) {
    if (_numberOfEntitiesInSystem<0) {
        throw CException("Invalid number of entities. The number of entities must be nonnegative.");
    }
    if (self->_serviceDurationPmf->simple.offset==0) {
        throw CException("Invalid service duration pmf. Service durations must be strictly positive.");
    }
    self->_internalState = _StandardMultiserver_resetMap(self,_numberOfEntitiesInSystem);
}

PyObject *_StandardMultiserver_resetWithNumberOfEntitiesInSystem_Py(PyObject *pyObj, PyObject *args) {
    _StandardMultiserver_object *self = (_StandardMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 1)
            throw CException("Expected 1 parameters");
        
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        
        _StandardMultiserver_resetWithNumberOfEntitiesInSystem(self, arg0);
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void **_StandardMultiserver_functionPointers = NULL;
const char **_StandardMultiserver_functionNames = NULL;
int *_StandardMultiserver_functionSignatureIndexes = NULL;

PyObject *_StandardMultiserver_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
    _StandardMultiserver_object *self;
 
    self = (_StandardMultiserver_object *) type->tp_alloc(type, 0);
    if (self == NULL) 
        return NULL;

    self->isMemModified = false;
    self->memList = NULL;
    self->functionCount = _StandardMultiserver_IMPLEMENTATION_COUNT;
    self->functionPointers = _StandardMultiserver_functionPointers;
    self->functionNames = _StandardMultiserver_functionNames;
    self->functionSignatureIndexes = _StandardMultiserver_functionSignatureIndexes;
    self->currentMemoryUse = 0;
    self->peakMemoryUse = 0;

    self->_numberOfArrivalsPmf = defaultPmf((QObject *)self, createSimplePmfConfig((QObject *)self));
    self->_serviceDurationPmf = defaultPmf((QObject *)self, createSimplePmfConfig((QObject *)self));
    self->_numberOfServers = 0;
    self->_internalState = defaultPmf((QObject *)self, createJointPmfConfig((QObject *)self, 2));
    self->_time = 0;
    self->_markNumberOfArrivalsPmf = defaultPmf((QObject *)self, createSimplePmfConfig((QObject *)self));
    self->_markServiceDurationPmf = defaultPmf((QObject *)self, createSimplePmfConfig((QObject *)self));
    self->_markNumberOfServers = 0;
    self->_markInternalState = defaultPmf((QObject *)self, createJointPmfConfig((QObject *)self, 2));
    self->_markTime = 0;
    

    if (_StandardMultiserver_init_Py((PyObject *) self, args) == Py_None)
        return (PyObject *) self;
    else
        return NULL;
}
PyMethodDef _StandardMultiserver_methods[] = {
    { "step", _StandardMultiserver_step_Py, METH_VARARGS, NULL },
    { "apply_observation_range", _StandardMultiserver_applyObservationRange_Py, METH_VARARGS, NULL },
    { "apply_observation_value", _StandardMultiserver_applyObservationValue_Py, METH_VARARGS, NULL },
    { "mark", _StandardMultiserver_mark_Py, METH_VARARGS, NULL },
    { "restore", _StandardMultiserver_restore_Py, METH_VARARGS, NULL },
    { "get_number_of_entities_in_system_pmf", _StandardMultiserver_getNumberOfEntitiesInSystemPmf_Py, METH_VARARGS, NULL },
    { "reset_with_number_of_entities_in_system", _StandardMultiserver_resetWithNumberOfEntitiesInSystem_Py, METH_VARARGS, NULL },
    { NULL }
};

PyMemberDef _StandardMultiserver_members[] = {
    { "number_of_servers", T_INT, offsetof(_StandardMultiserver_object, _numberOfServers), 0, NULL },
    { "time", T_INT, offsetof(_StandardMultiserver_object, _time), 0, NULL },
    { "current_memory_use", T_ULONGLONG, offsetof(_StandardMultiserver_object, currentMemoryUse), READONLY, NULL },
    { "peak_memory_use", T_ULONGLONG, offsetof(_StandardMultiserver_object, peakMemoryUse), READONLY, NULL },
    { NULL }
};

PyGetSetDef _StandardMultiserver_getset[] = {
    { "number_of_arrivals_pmf", (getter)_StandardMultiserver_get_numberOfArrivalsPmf, (setter)_StandardMultiserver_set_numberOfArrivalsPmf, NULL, NULL },
    { "service_duration_pmf", (getter)_StandardMultiserver_get_serviceDurationPmf, (setter)_StandardMultiserver_set_serviceDurationPmf, NULL, NULL },
    { "internal_state", (getter)_StandardMultiserver_get_internalState, (setter)_StandardMultiserver_set_internalState, NULL, NULL },
    { NULL }
};

static PyTypeObject _StandardMultiserver_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "qplex.StandardMultiserver",                      // tp_name 
    sizeof(_StandardMultiserver_object),                // tp_basicsize 
    0,                                      // tp_itemsize 
    (destructor) dealloc,                   // tp_dealloc 
    0,                                      // tp_vectorcall_offset 
    0,                                      // tp_getattr 
    0,                                      // tp_setattr 
    0,                                      // tp_as_async 
    0,                                      // tp_repr 
    0,                                      // tp_as_number 
    0,                                      // tp_as_sequence 
    0,                                      // tp_as_mapping 
    0,                                      // tp_hash 
    0,                                      // tp_call 
    0,                                      // tp_str 
    0,                                      // tp_getattro 
    0,                                      // tp_setattro 
    0,                                      // tp_as_buffer 
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   // tp_flags 
    0,                                      // tp_doc 
    0,                                      // tp_traverse 
    0,                                      // tp_clear 
    0,                                      // tp_richcompare 
    0,                                      // tp_weaklistoffset 
    0,                                      // tp_iter 
    0,                                      // tp_iternext 
    _StandardMultiserver_methods,                       // tp_methods 
    _StandardMultiserver_members,                       // tp_members 
    _StandardMultiserver_getset,                        // tp_getset 
    0,                                      // tp_base 
    0,                                      // tp_dict 
    0,                                      // tp_descr_get 
    0,                                      // tp_descr_set 
    0,                                      // tp_dictoffset 
    0,                                      // tp_init 
    0,                                      // tp_alloc 
    _StandardMultiserver_new,                           // tp_new 
};
// StandardNetworkMultiserver

#define _StandardNetworkMultiserver_IMPLEMENTATION_COUNT 0
typedef struct _StandardNetworkMultiserver_object _StandardNetworkMultiserver_object;

typedef struct _StandardNetworkMultiserver_object {
    PyObject_HEAD
    bool isMemModified;
    MemHeader *memList;
    int functionCount;
    void **functionPointers;
    const char **functionNames;
    int *functionSignatureIndexes;
    unsigned long long currentMemoryUse;
    unsigned long long peakMemoryUse;
    PmfArray * _internalState;
    Int _time;
    IntArray * _numberOfServers;
    PmfArray * _numberOfExternalArrivalsPmfs;
    PmfArray * _serviceDurationPmfs;
    RealMatrix * _routingProbabilities;
    PmfArray * _markInternalState;
    Int _markTime;
    IntArray * _markNumberOfServers;
    PmfArray * _markNumberOfExternalArrivalsPmfs;
    PmfArray * _markServiceDurationPmfs;
    RealMatrix * _markRoutingProbabilities;
} _StandardNetworkMultiserver_object;

void _StandardNetworkMultiserver_memRelease(_StandardNetworkMultiserver_object *self) {
    flag(self->_internalState);
    flag(self->_numberOfServers);
    flag(self->_numberOfExternalArrivalsPmfs);
    flag(self->_serviceDurationPmfs);
    flag(self->_routingProbabilities);
    flag(self->_markInternalState);
    flag(self->_markNumberOfServers);
    flag(self->_markNumberOfExternalArrivalsPmfs);
    flag(self->_markServiceDurationPmfs);
    flag(self->_markRoutingProbabilities);
    release((QObject *) self);
}

PyObject *_StandardNetworkMultiserver_get_internalState(_StandardNetworkMultiserver_object *self, PyObject *args) { 
    try {
        return PmfArray_toPy((QObject *) self, self->_internalState);
    } catch(CException x) {
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

int _StandardNetworkMultiserver_set_internalState(_StandardNetworkMultiserver_object *self, PyObject *arg) { 
    try {
        PmfArray * value = PmfArray_fromPy((QObject *) self, arg);         
        confirmJointPmfArray(value,2);
        self->_internalState = value; 
       if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
         return 0;
    } catch(CException x) {
       if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
         PyErr_SetString(PException, x.message);
        return -1;
    }
}

void _StandardNetworkMultiserver_init(_StandardNetworkMultiserver_object * self, Int _numberOfNodes) {
    if (_numberOfNodes<=0) {
        throw CException("Invalid number of nodes. The number of nodes must be strictly positive.");
    }
    self->_internalState = createPmfArray((QObject *)self, createJointPmfConfig((QObject *)self, 2),_numberOfNodes);
    self->_time = 0;
    self->_numberOfServers = createIntArray((QObject *)self, _numberOfNodes);
    self->_numberOfExternalArrivalsPmfs = createPmfArray((QObject *)self, createSimplePmfConfig((QObject *)self),_numberOfNodes);
    self->_serviceDurationPmfs = createPmfArray((QObject *)self, createSimplePmfConfig((QObject *)self),_numberOfNodes);
    Int min26 = 0;
    Int max26 = _numberOfNodes-1;
    for (Int _nodeIndex=min26; _nodeIndex<=max26; _nodeIndex++) {
        int index27 = _nodeIndex;
        lookup(self->_serviceDurationPmfs,index27) = (new SimpleAccumulator((QObject *)self))->putSingle(1.0,1)->toPmfAndDelete();
    }
    self->_routingProbabilities = createRealMatrix((QObject *)self, _numberOfNodes,_numberOfNodes);
    self->_markInternalState = createPmfArray((QObject *)self, createJointPmfConfig((QObject *)self, 2),_numberOfNodes);
    self->_markNumberOfServers = createIntArray((QObject *)self, _numberOfNodes);
    self->_markNumberOfExternalArrivalsPmfs = createPmfArray((QObject *)self, createSimplePmfConfig((QObject *)self),_numberOfNodes);
    self->_markServiceDurationPmfs = createPmfArray((QObject *)self, createSimplePmfConfig((QObject *)self),_numberOfNodes);
    Int min35 = 0;
    Int max35 = _numberOfNodes-1;
    for (Int _nodeIndex=min35; _nodeIndex<=max35; _nodeIndex++) {
        int index36 = _nodeIndex;
        lookup(self->_markServiceDurationPmfs,index36) = (new SimpleAccumulator((QObject *)self))->putSingle(1.0,1)->toPmfAndDelete();
    }
    self->_markRoutingProbabilities = createRealMatrix((QObject *)self, _numberOfNodes,_numberOfNodes);
}

PyObject *_StandardNetworkMultiserver_init_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 1)
            throw CException("Expected 1 parameters");
        
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        
        _StandardNetworkMultiserver_init(self, arg0);
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

Pmf * _StandardNetworkMultiserver_convolution(_StandardNetworkMultiserver_object * self, Pmf * _p1, Pmf * _p2) {
    SamplingStack samplingStack(2);
    SimpleAccumulator accumulator((QObject *) self);
    Pmf *dist_x = _p1;
    Int min_x = dist_x->simple.offset;
    Int max_x = dist_x->simple.offset+dist_x->simple.length - 1;
    for (Int _x = min_x; _x <= max_x; _x++) {
        Real prob_x = dist_x->simple.elements[_x-dist_x->simple.offset];
        if (prob_x <= 0)
            continue;
        samplingStack.set(0, prob_x);
        Pmf *dist_y = _p2;
        Int min_y = dist_y->simple.offset;
        Int max_y = dist_y->simple.offset+dist_y->simple.length - 1;
        for (Int _y = min_y; _y <= max_y; _y++) {
            Real prob_y = dist_y->simple.elements[_y-dist_y->simple.offset];
            if (prob_y <= 0)
                continue;
            samplingStack.branch(1, prob_y);
            Int sample = _x+_y;
            Real prob = samplingStack.branchProbability(1);
            accumulator.putSingle(prob, sample);
            continue;
        }
    }
    Pmf *retPmf = accumulator.toPmf();
    return retPmf;
}

Pmf * _StandardNetworkMultiserver_flow(_StandardNetworkMultiserver_object * self, Int _sourceNodeIndex, Int _destinationNodeIndex) {
    SamplingStack samplingStack(3);
    SimpleAccumulator accumulator((QObject *) self);
    Pmf *dist_z = lookupMarginalPmf(lookup(self->_internalState,_sourceNodeIndex));
    Int min_z = dist_z->simple.offset;
    Int max_z = dist_z->simple.offset+dist_z->simple.length - 1;
    for (Int _z = min_z; _z <= max_z; _z++) {
        Real prob_z = dist_z->simple.elements[_z-dist_z->simple.offset];
        if (prob_z <= 0)
            continue;
        samplingStack.set(0, prob_z);
        Pmf *dist_d = binomial((QObject *) self,std::min(_z,lookup(self->_numberOfServers,_sourceNodeIndex)),lookupProbability(lookupConditionalPmf(lookup(self->_internalState,_sourceNodeIndex),1,_z),1));
        Int min_d = dist_d->simple.offset;
        Int max_d = dist_d->simple.offset+dist_d->simple.length - 1;
        for (Int _d = min_d; _d <= max_d; _d++) {
            Real prob_d = dist_d->simple.elements[_d-dist_d->simple.offset];
            if (prob_d <= 0)
                continue;
            samplingStack.branch(1, prob_d);
            Pmf *dist_phi = binomial((QObject *) self,_d,lookup(lookup(self->_routingProbabilities,_sourceNodeIndex),_destinationNodeIndex));
            Int min_phi = dist_phi->simple.offset;
            Int max_phi = dist_phi->simple.offset+dist_phi->simple.length - 1;
            for (Int _phi = min_phi; _phi <= max_phi; _phi++) {
                Real prob_phi = dist_phi->simple.elements[_phi-dist_phi->simple.offset];
                if (prob_phi <= 0)
                    continue;
                samplingStack.branch(2, prob_phi);
                Int sample = _phi;
                Real prob = samplingStack.branchProbability(2);
                accumulator.putSingle(prob, sample);
                continue;
            }
        }
    }
    Pmf *retPmf = accumulator.toPmf();
    return retPmf;
}

Pmf * _StandardNetworkMultiserver_relabel(_StandardNetworkMultiserver_object * self, Int _nodeIndex, Int _z) {
    SamplingStack samplingStack(1);
    SimpleAccumulator accumulator((QObject *) self);
    Pmf *dist_ell = lookupConditionalPmf(lookup(self->_internalState,_nodeIndex),1,_z);
    Int min_ell = dist_ell->simple.offset;
    Int max_ell = dist_ell->simple.offset+dist_ell->simple.length - 1;
    for (Int _ell = min_ell; _ell <= max_ell; _ell++) {
        Real prob_ell = dist_ell->simple.elements[_ell-dist_ell->simple.offset];
        if (prob_ell <= 0)
            continue;
        samplingStack.set(0, prob_ell);
        if (_ell==1) {
            ;
            continue;
        }
        Int sample = _ell-1;
        Real prob = samplingStack.branchProbability(0);
        accumulator.putSingle(prob, sample);
        continue;
    }
    Pmf *retPmf = accumulator.toPmf();
    return retPmf;
}

Pmf * _StandardNetworkMultiserver_partialQplexMapAtNode(_StandardNetworkMultiserver_object * self, Int _nodeIndex, Pmf * _internalFlowIn) {
    SamplingStack samplingStack(4);
    SimpleAccumulator accumulator((QObject *) self);
    Pmf *dist_z = lookupMarginalPmf(lookup(self->_internalState,_nodeIndex));
    Int min_z = dist_z->simple.offset;
    Int max_z = dist_z->simple.offset+dist_z->simple.length - 1;
    for (Int _z = min_z; _z <= max_z; _z++) {
        Real prob_z = dist_z->simple.elements[_z-dist_z->simple.offset];
        if (prob_z <= 0)
            continue;
        samplingStack.set(0, prob_z);
        Pmf *dist_d = binomial((QObject *) self,std::min(_z,lookup(self->_numberOfServers,_nodeIndex)),lookupProbability(lookupConditionalPmf(lookup(self->_internalState,_nodeIndex),1,_z),1));
        Int min_d = dist_d->simple.offset;
        Int max_d = dist_d->simple.offset+dist_d->simple.length - 1;
        for (Int _d = min_d; _d <= max_d; _d++) {
            Real prob_d = dist_d->simple.elements[_d-dist_d->simple.offset];
            if (prob_d <= 0)
                continue;
            samplingStack.branch(1, prob_d);
            Pmf *dist_phi = binomial((QObject *) self,_d,lookup(lookup(self->_routingProbabilities,_nodeIndex),_nodeIndex));
            Int min_phi = dist_phi->simple.offset;
            Int max_phi = dist_phi->simple.offset+dist_phi->simple.length - 1;
            for (Int _phi = min_phi; _phi <= max_phi; _phi++) {
                Real prob_phi = dist_phi->simple.elements[_phi-dist_phi->simple.offset];
                if (prob_phi <= 0)
                    continue;
                samplingStack.branch(2, prob_phi);
                Pmf *dist_a = _StandardNetworkMultiserver_convolution(self,lookup(self->_numberOfExternalArrivalsPmfs,_nodeIndex),_internalFlowIn);
                Int min_a = dist_a->simple.offset;
                Int max_a = dist_a->simple.offset+dist_a->simple.length - 1;
                for (Int _a = min_a; _a <= max_a; _a++) {
                    Real prob_a = dist_a->simple.elements[_a-dist_a->simple.offset];
                    if (prob_a <= 0)
                        continue;
                    samplingStack.branch(3, prob_a);
                    Int sample = _z-_d+_phi+_a;
                    Real prob = samplingStack.branchProbability(3);
                    accumulator.putSingle(prob, sample);
                    continue;
                }
            }
        }
    }
    Pmf *retPmf = accumulator.toPmf();
    return retPmf;
}

Pmf * _StandardNetworkMultiserver_qplexMapAtNode(_StandardNetworkMultiserver_object * self, Int _nodeIndex, Pmf * _internalFlowIn, Int _leftTail, Int _rightTail) {
    SamplingStack samplingStack(6);
    JointAccumulator accumulator((QObject *) self, 2);
    Pmf *dist_z = lookupMarginalPmf(lookup(self->_internalState,_nodeIndex));
    Int min_z = dist_z->simple.offset;
    Int max_z = dist_z->simple.offset+dist_z->simple.length - 1;
    for (Int _z = min_z; _z <= max_z; _z++) {
        Real prob_z = dist_z->simple.elements[_z-dist_z->simple.offset];
        if (prob_z <= 0)
            continue;
        samplingStack.set(0, prob_z);
        Pmf *dist_d = binomial((QObject *) self,std::min(_z,lookup(self->_numberOfServers,_nodeIndex)),lookupProbability(lookupConditionalPmf(lookup(self->_internalState,_nodeIndex),1,_z),1));
        Int min_d = dist_d->simple.offset;
        Int max_d = dist_d->simple.offset+dist_d->simple.length - 1;
        for (Int _d = min_d; _d <= max_d; _d++) {
            Real prob_d = dist_d->simple.elements[_d-dist_d->simple.offset];
            if (prob_d <= 0)
                continue;
            samplingStack.branch(1, prob_d);
            Pmf *dist_phi = binomial((QObject *) self,_d,lookup(lookup(self->_routingProbabilities,_nodeIndex),_nodeIndex));
            Int min_phi = dist_phi->simple.offset;
            Int max_phi = dist_phi->simple.offset+dist_phi->simple.length - 1;
            for (Int _phi = min_phi; _phi <= max_phi; _phi++) {
                Real prob_phi = dist_phi->simple.elements[_phi-dist_phi->simple.offset];
                if (prob_phi <= 0)
                    continue;
                samplingStack.branch(2, prob_phi);
                Pmf *dist_a = _StandardNetworkMultiserver_convolution(self,lookup(self->_numberOfExternalArrivalsPmfs,_nodeIndex),_internalFlowIn);
                Int min_a = dist_a->simple.offset;
                Int max_a = dist_a->simple.offset+dist_a->simple.length - 1;
                for (Int _a = min_a; _a <= max_a; _a++) {
                    Real prob_a = dist_a->simple.elements[_a-dist_a->simple.offset];
                    if (prob_a <= 0)
                        continue;
                    samplingStack.branch(3, prob_a);
                    Int _zprime = _z-_d+_phi+_a;
                    if ((_zprime<_leftTail)||(_zprime>_rightTail)) {
                        ;
                        continue;
                    }
                    if (_zprime==0||lookup(self->_numberOfServers,_nodeIndex)==0) {
                        Pmf *dist_ellprime = lookup(self->_serviceDurationPmfs,_nodeIndex);
                        Int min_ellprime = dist_ellprime->simple.offset;
                        Int max_ellprime = dist_ellprime->simple.offset+dist_ellprime->simple.length - 1;
                        for (Int _ellprime = min_ellprime; _ellprime <= max_ellprime; _ellprime++) {
                            Real prob_ellprime = dist_ellprime->simple.elements[_ellprime-dist_ellprime->simple.offset];
                            if (prob_ellprime <= 0)
                                continue;
                            samplingStack.branch(4, prob_ellprime);
                            Int sample1 = _zprime;
                            Int sample2 = _ellprime;
                            Real prob = samplingStack.branchProbability(4);
                            accumulator.putDouble(prob,sample1,sample2);
                            continue;
                        }
                        continue;
                    }
                    Pmf *dist_entityIsOld = bernoulli((QObject *) self,(std::min(_z,lookup(self->_numberOfServers,_nodeIndex))-_d)/checkDenominator(std::min(_zprime,lookup(self->_numberOfServers,_nodeIndex))));
                    Int min_entityIsOld = dist_entityIsOld->simple.offset;
                    Int max_entityIsOld = dist_entityIsOld->simple.offset+dist_entityIsOld->simple.length - 1;
                    for (Int _entityIsOld = min_entityIsOld; _entityIsOld <= max_entityIsOld; _entityIsOld++) {
                        Real prob_entityIsOld = dist_entityIsOld->simple.elements[_entityIsOld-dist_entityIsOld->simple.offset];
                        if (prob_entityIsOld <= 0)
                            continue;
                        samplingStack.branch(4, prob_entityIsOld);
                        if (_entityIsOld==1) {
                            Pmf *dist_ellprime = _StandardNetworkMultiserver_relabel(self,_nodeIndex,_z);
                            Int min_ellprime = dist_ellprime->simple.offset;
                            Int max_ellprime = dist_ellprime->simple.offset+dist_ellprime->simple.length - 1;
                            for (Int _ellprime = min_ellprime; _ellprime <= max_ellprime; _ellprime++) {
                                Real prob_ellprime = dist_ellprime->simple.elements[_ellprime-dist_ellprime->simple.offset];
                                if (prob_ellprime <= 0)
                                    continue;
                                samplingStack.branch(5, prob_ellprime);
                                Int sample1 = _zprime;
                                Int sample2 = _ellprime;
                                Real prob = samplingStack.branchProbability(5);
                                accumulator.putDouble(prob,sample1,sample2);
                                continue;
                            }
                            continue;
                        } else {
                            Pmf *dist_ellprime = lookup(self->_serviceDurationPmfs,_nodeIndex);
                            Int min_ellprime = dist_ellprime->simple.offset;
                            Int max_ellprime = dist_ellprime->simple.offset+dist_ellprime->simple.length - 1;
                            for (Int _ellprime = min_ellprime; _ellprime <= max_ellprime; _ellprime++) {
                                Real prob_ellprime = dist_ellprime->simple.elements[_ellprime-dist_ellprime->simple.offset];
                                if (prob_ellprime <= 0)
                                    continue;
                                samplingStack.branch(5, prob_ellprime);
                                Int sample1 = _zprime;
                                Int sample2 = _ellprime;
                                Real prob = samplingStack.branchProbability(5);
                                accumulator.putDouble(prob,sample1,sample2);
                                continue;
                            }
                            continue;
                        }
                    }
                }
            }
        }
    }
    Pmf *retPmf = accumulator.toPmf();
    return retPmf;
}

Pmf * _StandardNetworkMultiserver_observationMapRangeAtNode(_StandardNetworkMultiserver_object * self, Int _nodeIndex, Int _z0, Int _z1) {
    SamplingStack samplingStack(2);
    JointAccumulator accumulator((QObject *) self, 2);
    Pmf *dist_z = lookup(self->_internalState,_nodeIndex);
    Int min_z = dist_z->joint.marginal->simple.offset;
    Int max_z = dist_z->joint.marginal->simple.offset+dist_z->joint.marginal->simple.length - 1;
    for (Int _z = min_z; _z <= max_z; _z++) {
        Real prob_z = dist_z->joint.marginal->simple.elements[_z-dist_z->joint.marginal->simple.offset];
        if (prob_z <= 0)
            continue;
        samplingStack.set(0, prob_z);
        Pmf *dist_ell = lookupConditionalPmf(dist_z, 1, _z);
        Int min_ell = dist_ell->simple.offset;
        Int max_ell = dist_ell->simple.offset+dist_ell->simple.length - 1;
        for (Int _ell = min_ell; _ell <= max_ell; _ell++) {
            Real prob_ell = dist_ell->simple.elements[_ell-dist_ell->simple.offset];
            if (prob_ell <= 0)
                continue;
            samplingStack.branch(1, prob_ell);
            if (_z<_z0||_z>=_z1) {
                ;
                continue;
            }
            Int sample1 = _z;
            Int sample2 = _ell;
            Real prob = samplingStack.branchProbability(1);
            accumulator.putDouble(prob,sample1,sample2);
            continue;
        }
    }
    Pmf *retPmf = accumulator.toPmf();
    return retPmf;
}

Pmf * _StandardNetworkMultiserver_resetMapAtNode(_StandardNetworkMultiserver_object * self, Int _nodeIndex, Int _z0) {
    SamplingStack samplingStack(1);
    JointAccumulator accumulator((QObject *) self, 2);
    Pmf *dist_ell = lookup(self->_serviceDurationPmfs,_nodeIndex);
    Int min_ell = dist_ell->simple.offset;
    Int max_ell = dist_ell->simple.offset+dist_ell->simple.length - 1;
    for (Int _ell = min_ell; _ell <= max_ell; _ell++) {
        Real prob_ell = dist_ell->simple.elements[_ell-dist_ell->simple.offset];
        if (prob_ell <= 0)
            continue;
        samplingStack.set(0, prob_ell);
        Int sample1 = _z0;
        Int sample2 = _ell;
        Real prob = samplingStack.branchProbability(0);
        accumulator.putDouble(prob,sample1,sample2);
        continue;
    }
    Pmf *retPmf = accumulator.toPmf();
    return retPmf;
}

void _StandardNetworkMultiserver_step(_StandardNetworkMultiserver_object * self) {
    Real _tolerance = 1e-8;
    Int _numberOfNodes = self->_numberOfServers->length;
    PmfArray * _flowIn = createPmfArray((QObject *)self, createSimplePmfConfig((QObject *)self),_numberOfNodes);
    Int min110 = 0;
    Int max110 = _numberOfNodes-1;
    for (Int _sourceNodeIndex=min110; _sourceNodeIndex<=max110; _sourceNodeIndex++) {
        Real _sourceSum = 0.0;
        Int min112 = 0;
        Int max112 = _numberOfNodes-1;
        for (Int _destinationNodeIndex=min112; _destinationNodeIndex<=max112; _destinationNodeIndex++) {
            _sourceSum = _sourceSum+lookup(lookup(self->_routingProbabilities,_sourceNodeIndex),_destinationNodeIndex);
        }
        if (_sourceSum>1.0) {
            throw CException("Invalid routing probabilities. Sum of destination probabilities exceeds 1.");
        }
    }
    Int min120 = 0;
    Int max120 = _numberOfNodes-1;
    for (Int _sourceNodeIndex=min120; _sourceNodeIndex<=max120; _sourceNodeIndex++) {
        Int min121 = 0;
        Int max121 = _sourceNodeIndex-1;
        for (Int _destinationNodeIndex=min121; _destinationNodeIndex<=max121; _destinationNodeIndex++) {
            int index122 = _destinationNodeIndex;
            lookup(_flowIn,index122) = _StandardNetworkMultiserver_convolution(self,lookup(_flowIn,_destinationNodeIndex),_StandardNetworkMultiserver_flow(self,_sourceNodeIndex,_destinationNodeIndex));
        }
        Int min124 = _sourceNodeIndex+1;
        Int max124 = _numberOfNodes-1;
        for (Int _destinationNodeIndex=min124; _destinationNodeIndex<=max124; _destinationNodeIndex++) {
            int index125 = _destinationNodeIndex;
            lookup(_flowIn,index125) = _StandardNetworkMultiserver_convolution(self,lookup(_flowIn,_destinationNodeIndex),_StandardNetworkMultiserver_flow(self,_sourceNodeIndex,_destinationNodeIndex));
        }
    }
    Int min128 = 0;
    Int max128 = _numberOfNodes-1;
    for (Int _nodeIndex=min128; _nodeIndex<=max128; _nodeIndex++) {
        Pmf * _p = _StandardNetworkMultiserver_partialQplexMapAtNode(self,_nodeIndex,lookup(_flowIn,_nodeIndex));
        Int _leftTail = computeLeftTail(_p,_tolerance/checkDenominator(2));
        Int _rightTail = computeRightTail(_p,_tolerance/checkDenominator(2));
        int index132 = _nodeIndex;
        lookup(self->_internalState,index132) = _StandardNetworkMultiserver_qplexMapAtNode(self,_nodeIndex,lookup(_flowIn,_nodeIndex),_leftTail,_rightTail);
    }
    self->_time = self->_time+1;
}

PyObject *_StandardNetworkMultiserver_step_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 0)
            throw CException("Expected 0 parameters");
        
        _StandardNetworkMultiserver_step(self);
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardNetworkMultiserver_applyObservationRangeAtNode(_StandardNetworkMultiserver_object * self, Int _nodeIndex, Int _startOfRange, Int _endOfRange) {
    int index138 = _nodeIndex;
    lookup(self->_internalState,index138) = _StandardNetworkMultiserver_observationMapRangeAtNode(self,_nodeIndex,_startOfRange,_endOfRange);
}

PyObject *_StandardNetworkMultiserver_applyObservationRangeAtNode_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 3)
            throw CException("Expected 3 parameters");
        
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        
        Int arg1 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 1));
        
        Int arg2 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 2));
        
        _StandardNetworkMultiserver_applyObservationRangeAtNode(self, arg0, arg1, arg2);
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardNetworkMultiserver_applyObservationValueAtNode(_StandardNetworkMultiserver_object * self, Int _nodeIndex, Int _observedNumberOfEntitiesInSystem) {
    int index142 = _nodeIndex;
    lookup(self->_internalState,index142) = _StandardNetworkMultiserver_observationMapRangeAtNode(self,_nodeIndex,_observedNumberOfEntitiesInSystem,_observedNumberOfEntitiesInSystem+1);
}

PyObject *_StandardNetworkMultiserver_applyObservationValueAtNode_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 2)
            throw CException("Expected 2 parameters");
        
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        
        Int arg1 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 1));
        
        _StandardNetworkMultiserver_applyObservationValueAtNode(self, arg0, arg1);
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardNetworkMultiserver_mark(_StandardNetworkMultiserver_object * self) {
    self->_markTime = self->_time;
    Int min147 = 0;
    Int max147 = self->_numberOfServers->length-1;
    for (Int _nodeIndex=min147; _nodeIndex<=max147; _nodeIndex++) {
        int index148 = _nodeIndex;
        lookup(self->_markInternalState,index148) = lookup(self->_internalState,_nodeIndex);
        int index149 = _nodeIndex;
        lookup(self->_markNumberOfServers,index149) = lookup(self->_numberOfServers,_nodeIndex);
        int index150 = _nodeIndex;
        lookup(self->_markNumberOfExternalArrivalsPmfs,index150) = lookup(self->_numberOfExternalArrivalsPmfs,_nodeIndex);
        int index151 = _nodeIndex;
        lookup(self->_markServiceDurationPmfs,index151) = lookup(self->_serviceDurationPmfs,_nodeIndex);
        Int min152 = 0;
        Int max152 = self->_numberOfServers->length-1;
        for (Int _nodeIndexDest=min152; _nodeIndexDest<=max152; _nodeIndexDest++) {
            int index153A = _nodeIndex;
            int index153B = _nodeIndexDest;
            lookup(lookup(self->_markRoutingProbabilities,index153A),index153B) = lookup(lookup(self->_routingProbabilities,_nodeIndex),_nodeIndexDest);
        }
    }
}

PyObject *_StandardNetworkMultiserver_mark_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 0)
            throw CException("Expected 0 parameters");
        
        _StandardNetworkMultiserver_mark(self);
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardNetworkMultiserver_restore(_StandardNetworkMultiserver_object * self) {
    self->_time = self->_markTime;
    Int min160 = 0;
    Int max160 = self->_numberOfServers->length-1;
    for (Int _nodeIndex=min160; _nodeIndex<=max160; _nodeIndex++) {
        int index161 = _nodeIndex;
        lookup(self->_internalState,index161) = lookup(self->_markInternalState,_nodeIndex);
        int index162 = _nodeIndex;
        lookup(self->_numberOfServers,index162) = lookup(self->_markNumberOfServers,_nodeIndex);
        int index163 = _nodeIndex;
        lookup(self->_numberOfExternalArrivalsPmfs,index163) = lookup(self->_markNumberOfExternalArrivalsPmfs,_nodeIndex);
        int index164 = _nodeIndex;
        lookup(self->_serviceDurationPmfs,index164) = lookup(self->_markServiceDurationPmfs,_nodeIndex);
        Int min165 = 0;
        Int max165 = self->_numberOfServers->length-1;
        for (Int _nodeIndexDest=min165; _nodeIndexDest<=max165; _nodeIndexDest++) {
            int index166A = _nodeIndex;
            int index166B = _nodeIndexDest;
            lookup(lookup(self->_routingProbabilities,index166A),index166B) = lookup(lookup(self->_markRoutingProbabilities,_nodeIndex),_nodeIndexDest);
        }
    }
}

PyObject *_StandardNetworkMultiserver_restore_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 0)
            throw CException("Expected 0 parameters");
        
        _StandardNetworkMultiserver_restore(self);
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

Pmf * _StandardNetworkMultiserver_getNumberOfEntitiesAtNodePmf(_StandardNetworkMultiserver_object * self, Int _nodeIndex) {
    Pmf * returnValue = lookupMarginalPmf(lookup(self->_internalState,_nodeIndex));
    return returnValue;
}

PyObject *_StandardNetworkMultiserver_getNumberOfEntitiesAtNodePmf_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        self->isMemModified = false;
        if (PyTuple_Size(args) != 1)
            throw CException("Expected 1 parameter(s)");
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        PyObject *returnValue = Pmf_toPy((QObject *) self, _StandardNetworkMultiserver_getNumberOfEntitiesAtNodePmf(self, arg0));
            if (self->isMemModified)
                _StandardNetworkMultiserver_memRelease(self);
        return returnValue;
    } catch (CException x) {
    if (self->isMemModified)
        _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

Pmf * _StandardNetworkMultiserver_getNumberOfExternalArrivalsAtNodePmf(_StandardNetworkMultiserver_object * self, Int _nodeIndex) {
    Pmf * returnValue = lookup(self->_numberOfExternalArrivalsPmfs,_nodeIndex);
    return returnValue;
}

PyObject *_StandardNetworkMultiserver_getNumberOfExternalArrivalsAtNodePmf_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        self->isMemModified = false;
        if (PyTuple_Size(args) != 1)
            throw CException("Expected 1 parameter(s)");
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        PyObject *returnValue = Pmf_toPy((QObject *) self, _StandardNetworkMultiserver_getNumberOfExternalArrivalsAtNodePmf(self, arg0));
            if (self->isMemModified)
                _StandardNetworkMultiserver_memRelease(self);
        return returnValue;
    } catch (CException x) {
    if (self->isMemModified)
        _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

Int _StandardNetworkMultiserver_getNumberOfNodes(_StandardNetworkMultiserver_object * self) {
    Int returnValue = self->_numberOfServers->length;
    return returnValue;
}

PyObject *_StandardNetworkMultiserver_getNumberOfNodes_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        self->isMemModified = false;
        if (PyTuple_Size(args) != 0)
            throw CException("Expected 0 parameter(s)");
        PyObject *returnValue = Int_toPy((QObject *) self, _StandardNetworkMultiserver_getNumberOfNodes(self));
            if (self->isMemModified)
                _StandardNetworkMultiserver_memRelease(self);
        return returnValue;
    } catch (CException x) {
    if (self->isMemModified)
        _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

Int _StandardNetworkMultiserver_getNumberOfServersAtNode(_StandardNetworkMultiserver_object * self, Int _nodeIndex) {
    Int returnValue = lookup(self->_numberOfServers,_nodeIndex);
    return returnValue;
}

PyObject *_StandardNetworkMultiserver_getNumberOfServersAtNode_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        self->isMemModified = false;
        if (PyTuple_Size(args) != 1)
            throw CException("Expected 1 parameter(s)");
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        PyObject *returnValue = Int_toPy((QObject *) self, _StandardNetworkMultiserver_getNumberOfServersAtNode(self, arg0));
            if (self->isMemModified)
                _StandardNetworkMultiserver_memRelease(self);
        return returnValue;
    } catch (CException x) {
    if (self->isMemModified)
        _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

Real _StandardNetworkMultiserver_getRoutingProbability(_StandardNetworkMultiserver_object * self, Int _sourceNodeIndex, Int _destinationNodeIndex) {
    Real returnValue = lookup(lookup(self->_routingProbabilities,_sourceNodeIndex),_destinationNodeIndex);
    return returnValue;
}

PyObject *_StandardNetworkMultiserver_getRoutingProbability_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        self->isMemModified = false;
        if (PyTuple_Size(args) != 2)
            throw CException("Expected 2 parameter(s)");
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        Int arg1 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 1));
        PyObject *returnValue = Real_toPy((QObject *) self, _StandardNetworkMultiserver_getRoutingProbability(self, arg0, arg1));
            if (self->isMemModified)
                _StandardNetworkMultiserver_memRelease(self);
        return returnValue;
    } catch (CException x) {
    if (self->isMemModified)
        _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

Pmf * _StandardNetworkMultiserver_getServiceDurationAtNodePmf(_StandardNetworkMultiserver_object * self, Int _nodeIndex) {
    Pmf * returnValue = lookup(self->_serviceDurationPmfs,_nodeIndex);
    return returnValue;
}

PyObject *_StandardNetworkMultiserver_getServiceDurationAtNodePmf_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        self->isMemModified = false;
        if (PyTuple_Size(args) != 1)
            throw CException("Expected 1 parameter(s)");
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        PyObject *returnValue = Pmf_toPy((QObject *) self, _StandardNetworkMultiserver_getServiceDurationAtNodePmf(self, arg0));
            if (self->isMemModified)
                _StandardNetworkMultiserver_memRelease(self);
        return returnValue;
    } catch (CException x) {
    if (self->isMemModified)
        _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardNetworkMultiserver_setNumberOfExternalArrivalsAtNodePmf(_StandardNetworkMultiserver_object * self, Int _nodeIndex, Pmf * _numberOfExternalArrivalsPmf) {
    int index196 = _nodeIndex;
    lookup(self->_numberOfExternalArrivalsPmfs,index196) = _numberOfExternalArrivalsPmf;
}

PyObject *_StandardNetworkMultiserver_setNumberOfExternalArrivalsAtNodePmf_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 2)
            throw CException("Expected 2 parameters");
        
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        
        Pmf * arg1 = Pmf_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 1));
        
        _StandardNetworkMultiserver_setNumberOfExternalArrivalsAtNodePmf(self, arg0, confirmSimplePmf(arg1));
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardNetworkMultiserver_setNumberOfServersAtNode(_StandardNetworkMultiserver_object * self, Int _nodeIndex, Int _n) {
    if (_n<0) {
        throw CException("Invalid number of servers. The number of servers must be nonnegative.");
    }
    int index203 = _nodeIndex;
    lookup(self->_numberOfServers,index203) = _n;
}

PyObject *_StandardNetworkMultiserver_setNumberOfServersAtNode_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 2)
            throw CException("Expected 2 parameters");
        
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        
        Int arg1 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 1));
        
        _StandardNetworkMultiserver_setNumberOfServersAtNode(self, arg0, arg1);
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardNetworkMultiserver_setRoutingProbability(_StandardNetworkMultiserver_object * self, Int _sourceNodeIndex, Int _destinationNodeIndex, Real _probability) {
    if (_probability<0.0||_probability>1.0) {
        throw CException("Invalid probability. Probabilities must be between 0 and 1.");
    }
    int index210A = _sourceNodeIndex;
    int index210B = _destinationNodeIndex;
    lookup(lookup(self->_routingProbabilities,index210A),index210B) = _probability;
}

PyObject *_StandardNetworkMultiserver_setRoutingProbability_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 3)
            throw CException("Expected 3 parameters");
        
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        
        Int arg1 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 1));
        
        Real arg2 = Real_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 2));
        
        _StandardNetworkMultiserver_setRoutingProbability(self, arg0, arg1, arg2);
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardNetworkMultiserver_setServiceDurationAtNodePmf(_StandardNetworkMultiserver_object * self, Int _nodeIndex, Pmf * _serviceDurationPmf) {
    if (_serviceDurationPmf->simple.offset==0) {
        throw CException("Invalid service duration pmf. Service durations must be strictly positive.");
    }
    int index217 = _nodeIndex;
    lookup(self->_serviceDurationPmfs,index217) = _serviceDurationPmf;
}

PyObject *_StandardNetworkMultiserver_setServiceDurationAtNodePmf_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 2)
            throw CException("Expected 2 parameters");
        
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        
        Pmf * arg1 = Pmf_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 1));
        
        _StandardNetworkMultiserver_setServiceDurationAtNodePmf(self, arg0, confirmSimplePmf(arg1));
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void _StandardNetworkMultiserver_resetNodeWithNumberOfEntities(_StandardNetworkMultiserver_object * self, Int _nodeIndex, Int _numberOfEntitiesAtNode) {
    if (_numberOfEntitiesAtNode<0) {
        throw CException("Invalid number of entities. The number of entities must be nonnegative.");
    }
    int index224 = _nodeIndex;
    lookup(self->_internalState,index224) = _StandardNetworkMultiserver_resetMapAtNode(self,_nodeIndex,_numberOfEntitiesAtNode);
}

PyObject *_StandardNetworkMultiserver_resetNodeWithNumberOfEntities_Py(PyObject *pyObj, PyObject *args) {
    _StandardNetworkMultiserver_object *self = (_StandardNetworkMultiserver_object *) pyObj;
    try {
        if (PyTuple_Size(args) != 2)
            throw CException("Expected 2 parameters");
        
        Int arg0 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 0));
        
        Int arg1 = Int_fromPy((QObject *) self, PyTuple_GET_ITEM(args, 1));
        
        _StandardNetworkMultiserver_resetNodeWithNumberOfEntities(self, arg0, arg1);
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        Py_XINCREF(Py_None);
        return Py_None;

    } catch (CException x) {
        if (self->isMemModified)
            _StandardNetworkMultiserver_memRelease(self);
        PyErr_SetString(PException, x.message);
        return NULL;
    }
}

void **_StandardNetworkMultiserver_functionPointers = NULL;
const char **_StandardNetworkMultiserver_functionNames = NULL;
int *_StandardNetworkMultiserver_functionSignatureIndexes = NULL;

PyObject *_StandardNetworkMultiserver_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
    _StandardNetworkMultiserver_object *self;
 
    self = (_StandardNetworkMultiserver_object *) type->tp_alloc(type, 0);
    if (self == NULL) 
        return NULL;

    self->isMemModified = false;
    self->memList = NULL;
    self->functionCount = _StandardNetworkMultiserver_IMPLEMENTATION_COUNT;
    self->functionPointers = _StandardNetworkMultiserver_functionPointers;
    self->functionNames = _StandardNetworkMultiserver_functionNames;
    self->functionSignatureIndexes = _StandardNetworkMultiserver_functionSignatureIndexes;
    self->currentMemoryUse = 0;
    self->peakMemoryUse = 0;

    self->_internalState = defaultPmfArray((QObject *)self, createJointPmfConfig((QObject *)self, 2));
    self->_time = 0;
    self->_numberOfServers = defaultIntArray((QObject *)self);
    self->_numberOfExternalArrivalsPmfs = defaultPmfArray((QObject *)self, createSimplePmfConfig((QObject *)self));
    self->_serviceDurationPmfs = defaultPmfArray((QObject *)self, createSimplePmfConfig((QObject *)self));
    self->_routingProbabilities = defaultRealMatrix((QObject *)self);
    self->_markInternalState = defaultPmfArray((QObject *)self, createJointPmfConfig((QObject *)self, 2));
    self->_markTime = 0;
    self->_markNumberOfServers = defaultIntArray((QObject *)self);
    self->_markNumberOfExternalArrivalsPmfs = defaultPmfArray((QObject *)self, createSimplePmfConfig((QObject *)self));
    self->_markServiceDurationPmfs = defaultPmfArray((QObject *)self, createSimplePmfConfig((QObject *)self));
    self->_markRoutingProbabilities = defaultRealMatrix((QObject *)self);
    

    if (_StandardNetworkMultiserver_init_Py((PyObject *) self, args) == Py_None)
        return (PyObject *) self;
    else
        return NULL;
}
PyMethodDef _StandardNetworkMultiserver_methods[] = {
    { "step", _StandardNetworkMultiserver_step_Py, METH_VARARGS, NULL },
    { "apply_observation_range_at_node", _StandardNetworkMultiserver_applyObservationRangeAtNode_Py, METH_VARARGS, NULL },
    { "apply_observation_value_at_node", _StandardNetworkMultiserver_applyObservationValueAtNode_Py, METH_VARARGS, NULL },
    { "mark", _StandardNetworkMultiserver_mark_Py, METH_VARARGS, NULL },
    { "restore", _StandardNetworkMultiserver_restore_Py, METH_VARARGS, NULL },
    { "get_number_of_entities_at_node_pmf", _StandardNetworkMultiserver_getNumberOfEntitiesAtNodePmf_Py, METH_VARARGS, NULL },
    { "get_number_of_external_arrivals_at_node_pmf", _StandardNetworkMultiserver_getNumberOfExternalArrivalsAtNodePmf_Py, METH_VARARGS, NULL },
    { "get_number_of_nodes", _StandardNetworkMultiserver_getNumberOfNodes_Py, METH_VARARGS, NULL },
    { "get_number_of_servers_at_node", _StandardNetworkMultiserver_getNumberOfServersAtNode_Py, METH_VARARGS, NULL },
    { "get_routing_probability", _StandardNetworkMultiserver_getRoutingProbability_Py, METH_VARARGS, NULL },
    { "get_service_duration_at_node_pmf", _StandardNetworkMultiserver_getServiceDurationAtNodePmf_Py, METH_VARARGS, NULL },
    { "set_number_of_external_arrivals_at_node_pmf", _StandardNetworkMultiserver_setNumberOfExternalArrivalsAtNodePmf_Py, METH_VARARGS, NULL },
    { "set_number_of_servers_at_node", _StandardNetworkMultiserver_setNumberOfServersAtNode_Py, METH_VARARGS, NULL },
    { "set_routing_probability", _StandardNetworkMultiserver_setRoutingProbability_Py, METH_VARARGS, NULL },
    { "set_service_duration_at_node_pmf", _StandardNetworkMultiserver_setServiceDurationAtNodePmf_Py, METH_VARARGS, NULL },
    { "reset_node_with_number_of_entities", _StandardNetworkMultiserver_resetNodeWithNumberOfEntities_Py, METH_VARARGS, NULL },
    { NULL }
};

PyMemberDef _StandardNetworkMultiserver_members[] = {
    { "time", T_INT, offsetof(_StandardNetworkMultiserver_object, _time), 0, NULL },
    { "current_memory_use", T_ULONGLONG, offsetof(_StandardNetworkMultiserver_object, currentMemoryUse), READONLY, NULL },
    { "peak_memory_use", T_ULONGLONG, offsetof(_StandardNetworkMultiserver_object, peakMemoryUse), READONLY, NULL },
    { NULL }
};

PyGetSetDef _StandardNetworkMultiserver_getset[] = {
    { "internal_state", (getter)_StandardNetworkMultiserver_get_internalState, (setter)_StandardNetworkMultiserver_set_internalState, NULL, NULL },
    { NULL }
};

static PyTypeObject _StandardNetworkMultiserver_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "qplex.StandardNetworkMultiserver",                      // tp_name 
    sizeof(_StandardNetworkMultiserver_object),                // tp_basicsize 
    0,                                      // tp_itemsize 
    (destructor) dealloc,                   // tp_dealloc 
    0,                                      // tp_vectorcall_offset 
    0,                                      // tp_getattr 
    0,                                      // tp_setattr 
    0,                                      // tp_as_async 
    0,                                      // tp_repr 
    0,                                      // tp_as_number 
    0,                                      // tp_as_sequence 
    0,                                      // tp_as_mapping 
    0,                                      // tp_hash 
    0,                                      // tp_call 
    0,                                      // tp_str 
    0,                                      // tp_getattro 
    0,                                      // tp_setattro 
    0,                                      // tp_as_buffer 
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   // tp_flags 
    0,                                      // tp_doc 
    0,                                      // tp_traverse 
    0,                                      // tp_clear 
    0,                                      // tp_richcompare 
    0,                                      // tp_weaklistoffset 
    0,                                      // tp_iter 
    0,                                      // tp_iternext 
    _StandardNetworkMultiserver_methods,                       // tp_methods 
    _StandardNetworkMultiserver_members,                       // tp_members 
    _StandardNetworkMultiserver_getset,                        // tp_getset 
    0,                                      // tp_base 
    0,                                      // tp_dict 
    0,                                      // tp_descr_get 
    0,                                      // tp_descr_set 
    0,                                      // tp_dictoffset 
    0,                                      // tp_init 
    0,                                      // tp_alloc 
    _StandardNetworkMultiserver_new,                           // tp_new 
};
// MODULE

static struct PyModuleDef moduleDef = {
    PyModuleDef_HEAD_INIT,
    "qplex",  // m_name
    NULL,   // m_doc  
    -1,     // m_size
    NULL    // m_methods
};

PyMODINIT_FUNC PyInit_qplex(void) {
    PyObject *m;
    
    if (PyType_Ready(&_StandardMultiserver_Type) < 0)
        return NULL;
    
    if (PyType_Ready(&_StandardNetworkMultiserver_Type) < 0)
        return NULL;
    
    m = PyModule_Create(&moduleDef);
    if (m == NULL)
        return NULL;
    
    Py_INCREF(&_StandardMultiserver_Type);
    if (PyModule_AddObject(m, "StandardMultiserver", (PyObject *) &_StandardMultiserver_Type) < 0) {
        Py_DECREF(&_StandardMultiserver_Type);
        Py_DECREF(m);
        return NULL;
    }
    
    Py_INCREF(&_StandardNetworkMultiserver_Type);
    if (PyModule_AddObject(m, "StandardNetworkMultiserver", (PyObject *) &_StandardNetworkMultiserver_Type) < 0) {
        Py_DECREF(&_StandardNetworkMultiserver_Type);
        Py_DECREF(m);
        return NULL;
    }
    
    PException = PyErr_NewException("qplex.error", NULL, NULL);
    Py_XINCREF(PException);
    if (PyModule_AddObject(m, "error", PException) < 0) {
        Py_XDECREF(PException);
        Py_CLEAR(PException);
        Py_DECREF(m);
        return NULL;
    }

    return m;
}
