# coding: utf-8

"""
    CryptoAPIs

    Crypto APIs is a complex and innovative infrastructure layer that radically simplifies the development of any Blockchain and Crypto related applications. Organized around REST, Crypto APIs can assist both novice Bitcoin/Ethereum enthusiasts and crypto experts with the development of their blockchain applications. Crypto APIs provides unified endpoints and data, raw data, automatic tokens and coins forwardings, callback functionalities, and much more.

    The version of the OpenAPI document: 2023-04-25
    Contact: developers@cryptoapis.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from com.cryptoapis.rest_apis.sdk.models.add_tokens_to_existing_from_address_r import AddTokensToExistingFromAddressR
from com.cryptoapis.rest_apis.sdk.models.add_tokens_to_existing_from_address_rb import AddTokensToExistingFromAddressRB
from com.cryptoapis.rest_apis.sdk.models.create_automatic_tokens_forwarding_r import CreateAutomaticTokensForwardingR
from com.cryptoapis.rest_apis.sdk.models.create_automatic_tokens_forwarding_rb import CreateAutomaticTokensForwardingRB
from com.cryptoapis.rest_apis.sdk.models.delete_automatic_tokens_forwarding_r import DeleteAutomaticTokensForwardingR
from com.cryptoapis.rest_apis.sdk.models.get_fee_address_details_r import GetFeeAddressDetailsR
from com.cryptoapis.rest_apis.sdk.models.list_tokens_forwarding_automations_r import ListTokensForwardingAutomationsR

from com.cryptoapis.rest_apis.sdk.api_client import ApiClient, RequestSerialized
from com.cryptoapis.rest_apis.sdk.api_response import ApiResponse
from com.cryptoapis.rest_apis.sdk.rest import RESTResponseType


class AutomaticTokensForwardingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_tokens_to_existing_from_address(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        add_tokens_to_existing_from_address_rb: Optional[AddTokensToExistingFromAddressRB] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AddTokensToExistingFromAddressR:
        """Add Tokens To Existing fromAddress

        Through this endpoint customers can add **Automatic Tokens forwardings** to an already existing `fromAddress`. Unlike the \"Create Automatic Tokens Forwarding\" endpoint, where the `fromAddress` is generated each time, with this endpoint customers can add an automation from another token to one and the same `fromAddress`.    The `fromAddress` can be used as a deposit address. Any funds received by this address will be automatically forwarded to `toAddress` based on what the customer has set for the automation. The  `toAddress` is essentially the main address and destination for the automatic tokens forwarding.    There is also a `minimumTransferAmount` which only when reached will then trigger the forwarding. Through this the customer can save from fees.    Moreover, `feePriority` can be also set,  which defines how quickly to move the tokens once they are received. The higher priority, the larger the fee will be. It can be \"SLOW\", \"STANDARD\" or \"FAST\".    For this automatic forwarding the customer can set a callback subscription.    {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}    {warning}The subscription will work for all incoming transactions until it is deleted. There is no need to do that for every transaction.{/warning}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param add_tokens_to_existing_from_address_rb:
        :type add_tokens_to_existing_from_address_rb: AddTokensToExistingFromAddressRB
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_tokens_to_existing_from_address_serialize(
            blockchain=blockchain,
            network=network,
            context=context,
            add_tokens_to_existing_from_address_rb=add_tokens_to_existing_from_address_rb,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "AddTokensToExistingFromAddressR",
            '400': "AddTokensToExistingFromAddress400Response",
            '401': "AddTokensToExistingFromAddress401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "AddTokensToExistingFromAddress403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_tokens_to_existing_from_address_with_http_info(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        add_tokens_to_existing_from_address_rb: Optional[AddTokensToExistingFromAddressRB] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AddTokensToExistingFromAddressR]:
        """Add Tokens To Existing fromAddress

        Through this endpoint customers can add **Automatic Tokens forwardings** to an already existing `fromAddress`. Unlike the \"Create Automatic Tokens Forwarding\" endpoint, where the `fromAddress` is generated each time, with this endpoint customers can add an automation from another token to one and the same `fromAddress`.    The `fromAddress` can be used as a deposit address. Any funds received by this address will be automatically forwarded to `toAddress` based on what the customer has set for the automation. The  `toAddress` is essentially the main address and destination for the automatic tokens forwarding.    There is also a `minimumTransferAmount` which only when reached will then trigger the forwarding. Through this the customer can save from fees.    Moreover, `feePriority` can be also set,  which defines how quickly to move the tokens once they are received. The higher priority, the larger the fee will be. It can be \"SLOW\", \"STANDARD\" or \"FAST\".    For this automatic forwarding the customer can set a callback subscription.    {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}    {warning}The subscription will work for all incoming transactions until it is deleted. There is no need to do that for every transaction.{/warning}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param add_tokens_to_existing_from_address_rb:
        :type add_tokens_to_existing_from_address_rb: AddTokensToExistingFromAddressRB
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_tokens_to_existing_from_address_serialize(
            blockchain=blockchain,
            network=network,
            context=context,
            add_tokens_to_existing_from_address_rb=add_tokens_to_existing_from_address_rb,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "AddTokensToExistingFromAddressR",
            '400': "AddTokensToExistingFromAddress400Response",
            '401': "AddTokensToExistingFromAddress401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "AddTokensToExistingFromAddress403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_tokens_to_existing_from_address_without_preload_content(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        add_tokens_to_existing_from_address_rb: Optional[AddTokensToExistingFromAddressRB] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add Tokens To Existing fromAddress

        Through this endpoint customers can add **Automatic Tokens forwardings** to an already existing `fromAddress`. Unlike the \"Create Automatic Tokens Forwarding\" endpoint, where the `fromAddress` is generated each time, with this endpoint customers can add an automation from another token to one and the same `fromAddress`.    The `fromAddress` can be used as a deposit address. Any funds received by this address will be automatically forwarded to `toAddress` based on what the customer has set for the automation. The  `toAddress` is essentially the main address and destination for the automatic tokens forwarding.    There is also a `minimumTransferAmount` which only when reached will then trigger the forwarding. Through this the customer can save from fees.    Moreover, `feePriority` can be also set,  which defines how quickly to move the tokens once they are received. The higher priority, the larger the fee will be. It can be \"SLOW\", \"STANDARD\" or \"FAST\".    For this automatic forwarding the customer can set a callback subscription.    {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}    {warning}The subscription will work for all incoming transactions until it is deleted. There is no need to do that for every transaction.{/warning}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param add_tokens_to_existing_from_address_rb:
        :type add_tokens_to_existing_from_address_rb: AddTokensToExistingFromAddressRB
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_tokens_to_existing_from_address_serialize(
            blockchain=blockchain,
            network=network,
            context=context,
            add_tokens_to_existing_from_address_rb=add_tokens_to_existing_from_address_rb,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "AddTokensToExistingFromAddressR",
            '400': "AddTokensToExistingFromAddress400Response",
            '401': "AddTokensToExistingFromAddress401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "AddTokensToExistingFromAddress403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_tokens_to_existing_from_address_serialize(
        self,
        blockchain,
        network,
        context,
        add_tokens_to_existing_from_address_rb,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if blockchain is not None:
            _path_params['blockchain'] = blockchain
        if network is not None:
            _path_params['network'] = network
        # process the query parameters
        if context is not None:
            
            _query_params.append(('context', context))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if add_tokens_to_existing_from_address_rb is not None:
            _body_params = add_tokens_to_existing_from_address_rb


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/blockchain-automations/{blockchain}/{network}/tokens-forwarding/automations/add-token',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_automatic_tokens_forwarding(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        create_automatic_tokens_forwarding_rb: Optional[CreateAutomaticTokensForwardingRB] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateAutomaticTokensForwardingR:
        """Create Automatic Tokens Forwarding

        Through this endpoint customers can set up an automatic forwarding function specifically for tokens (**not** coins). They can have a `toAddress` which is essentially the main address and the destination for the automatic tokens forwarding.     There is also a `minimumTransferAmount` which only when reached will then trigger the forwarding. Through this the customer can save from fees.    Moreover, `feePriority` can be also set,  which defines how quickly to move the tokens once they are received. The higher priority, the larger the fee will be. It can be \"SLOW\", \"STANDARD\" or \"FAST\".    The response of this endpoint contains an attribute `fromAddress` which can be used as a deposit address. Any funds received by this address will be automatically forwarded to `toAddress` based on what the customer has set for the automation.    For this automatic forwarding the customer can set a callback subscription.    {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}    {warning}The subscription will work for all incoming transactions until it is deleted. There is no need to do that for every transaction.{/warning}    {note}This endpoint generates a new `fromAddress` each time.{/note}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param create_automatic_tokens_forwarding_rb:
        :type create_automatic_tokens_forwarding_rb: CreateAutomaticTokensForwardingRB
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_automatic_tokens_forwarding_serialize(
            blockchain=blockchain,
            network=network,
            context=context,
            create_automatic_tokens_forwarding_rb=create_automatic_tokens_forwarding_rb,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateAutomaticTokensForwardingR",
            '400': "CreateAutomaticTokensForwarding400Response",
            '401': "CreateAutomaticTokensForwarding401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "CreateAutomaticTokensForwarding403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_automatic_tokens_forwarding_with_http_info(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        create_automatic_tokens_forwarding_rb: Optional[CreateAutomaticTokensForwardingRB] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateAutomaticTokensForwardingR]:
        """Create Automatic Tokens Forwarding

        Through this endpoint customers can set up an automatic forwarding function specifically for tokens (**not** coins). They can have a `toAddress` which is essentially the main address and the destination for the automatic tokens forwarding.     There is also a `minimumTransferAmount` which only when reached will then trigger the forwarding. Through this the customer can save from fees.    Moreover, `feePriority` can be also set,  which defines how quickly to move the tokens once they are received. The higher priority, the larger the fee will be. It can be \"SLOW\", \"STANDARD\" or \"FAST\".    The response of this endpoint contains an attribute `fromAddress` which can be used as a deposit address. Any funds received by this address will be automatically forwarded to `toAddress` based on what the customer has set for the automation.    For this automatic forwarding the customer can set a callback subscription.    {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}    {warning}The subscription will work for all incoming transactions until it is deleted. There is no need to do that for every transaction.{/warning}    {note}This endpoint generates a new `fromAddress` each time.{/note}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param create_automatic_tokens_forwarding_rb:
        :type create_automatic_tokens_forwarding_rb: CreateAutomaticTokensForwardingRB
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_automatic_tokens_forwarding_serialize(
            blockchain=blockchain,
            network=network,
            context=context,
            create_automatic_tokens_forwarding_rb=create_automatic_tokens_forwarding_rb,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateAutomaticTokensForwardingR",
            '400': "CreateAutomaticTokensForwarding400Response",
            '401': "CreateAutomaticTokensForwarding401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "CreateAutomaticTokensForwarding403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_automatic_tokens_forwarding_without_preload_content(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        create_automatic_tokens_forwarding_rb: Optional[CreateAutomaticTokensForwardingRB] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Automatic Tokens Forwarding

        Through this endpoint customers can set up an automatic forwarding function specifically for tokens (**not** coins). They can have a `toAddress` which is essentially the main address and the destination for the automatic tokens forwarding.     There is also a `minimumTransferAmount` which only when reached will then trigger the forwarding. Through this the customer can save from fees.    Moreover, `feePriority` can be also set,  which defines how quickly to move the tokens once they are received. The higher priority, the larger the fee will be. It can be \"SLOW\", \"STANDARD\" or \"FAST\".    The response of this endpoint contains an attribute `fromAddress` which can be used as a deposit address. Any funds received by this address will be automatically forwarded to `toAddress` based on what the customer has set for the automation.    For this automatic forwarding the customer can set a callback subscription.    {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}    {warning}The subscription will work for all incoming transactions until it is deleted. There is no need to do that for every transaction.{/warning}    {note}This endpoint generates a new `fromAddress` each time.{/note}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param create_automatic_tokens_forwarding_rb:
        :type create_automatic_tokens_forwarding_rb: CreateAutomaticTokensForwardingRB
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_automatic_tokens_forwarding_serialize(
            blockchain=blockchain,
            network=network,
            context=context,
            create_automatic_tokens_forwarding_rb=create_automatic_tokens_forwarding_rb,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateAutomaticTokensForwardingR",
            '400': "CreateAutomaticTokensForwarding400Response",
            '401': "CreateAutomaticTokensForwarding401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "CreateAutomaticTokensForwarding403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_automatic_tokens_forwarding_serialize(
        self,
        blockchain,
        network,
        context,
        create_automatic_tokens_forwarding_rb,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if blockchain is not None:
            _path_params['blockchain'] = blockchain
        if network is not None:
            _path_params['network'] = network
        # process the query parameters
        if context is not None:
            
            _query_params.append(('context', context))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_automatic_tokens_forwarding_rb is not None:
            _body_params = create_automatic_tokens_forwarding_rb


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/blockchain-automations/{blockchain}/{network}/tokens-forwarding/automations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_automatic_tokens_forwarding(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        reference_id: Annotated[StrictStr, Field(description="Represents a unique ID used to reference the specific callback subscription.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DeleteAutomaticTokensForwardingR:
        """Delete Automatic Tokens Forwarding

        Through this endpoint customers can delete a forwarding function they have set for **tokens** (**not** coins).    By setting a `fromAddress` and a `toAddress`, and specifying the amount, tokens can be transferred between addresses.     A `feePriority` will be returned which represents the fee priority of the automation whether it is \"SLOW\", \"STANDARD\" OR \"FAST\".    {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}    {warning}The subscription will work for all incoming transactions until it is deleted. There is no need to do that for every transaction.{/warning}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param reference_id: Represents a unique ID used to reference the specific callback subscription. (required)
        :type reference_id: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_automatic_tokens_forwarding_serialize(
            blockchain=blockchain,
            network=network,
            reference_id=reference_id,
            context=context,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteAutomaticTokensForwardingR",
            '400': "DeleteAutomaticTokensForwarding400Response",
            '401': "DeleteAutomaticTokensForwarding401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "DeleteAutomaticTokensForwarding403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_automatic_tokens_forwarding_with_http_info(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        reference_id: Annotated[StrictStr, Field(description="Represents a unique ID used to reference the specific callback subscription.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DeleteAutomaticTokensForwardingR]:
        """Delete Automatic Tokens Forwarding

        Through this endpoint customers can delete a forwarding function they have set for **tokens** (**not** coins).    By setting a `fromAddress` and a `toAddress`, and specifying the amount, tokens can be transferred between addresses.     A `feePriority` will be returned which represents the fee priority of the automation whether it is \"SLOW\", \"STANDARD\" OR \"FAST\".    {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}    {warning}The subscription will work for all incoming transactions until it is deleted. There is no need to do that for every transaction.{/warning}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param reference_id: Represents a unique ID used to reference the specific callback subscription. (required)
        :type reference_id: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_automatic_tokens_forwarding_serialize(
            blockchain=blockchain,
            network=network,
            reference_id=reference_id,
            context=context,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteAutomaticTokensForwardingR",
            '400': "DeleteAutomaticTokensForwarding400Response",
            '401': "DeleteAutomaticTokensForwarding401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "DeleteAutomaticTokensForwarding403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_automatic_tokens_forwarding_without_preload_content(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        reference_id: Annotated[StrictStr, Field(description="Represents a unique ID used to reference the specific callback subscription.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Automatic Tokens Forwarding

        Through this endpoint customers can delete a forwarding function they have set for **tokens** (**not** coins).    By setting a `fromAddress` and a `toAddress`, and specifying the amount, tokens can be transferred between addresses.     A `feePriority` will be returned which represents the fee priority of the automation whether it is \"SLOW\", \"STANDARD\" OR \"FAST\".    {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}    {warning}The subscription will work for all incoming transactions until it is deleted. There is no need to do that for every transaction.{/warning}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param reference_id: Represents a unique ID used to reference the specific callback subscription. (required)
        :type reference_id: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_automatic_tokens_forwarding_serialize(
            blockchain=blockchain,
            network=network,
            reference_id=reference_id,
            context=context,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteAutomaticTokensForwardingR",
            '400': "DeleteAutomaticTokensForwarding400Response",
            '401': "DeleteAutomaticTokensForwarding401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "DeleteAutomaticTokensForwarding403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_automatic_tokens_forwarding_serialize(
        self,
        blockchain,
        network,
        reference_id,
        context,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if blockchain is not None:
            _path_params['blockchain'] = blockchain
        if network is not None:
            _path_params['network'] = network
        if reference_id is not None:
            _path_params['referenceId'] = reference_id
        # process the query parameters
        if context is not None:
            
            _query_params.append(('context', context))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/blockchain-automations/{blockchain}/{network}/tokens-forwarding/automations/{referenceId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fee_address_details(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFeeAddressDetailsR:
        """Get Fee Address Details

        Through this endpoint customers can obtain details about a fee address. Only one fee address per currency per network for a user's account can be set no matter how many tokens or subscriptions they have or want to automatically forward.    {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fee_address_details_serialize(
            blockchain=blockchain,
            network=network,
            context=context,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFeeAddressDetailsR",
            '400': "GetFeeAddressDetails400Response",
            '401': "GetFeeAddressDetails401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "GetFeeAddressDetails403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fee_address_details_with_http_info(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFeeAddressDetailsR]:
        """Get Fee Address Details

        Through this endpoint customers can obtain details about a fee address. Only one fee address per currency per network for a user's account can be set no matter how many tokens or subscriptions they have or want to automatically forward.    {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fee_address_details_serialize(
            blockchain=blockchain,
            network=network,
            context=context,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFeeAddressDetailsR",
            '400': "GetFeeAddressDetails400Response",
            '401': "GetFeeAddressDetails401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "GetFeeAddressDetails403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fee_address_details_without_preload_content(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Fee Address Details

        Through this endpoint customers can obtain details about a fee address. Only one fee address per currency per network for a user's account can be set no matter how many tokens or subscriptions they have or want to automatically forward.    {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fee_address_details_serialize(
            blockchain=blockchain,
            network=network,
            context=context,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFeeAddressDetailsR",
            '400': "GetFeeAddressDetails400Response",
            '401': "GetFeeAddressDetails401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "GetFeeAddressDetails403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fee_address_details_serialize(
        self,
        blockchain,
        network,
        context,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if blockchain is not None:
            _path_params['blockchain'] = blockchain
        if network is not None:
            _path_params['network'] = network
        # process the query parameters
        if context is not None:
            
            _query_params.append(('context', context))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/blockchain-automations/{blockchain}/{network}/tokens-forwarding/fee-addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_tokens_forwarding_automations(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Defines how many items should be returned in the response per page basis.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting index of the response items, i.e. where the response should start listing the returned items.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListTokensForwardingAutomationsR:
        """List Tokens Forwarding Automations

        Through this endpoint customers can list all of their **tokens** forwarding automations (**not** coins).    Customers can set up automatic forwarding functions for tokens by setting a `fromAddress` and a `toAddress`, and specifying the amount that can be transferred between addresses.     A `feePriority` will be returned which represents the fee priority of the automation whether it is \"SLOW\", \"STANDARD\" OR \"FAST\".     {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}    {warning}The subscription will work for all transactions until it is deleted. There is no need to do that for every transaction.{/warning}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param limit: Defines how many items should be returned in the response per page basis.
        :type limit: int
        :param offset: The starting index of the response items, i.e. where the response should start listing the returned items.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_tokens_forwarding_automations_serialize(
            blockchain=blockchain,
            network=network,
            context=context,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTokensForwardingAutomationsR",
            '400': "ListTokensForwardingAutomations400Response",
            '401': "ListTokensForwardingAutomations401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "ListTokensForwardingAutomations403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_tokens_forwarding_automations_with_http_info(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Defines how many items should be returned in the response per page basis.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting index of the response items, i.e. where the response should start listing the returned items.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListTokensForwardingAutomationsR]:
        """List Tokens Forwarding Automations

        Through this endpoint customers can list all of their **tokens** forwarding automations (**not** coins).    Customers can set up automatic forwarding functions for tokens by setting a `fromAddress` and a `toAddress`, and specifying the amount that can be transferred between addresses.     A `feePriority` will be returned which represents the fee priority of the automation whether it is \"SLOW\", \"STANDARD\" OR \"FAST\".     {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}    {warning}The subscription will work for all transactions until it is deleted. There is no need to do that for every transaction.{/warning}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param limit: Defines how many items should be returned in the response per page basis.
        :type limit: int
        :param offset: The starting index of the response items, i.e. where the response should start listing the returned items.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_tokens_forwarding_automations_serialize(
            blockchain=blockchain,
            network=network,
            context=context,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTokensForwardingAutomationsR",
            '400': "ListTokensForwardingAutomations400Response",
            '401': "ListTokensForwardingAutomations401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "ListTokensForwardingAutomations403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_tokens_forwarding_automations_without_preload_content(
        self,
        blockchain: Annotated[StrictStr, Field(description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")],
        network: Annotated[StrictStr, Field(description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")],
        context: Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Defines how many items should be returned in the response per page basis.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting index of the response items, i.e. where the response should start listing the returned items.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Tokens Forwarding Automations

        Through this endpoint customers can list all of their **tokens** forwarding automations (**not** coins).    Customers can set up automatic forwarding functions for tokens by setting a `fromAddress` and a `toAddress`, and specifying the amount that can be transferred between addresses.     A `feePriority` will be returned which represents the fee priority of the automation whether it is \"SLOW\", \"STANDARD\" OR \"FAST\".     {warning}Currently we support fungible tokens (ERC-20) **only**, NFTs (ERC-721) are **not** supported.{/warning}    {warning}The subscription will work for all transactions until it is deleted. There is no need to do that for every transaction.{/warning}

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param limit: Defines how many items should be returned in the response per page basis.
        :type limit: int
        :param offset: The starting index of the response items, i.e. where the response should start listing the returned items.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_tokens_forwarding_automations_serialize(
            blockchain=blockchain,
            network=network,
            context=context,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTokensForwardingAutomationsR",
            '400': "ListTokensForwardingAutomations400Response",
            '401': "ListTokensForwardingAutomations401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "ListTokensForwardingAutomations403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_tokens_forwarding_automations_serialize(
        self,
        blockchain,
        network,
        context,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if blockchain is not None:
            _path_params['blockchain'] = blockchain
        if network is not None:
            _path_params['network'] = network
        # process the query parameters
        if context is not None:
            
            _query_params.append(('context', context))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/blockchain-automations/{blockchain}/{network}/tokens-forwarding/automations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


