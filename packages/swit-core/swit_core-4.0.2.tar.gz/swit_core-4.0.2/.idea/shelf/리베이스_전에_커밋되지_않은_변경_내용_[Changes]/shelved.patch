Index: switcore/action/schemas.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import base64\nimport bz2\nimport json\nfrom datetime import datetime, date\nfrom enum import Enum\nfrom typing import Any, Type, Union, Literal\nfrom typing import List\n\nfrom pydantic import validator, root_validator, model_validator, field_validator, Field\n\nfrom switcore.pydantic_base_model import SwitBaseModel\nfrom switcore.ui.button import Button\nfrom switcore.ui.collection_entry import CollectionEntry\nfrom switcore.ui.container import Container\nfrom switcore.ui.datepicker import DatePicker\nfrom switcore.ui.divider import Divider\nfrom switcore.ui.file import File\nfrom switcore.ui.header import Header, AttachmentHeader\nfrom switcore.ui.html_frame import HtmlFrame\nfrom switcore.ui.image import Image\nfrom switcore.ui.image_grid import ImageGrid\nfrom switcore.ui.info_card import InfoCard\nfrom switcore.ui.input import Input\nfrom switcore.ui.interactive_image import InteractiveImage\nfrom switcore.ui.select import Select, Option, OptionGroup, NoOptionsReason\nfrom switcore.ui.signIn_page import SignInPage\nfrom switcore.ui.tabs import Tabs\nfrom switcore.ui.text_paragraph import TextParagraph\nfrom switcore.ui.textarea import Textarea\n\n\nclass UserInfo(SwitBaseModel):\n    user_id: str\n    organization_id: str\n\n\nclass UserPreferences(SwitBaseModel):\n    language: str\n    time_zone_offset: str\n    color_theme: str\n\n\nclass Settings(SwitBaseModel):\n    presence_sync: bool\n\n\nclass MessageResource(SwitBaseModel):\n    resource_type: Literal['message'] = 'message'\n    id: str\n    created_at: datetime\n    edited_at: datetime | None = None\n    content: str\n    content_formatted: dict | None = None\n    attachments: list[dict] | None = None\n    files: list[dict] | None = None\n    creator: dict\n\n    @field_validator('edited_at', mode='before')  # noqa\n    @classmethod\n    def parse_empty_string_to_none(cls, v):\n        if v == '':\n            return None\n        return v\n\n\nclass MessageCommentResource(MessageResource):\n    resource_type: Literal['message_comment'] = 'message_comment'\n\n\nclass TaskPriorityLevel(str, Enum):\n    HIGHEST = 'highest'\n    HIGH = 'high'\n    NORMAL = 'normal'\n    LOW = 'low'\n    LOWEST = 'lowest'\n\n\nclass TaskColorLabel(str, Enum):\n    RED = 'red'\n    PINK = 'pink'\n    ORANGE = 'orange'\n    YELLOW = 'yellow'\n    LIGHT_GREEN = 'light_green'\n    GREEN = 'green'\n    CYAN = 'cyan'\n    BLUE = 'blue'\n    NAVY = 'navy'\n    VIOLET = 'violet'\n    GRAY = 'gray'\n\n\nclass TaskStatusType(str, Enum):\n    NOT_STARTED = 'not_started'\n    IN_PROGRESS = 'in_progress'\n    DONE = 'done'\n\n\nclass TaskPeriod(SwitBaseModel):\n    start_time: datetime | date | None = None\n    due_time: datetime | date | None = None\n    include_time: bool\n\n    @model_validator(mode='before')\n    def parse_empty_strings(cls, values: dict[str, Any]):\n        for field, value in values.items():\n            if isinstance(value, str) and value == \"\":\n                values[field] = None\n        return values\n\n\nclass TaskUser(SwitBaseModel):\n    id: str\n\n\nclass TaskStatus(SwitBaseModel):\n    id: str\n    name: str\n    type: TaskStatusType\n\n\nclass TaskBucket(SwitBaseModel):\n    id: str\n\n\nclass TaskResource(SwitBaseModel):\n    resource_type: Literal['task'] = 'task'\n    id: str\n    parent_task_id: str | None = None\n    created_at: datetime\n    edited_at: datetime | None = None\n    title: str\n    period: TaskPeriod\n    priority: TaskPriorityLevel\n    color_label: TaskColorLabel | None = None\n    assignees: List[TaskUser]\n    collaborators: List[TaskUser]\n    status: TaskStatus\n    bucket: TaskBucket\n\n    @model_validator(mode='before')\n    def parse_empty_strings(cls, values: dict[str, Any]):\n        for field, value in values.items():\n            if isinstance(value, str) and value == \"\":\n                values[field] = None\n        return values\n\n\nclass SettingsResource(SwitBaseModel):\n    resource_type: Literal['settings.presence_sync'] = 'settings.presence_sync'\n    settings: Settings\n\n\nclass QueryResource(SwitBaseModel):\n    resource_type: Literal['query'] = 'query'\n    value: str\n\n\nclass UserActionType(str, Enum):\n    right_panel_open = \"right_panel_open\"\n    presence_sync = \"presence_sync\"\n    user_commands_chat = \"user_commands.extensions:chat\"\n    user_commands_chat_extension = \"user_commands.chat_extension\"\n    user_commands_chat_commenting = \"user_commands.extensions:chat_commenting\"\n    user_commands_context_menus_message = \"user_commands.context_menus:message\"\n    user_commands_context_menus_message_comment = \"user_commands.context_menus:message_comment\"\n    view_actions_drop = \"view_actions.drop\"\n    view_actions_input = \"view_actions.input\"\n    view_actions_query = \"view_actions.query\"\n    view_actions_submit = \"view_actions.submit\"\n    view_actions_oauth_complete = \"view_actions.oauth_complete\"\n    user_commands_context_menus_task = \"user_commands.context_menus:task\"  # this action has a dict resource\n    user_commands_task_extension = \"user_commands.extensions:task\"\n\n\nclass UserAction(SwitBaseModel):\n    type: UserActionType\n    id: str\n    slash_command: str\n    resource: MessageResource | MessageCommentResource | SettingsResource | QueryResource | TaskResource | None = Field(\n        default=None, discriminator='resource_type')\n    value: str | None = None\n\n\nclass Context(SwitBaseModel):\n    workspace_id: str | None = None\n    channel_id: str | None = None\n    project_id: str | None = None\n    task_id: str | None = None\n\n\nElementType = (CollectionEntry | Button | Divider | File | HtmlFrame | Input | Select\n               | SignInPage | TextParagraph | Image | Textarea | Container | Tabs | DatePicker | InfoCard\n               | ImageGrid | InteractiveImage)\n\nElementTypeTuple = (CollectionEntry, Button, Divider, File, HtmlFrame, Input, Select,\n                    SignInPage, TextParagraph, Image, Textarea, Container, Tabs, DatePicker, InfoCard,\n                    ImageGrid, InteractiveImage)\n\nAttachmentElementType = (CollectionEntry | InfoCard | Image | Divider | File | TextParagraph)\n\n\ndef contain_only_dict(elements_data: list[Union[dict, ElementType]]) -> bool:\n    \"\"\"\n        if Body is initialized from swit_request, elements_data is list of dict\n    \"\"\"\n    for element_data in elements_data:\n        if isinstance(element_data, ElementTypeTuple):\n            return False\n\n    return True\n\n\ndef get_element_type(element_data: dict) -> Type[ElementType]:\n    element_type_str = element_data.get('type')\n    if element_type_str == 'collection_entry':\n        return CollectionEntry\n    elif element_type_str == 'button':\n        return Button\n    elif element_type_str == 'divider':\n        return Divider\n    elif element_type_str == 'file':\n        return File\n    elif element_type_str == 'html_frame':\n        return HtmlFrame\n    elif element_type_str == 'text_input':\n        return Input\n    elif element_type_str == 'select':\n        return Select\n    elif element_type_str == 'sign_in_page':\n        return SignInPage\n    elif element_type_str == 'text':\n        return TextParagraph\n    elif element_type_str == 'textarea':\n        return Textarea\n    elif element_type_str == 'image':\n        return Image\n    elif element_type_str == 'container':\n        return Container\n    elif element_type_str == 'tabs':\n        return Tabs\n    elif element_type_str == 'datepicker':\n        return DatePicker\n    elif element_type_str == 'info_card':\n        return InfoCard\n    elif element_type_str == 'image_grid':\n        return ImageGrid\n    elif element_type_str == 'interactive_image':\n        return InteractiveImage\n    else:\n        raise ValueError(f\"Unknown element type: {element_type_str}\")\n\n\n# class ElementMixin:\n#     def __init__(self, **data: Any) -> None:\n#         elements_data: list[dict | ElementType] = data.get('elements', [])\n#\n#         if contain_only_dict(elements_data):\n#             _elements: List[ElementType] = []\n#             for element_data in elements_data:\n#                 assert isinstance(element_data, dict), \"element_data must be dict\"\n#                 element_type = get_element_type(element_data)\n#                 element: ElementType = element_type(**element_data)\n#                 _elements.append(element)\n#             data['elements'] = _elements\n#\n#         super().__init__(**data)  # type: ignore\n#\n#     def get_element_by_action_id(self, action_id: str) -> ElementType:\n#         \"\"\"\n#         Get element by action_id if it exists, otherwise raise ValueError\n#         \"\"\"\n#         elements: list[ElementType] = getattr(self, 'elements', [])\n#         for element in elements:  # type: ignore\n#             if getattr(element, 'action_id', None) is None:\n#                 continue\n#\n#             if element.action_id == action_id:  # type: ignore\n#                 return element\n#\n#         raise ValueError(f\"Element with action_id: {action_id} not found\")\n\n\nclass AttachmentBody(SwitBaseModel):\n    elements: list[ElementType] = Field(default_factory=list, discriminator='type')\n\n\nclass Body(SwitBaseModel):\n    elements: list[ElementType] = Field(default_factory=list, discriminator='type')\n\n\nclass Footer(SwitBaseModel):\n    buttons: list[Button]\n\n\nclass ViewCallbackType(str, Enum):\n    update = \"views.update\"\n    initialize = \"views.initialize\"\n    open = \"views.open\"\n    push = \"views.push\"\n    close = \"views.close\"\n\n\nclass AttachmentCallbackTypes(str, Enum):\n    share_channel = \"attachments.share.channel\"\n    share_new_task = \"attachments.share.new_task\"\n    share_existing_task = \"attachments.share.existing_task\"\n\n\nclass SettingsCallbackTypes(str, Enum):\n    settings_update = \"settings.update\"\n\n\nclass BotCallbackTypes(str, Enum):\n    invite_prompt = \"bot.invite_prompt\"\n\n\nclass SuggestionsCallbackTypes(str, Enum):\n    query_suggestions = \"query.suggestions\"\n\n\nclass SettingsResult(SwitBaseModel):\n    success: bool = True\n    error_message: str | None = None\n\n\nclass SuggestionsResult(SwitBaseModel):\n    options: list[Option] | None = Field(default=None, max_length=50)\n    option_groups: list[OptionGroup] | None = Field(default=None, max_length=10)\n    no_options_reason: NoOptionsReason | None = None\n\n    @model_validator(mode='before')\n    @classmethod\n    def check_suggestions_result(cls, values):\n        options = values.get('options')\n        option_groups = values.get('option_groups')\n        no_suggestions_reason = values.get('no_suggestions_reason')\n\n        if options:\n            if option_groups or no_suggestions_reason:\n                raise ValueError('If options are set, option_groups and no_suggestions_reason should not be set')\n\n        if option_groups:\n            if options or no_suggestions_reason:\n                raise ValueError('If option_groups are set, options and no_suggestions_reason should not be set')\n\n        if no_suggestions_reason:\n            if options or option_groups:\n                raise ValueError('If no_suggestions_reason is set, options and option_groups should not be set')\n\n        return values\n\n    # @field_validator('options', mode='before')  # ignore\n    # @classmethod\n    # def validate_options_length(cls, v):\n    #     if len(v) > 50:\n    #         raise ValueError(\"options length should be less than 50\")\n    #     return v\n    #\n    # @field_validator('option_groups', mode='before')\n    # @classmethod\n    # def validate_option_groups_length(cls, v):\n    #     if len(v) > 10:\n    #         raise ValueError(\"option_groups length should be less than 10\")\n    #     return v\n\n\nclass DestinationTypes(str, Enum):\n    channel = 'channel'\n    project = 'project'\n\n\nclass Destination(SwitBaseModel):\n    type: DestinationTypes\n    id: str\n\n\nclass AttachmentDestinationHint(SwitBaseModel):\n    workspace_id: str | None = None\n    channel_id: str | None = None\n    project_id: str | None = None\n    task_id: str | None = None\n\n\nclass AttachmentView(SwitBaseModel):\n    view_id: str\n    state: str | bytes\n    header: AttachmentHeader\n    footer: Footer | None = None\n    body: AttachmentBody\n\n\nclass View(SwitBaseModel):\n    view_id: str\n    state: str | bytes\n    header: Header\n    footer: Footer | None = None\n    body: Body\n\n\nclass PlatformTypes(str, Enum):\n    DESKTOP = 'Desktop'\n    IOS = 'iOS'\n    ANDROID = 'Android'\n\n\nclass SwitRequest(SwitBaseModel):\n    platform: PlatformTypes\n    time: datetime\n    app_id: str\n    user_info: UserInfo\n    user_preferences: UserPreferences\n    context: Context\n    user_action: UserAction\n    current_view: View | AttachmentView | None = None\n\n    @field_validator('current_view', mode='before')\n    @classmethod\n    def empty_dict_to_null(cls, v):\n        if v == {}:\n            return None\n        return v\n\n\nclass SwitResponse(SwitBaseModel):\n    callback_type: (ViewCallbackType | AttachmentCallbackTypes | SettingsCallbackTypes\n                    | BotCallbackTypes | SuggestionsCallbackTypes)\n    new_view: View | None = None\n    attachments: list[AttachmentView] | None = None\n    destination_hint: AttachmentDestinationHint | None = None\n    reference_view_id: str | None = None\n    result: SettingsResult | SuggestionsResult | None = None\n    destination: Destination | None = None\n\n\nclass BaseState(SwitBaseModel):\n    autoincrement_id: int = 1\n\n    @classmethod\n    def from_bytes(cls, byte: bytes):\n        d = json.loads(bz2.decompress(base64.b64decode(byte)).decode(\"utf-8\"))\n        return cls(**d)\n\n    def to_bytes(self) -> bytes:\n        return base64.b64encode(bz2.compress(self.json().encode(\"utf-8\"), 1))\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/switcore/action/schemas.py b/switcore/action/schemas.py
--- a/switcore/action/schemas.py	(revision 3ce259ae7bf94f0e7b6094266c04f16308765fc1)
+++ b/switcore/action/schemas.py	(date 1712045368926)
@@ -67,28 +67,6 @@
     resource_type: Literal['message_comment'] = 'message_comment'
 
 
-class TaskPriorityLevel(str, Enum):
-    HIGHEST = 'highest'
-    HIGH = 'high'
-    NORMAL = 'normal'
-    LOW = 'low'
-    LOWEST = 'lowest'
-
-
-class TaskColorLabel(str, Enum):
-    RED = 'red'
-    PINK = 'pink'
-    ORANGE = 'orange'
-    YELLOW = 'yellow'
-    LIGHT_GREEN = 'light_green'
-    GREEN = 'green'
-    CYAN = 'cyan'
-    BLUE = 'blue'
-    NAVY = 'navy'
-    VIOLET = 'violet'
-    GRAY = 'gray'
-
-
 class TaskStatusType(str, Enum):
     NOT_STARTED = 'not_started'
     IN_PROGRESS = 'in_progress'
@@ -130,8 +108,9 @@
     edited_at: datetime | None = None
     title: str
     period: TaskPeriod
-    priority: TaskPriorityLevel
-    color_label: TaskColorLabel | None = None
+    priority: Literal['highest', 'high', 'normal', 'low', 'lowest']
+    color_label: Literal[
+                     'red', 'pink', 'orange', 'yellow', 'light_green', 'green', 'cyan', 'blue', 'navy', 'violet', 'gray'] | None = None
     assignees: List[TaskUser]
     collaborators: List[TaskUser]
     status: TaskStatus
Index: tests/test_swit_response.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json  # noqa: F401\nimport unittest\n\nfrom switcore.action.schemas import SwitResponse, ViewCallbackType, View, Body, AttachmentCallbackTypes, AttachmentView, \\\n    AttachmentBody, SuggestionsCallbackTypes, SuggestionsResult, NoOptionsReason, AttachmentDestinationHint\nfrom switcore.ui.divider import Divider\nfrom switcore.ui.element_components import Tag, TagStyle, TagColorTypes, TagShapeTypes\nfrom switcore.ui.header import Header, AttachmentHeader\nfrom switcore.ui.image import Image\nfrom switcore.ui.select import Option, OptionGroup\nfrom switcore.ui.text_paragraph import TextParagraph\n\n\nclass SwitViewResponseTest(unittest.TestCase):\n\n    def test_swit_response_view(self):\n        body = Body(\n            elements=[TextParagraph(content=\"test content\"), Divider()],\n        )\n        swit_response = SwitResponse(\n            callback_type=ViewCallbackType.update,\n            new_view=View(\n                view_id=\"test01\",\n                state=\"test state\",\n                header=Header(title=\"this is Header\"),\n                body=body,\n            )\n        )\n        expected: dict = {\n            'callback_type': ViewCallbackType.update,\n            'new_view': {\n                'view_id': 'test01',\n                'state': \"test state\",\n                'header': {'title': 'this is Header'},\n                'body': {\n                    'elements': [\n                        {\n                            'content': 'test content',\n                            'markdown': False,\n                            'type': 'text'\n                        },\n                        {\n                            'type': 'divider'\n                        }\n                    ],\n                }\n            }\n        }\n        self.assertEqual(expected, swit_response.model_dump(exclude_none=True))\n\n    def test_swit_response_attachments(self):\n        swit_response = SwitResponse(\n            callback_type=AttachmentCallbackTypes.share_channel,\n            attachments=[AttachmentView(\n                view_id=\"test01\",\n                state=\"test state\",\n                header=AttachmentHeader(\n                    title=\"this is Header\",\n                    app_id=\"test app id\",\n                    icon=Image(\n                        image_url=\"https://example.com/image.png\",\n                    ),\n                ),\n                body=AttachmentBody(\n                    elements=[TextParagraph(content=\"test content\")],\n                ),\n            )],\n            destination_hint=AttachmentDestinationHint(\n                workspace_id=\"1234\",\n                channel_id=\"5678\",\n            )\n        )\n        expected: dict = {\n            'callback_type': 'attachments.share.channel',\n            'attachments': [{\n                'view_id': 'test01',\n                'state': \"test state\",\n                'header': {\n                    'title': 'this is Header',\n                    'app_id': 'test app id',\n                    'icon': {\n                        'type': 'image',\n                        'image_url': 'https://example.com/image.png'\n                    }\n                },\n                'body': {\n                    'elements': [\n                        {\n                            'content': 'test content',\n                            'markdown': False,\n                            'type': 'text'\n                        }\n                    ],\n                }\n            }],\n            'destination_hint': {\n                'workspace_id': '1234',\n                'channel_id': '5678'\n            }\n        }\n        self.assertEqual(expected, swit_response.model_dump(exclude_none=True))\n\n    def test_swit_response_query_suggestion01(self):\n        swit_response = SwitResponse(\n            callback_type=SuggestionsCallbackTypes.query_suggestions,\n            result=SuggestionsResult(\n                options=[Option(\n                    label=\"Search 성공!\",\n                    action_id=\"success_option_action_id\",\n                )],\n            )\n        )\n\n        expected: dict = {\n            'callback_type': SuggestionsCallbackTypes.query_suggestions,\n            'result': {\n                'options': [{\n                    'label': 'Search 성공!',\n                    'action_id': 'success_option_action_id'\n                }]\n            }\n        }\n        self.assertEqual(expected, swit_response.model_dump(exclude_none=True))\n\n    def test_swit_response_query_suggestion02(self):\n        options: list[Option] = [\n            Option(\n                label=\"test label1\",\n                icon=Image(\n                    image_url=\"https://files.swit.dev/webhook_logo.png\",\n                ),\n                tag=Tag(content=\"no style\"),\n                action_id=\"test_action_id1\"\n            ),\n            Option(\n                label=\"test label2\",\n                action_id=\"test_action_id2\",\n                tag=Tag(content=\"red rounded\", style=TagStyle(color=TagColorTypes.danger, shape=TagShapeTypes.rounded)),\n            ),\n            Option(\n                label=\"test label3\",\n                icon=Image(\n                    image_url=\"https://files.swit.dev/webhook_logo.png\",\n                ),\n                action_id=\"test_action_id3\",\n            ),\n        ]\n\n        swit_response = SwitResponse(\n            callback_type=SuggestionsCallbackTypes.query_suggestions,\n            result=SuggestionsResult(\n                options=options,\n            )\n        )\n\n        expected: dict = {\n            'callback_type': SuggestionsCallbackTypes.query_suggestions.value,\n            'result': {\n                'options': [\n                    {\n                        'label': 'test label1',\n                        'icon': {\n                            'type': 'image',\n                            'image_url': 'https://files.swit.dev/webhook_logo.png'\n                        },\n                        'tag': {\n                            'type': 'tag',\n                            'content': 'no style'\n                        },\n                        'action_id': 'test_action_id1'\n                    },\n                    {\n                        'label': 'test label2',\n                        'tag': {\n                            'type': 'tag',\n                            'content': 'red rounded',\n                            'style': {\n                                'color': 'danger',\n                                'shape': 'rounded'\n                            }\n                        },\n                        'action_id': 'test_action_id2'\n                    },\n                    {\n                        'label': 'test label3',\n                        'icon': {\n                            'type': 'image',\n                            'image_url': 'https://files.swit.dev/webhook_logo.png'\n                        },\n                        'action_id': 'test_action_id3'\n                    }\n                ]\n            }\n        }\n\n        # convert expected json to json format\n        expected_json = json.dumps(expected)\n\n        self.assertEqual(expected, swit_response.model_dump(exclude_none=True))\n\n    def test_swit_response_query_suggestions03(self):\n        with self.assertRaises(ValueError):\n            SwitResponse(\n                callback_type=SuggestionsCallbackTypes.query_suggestions,\n                result=SuggestionsResult(\n                    options=[Option(\n                        label=\"Search 성공!\",\n                        action_id=\"success_option_action_id\",\n                    )],\n                    option_groups=[\n                        OptionGroup(\n                            label=\"test group\",\n                            options=[Option(\n                                label=\"test label\",\n                                action_id=\"test action id\",\n                            )]\n                        )\n                    ]\n                )\n            )\n\n    def test_swit_response_query_suggestion05(self):\n        swit_response = SwitResponse(\n            callback_type=SuggestionsCallbackTypes.query_suggestions,\n            result=SuggestionsResult(\n                option_groups=[\n                    OptionGroup(\n                        label=\"test group1\",\n                        options=[Option(\n                            label=\"test label1\",\n                            action_id=\"test action id1\",\n                        )]\n                    ),\n                    OptionGroup(\n                        label=\"test group2\",\n                        options=[Option(\n                            label=\"test label2\",\n                            action_id=\"test action id2\",\n                        )]\n                    ),\n                ]\n            )\n        )\n\n        expected: dict = {\n            'callback_type': SuggestionsCallbackTypes.query_suggestions,\n            'result': {\n                'option_groups': [\n                    {\n                        'label': 'test group1',\n                        'options': [{\n                            'label': 'test label1',\n                            'action_id': 'test action id1'\n                        }]\n                    },\n                    {\n                        'label': 'test group2',\n                        'options': [{\n                            'label': 'test label2',\n                            'action_id': 'test action id2'\n                        }]\n                    }\n                ]\n            }\n        }\n        # convert expected json to json format\n        expected_json = json.dumps(expected)\n\n        self.assertEqual(expected, swit_response.model_dump(exclude_none=True))\n\n    def test_swit_response_query_suggestion06(self):\n        swit_response = SwitResponse(\n            callback_type=SuggestionsCallbackTypes.query_suggestions,\n            result=SuggestionsResult(\n                no_options_reason=NoOptionsReason(\n                    message=\"test message\",\n                )\n            )\n        )\n\n        expected: dict = {\n            'callback_type': SuggestionsCallbackTypes.query_suggestions,\n            'result': {\n                'no_options_reason': {\n                    'message': 'test message'\n                }\n            }\n        }\n\n        # convert expected json to json format\n        expected_json = json.dumps(expected)\n\n        self.assertEqual(expected, swit_response.model_dump(exclude_none=True))\n\n    def test_swit_response_task_attachments(self):\n        swit_response = SwitResponse(\n            callback_type=AttachmentCallbackTypes.share_new_task,\n            attachments=[AttachmentView(\n                view_id=\"test01\",\n                state=\"test state\",\n                header=AttachmentHeader(\n                    title=\"this is Header\",\n                    app_id=\"test app id\",\n                    icon=Image(\n                        image_url=\"https://example.com/image.png\",\n                    )\n                ),\n                body=AttachmentBody(\n                    elements=[TextParagraph(content=\"test content\")],\n                ),\n            )],\n            destination_hint=AttachmentDestinationHint(\n                workspace_id=\"1234\",\n                project_id=\"5678\",\n            )\n        )\n        expected: dict = {\n            'callback_type': 'attachments.share.new_task',\n            'attachments': [{\n                'view_id': 'test01',\n                'state': \"test state\",\n                'header': {\n                    'title': 'this is Header',\n                    'app_id': 'test app id',\n                    'icon': {\n                        'type': 'image',\n                        'image_url': 'https://example.com/image.png'\n                    }\n                },\n                'body': {\n                    'elements': [\n                        {\n                            'content': 'test content',\n                            'markdown': False,\n                            'type': 'text'\n                        }\n                    ],\n                }\n            }],\n            'destination_hint': {\n                'workspace_id': '1234',\n                'project_id': '5678'\n            }\n        }\n        self.assertEqual(expected, swit_response.model_dump(exclude_none=True))\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/test_swit_response.py b/tests/test_swit_response.py
--- a/tests/test_swit_response.py	(revision 3ce259ae7bf94f0e7b6094266c04f16308765fc1)
+++ b/tests/test_swit_response.py	(date 1712043098554)
@@ -4,7 +4,7 @@
 from switcore.action.schemas import SwitResponse, ViewCallbackType, View, Body, AttachmentCallbackTypes, AttachmentView, \
     AttachmentBody, SuggestionsCallbackTypes, SuggestionsResult, NoOptionsReason, AttachmentDestinationHint
 from switcore.ui.divider import Divider
-from switcore.ui.element_components import Tag, TagStyle, TagColorTypes, TagShapeTypes
+from switcore.ui.element_components import Tag, TagStyle
 from switcore.ui.header import Header, AttachmentHeader
 from switcore.ui.image import Image
 from switcore.ui.select import Option, OptionGroup
@@ -135,7 +135,7 @@
             Option(
                 label="test label2",
                 action_id="test_action_id2",
-                tag=Tag(content="red rounded", style=TagStyle(color=TagColorTypes.danger, shape=TagShapeTypes.rounded)),
+                tag=Tag(content="red rounded", style=TagStyle(color='danger', shape='rounded')),
             ),
             Option(
                 label="test label3",
Index: tests/ui/test_select.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import unittest\n\nfrom switcore.ui.element_components import OpenLink, Tag, TagStyle, TagColorTypes, TagShapeTypes\nfrom switcore.ui.image import Image\nfrom switcore.ui.select import Select, Option, OptionGroup, SelectQuery, NoOptionsReason\n\n\nclass SelectTest(unittest.TestCase):\n\n    def test_valid_select01(self):\n        select = Select(\n            trigger_on_input=True,\n            options=[\n                Option(\n                    label=\"test label1\",\n                    action_id=\"action_id1\"\n                ),\n                Option(\n                    label=\"test label2\",\n                    action_id=\"action_id2\"\n                ),\n            ]\n        )\n        expected = {\n            'type': 'select',\n            'multiselect': False,\n            'trigger_on_input': True,\n            'options': [\n                {\n                    'label': 'test label1',\n                    'action_id': 'action_id1'\n                },\n                {\n                    'label': 'test label2',\n                    'action_id': 'action_id2'\n                }\n            ],\n            'option_groups': []\n        }\n        self.assertEqual(expected, select.model_dump(exclude_none=True))\n\n    def test_valid_select02(self):\n        select = Select(\n            trigger_on_input=True,\n            options=[\n                Option(\n                    label=\"test label1\",\n                    action_id=\"action_id1\",\n                    static_action=OpenLink(\n                        link_url=\"https://www.google.com\"\n                    )\n                ),\n                Option(\n                    label=\"test label2\",\n                    action_id=\"action_id2\"\n                ),\n            ]\n        )\n        expected = {\n            'type': 'select',\n            'multiselect': False,\n            'options': [{'action_id': 'action_id1',\n                         'label': 'test label1',\n                         'static_action': {'link_url': 'https://www.google.com',\n                                           'action_type': 'open_link'}},\n                        {'action_id': 'action_id2', 'label': 'test label2'}],\n            'option_groups': [],\n            'trigger_on_input': True,\n        }\n        self.assertEqual(expected, select.model_dump(exclude_none=True))\n\n    def test_valid_select03(self):\n        select = Select(\n            trigger_on_input=True,\n            options=[\n                Option(\n                    label=\"test label1\",\n                    action_id=\"action_id1\",\n                    tag=Tag(content=\"tag1\", style=TagStyle(color=TagColorTypes.danger))\n                ),\n                Option(\n                    label=\"test label2\",\n                    action_id=\"action_id2\",\n                    tag=Tag(content=\"tag1\", style=TagStyle(color=TagColorTypes.primary, shape=TagShapeTypes.rounded))\n                ),\n            ]\n        )\n\n        expected = {\n            'type': 'select',\n            'multiselect': False,\n            'options': [{'action_id': 'action_id1', 'label': 'test label1',\n                         'tag': {'type': 'tag', 'content': 'tag1',\n                                 'style': {'color': 'danger', 'shape': 'rectangular'}}},\n                        {'action_id': 'action_id2', 'label': 'test label2',\n                         'tag': {'type': 'tag', 'content': 'tag1', 'style': {'color': 'primary', 'shape': 'rounded'}}}],\n            'option_groups': [],\n            'trigger_on_input': True,\n        }\n        self.assertEqual(expected, select.model_dump(exclude_none=True))\n\n    def test_options_select(self):\n        select = Select(\n            trigger_on_input=True,\n            options=[\n                Option(\n                    label=\"test label1\",\n                    icon=Image(\n                        image_url=\"https://www.google.com\",\n                    ),\n                    action_id=\"action_id1\",\n                    tag=Tag(content=\"tag1\"),\n                ),\n                Option(\n                    label=\"test label2\",\n                    action_id=\"action_id2\",\n                    tag=Tag(content=\"tag2\"),\n                ),\n                Option(\n                    label=\"test label3\",\n                    icon=Image(\n                        image_url=\"https://www.google.com\",\n                    ),\n                    action_id=\"action_id3\",\n                ),\n            ],\n            query=SelectQuery(\n                query_server=True,\n                action_id=\"action_id\"\n            )\n        )\n\n        expected: dict = {\n            'type': 'select',\n            'multiselect': False,\n            'options': [\n                {'action_id': 'action_id1', 'icon': {'type': 'image', 'image_url': 'https://www.google.com'},\n                 'label': 'test label1', 'tag': {'type': 'tag', 'content': 'tag1'}},\n                {'action_id': 'action_id2', 'label': 'test label2',\n                 'tag': {'type': 'tag', 'content': 'tag2'}},\n                {'action_id': 'action_id3', 'icon': {'type': 'image', 'image_url': 'https://www.google.com'},\n                 'label': 'test label3'}\n            ],\n            'option_groups': [],\n            'trigger_on_input': True,\n            'query': {'query_server': True, 'disabled': False, 'action_id': 'action_id'}\n        }\n        self.assertEqual(expected, select.model_dump(exclude_none=True))\n\n    def test_group_options_select(self):\n        select = Select(\n            trigger_on_input=True,\n            option_groups=[\n                OptionGroup(\n                    label=\"test group1\",\n                    options=[\n                        Option(\n                            label=\"test label1\",\n                            icon=Image(\n                                image_url=\"https://www.google.com\",\n                            ),\n                            tag=Tag(content=\"tag1\"),\n                            action_id=\"action_id1\",\n                        ),\n                        Option(\n                            label=\"test label2\",\n                            action_id=\"action_id2\",\n                            tag=Tag(content=\"tag2\"),\n                        )\n                    ],\n                ),\n                OptionGroup(\n                    label=\"test group2\",\n                    options=[\n                        Option(\n                            label=\"test label3\",\n                            icon=Image(\n                                image_url=\"https://www.google.com\",\n                            ),\n                            action_id=\"action_id3\",\n                        )\n                    ],\n                ),\n\n            ],\n            query=SelectQuery(\n                query_server=True,\n                action_id=\"action_id\"\n            )\n        )\n\n        expected: dict = {\n            'type': 'select',\n            'multiselect': False,\n            'options': [],\n            'option_groups': [\n                {'label': 'test group1', 'options': [\n                    {'action_id': 'action_id1', 'icon': {'type': 'image', 'image_url': 'https://www.google.com'},\n                     'label': 'test label1', 'tag': {'type': 'tag', 'content': 'tag1'}},\n                    {'action_id': 'action_id2', 'label': 'test label2',\n                     'tag': {'type': 'tag', 'content': 'tag2'}}\n                ]},\n                {'label': 'test group2', 'options': [\n                    {'action_id': 'action_id3', 'icon': {'type': 'image', 'image_url': 'https://www.google.com'},\n                     'label': 'test label3'}\n                ]}\n            ],\n            'trigger_on_input': True,\n            'query': {'query_server': True, 'disabled': False, 'action_id': 'action_id'}\n        }\n        self.assertEqual(expected, select.model_dump(exclude_none=True))\n\n    def test_mixed_select(self):\n        with self.assertRaises(ValueError):\n            Select(\n                trigger_on_input=True,\n                options=[\n                    Option(\n                        label=\"test label1\",\n                        action_id=\"mixed_action_id1\",\n                    ),\n                    Option(\n                        label=\"test label2\",\n                        action_id=\"mixed_action_id2\"\n                    ),\n                ],\n                option_groups=[\n                    OptionGroup(label=\"test group1\",\n                                options=[Option(label=\"test label1\", action_id=\"mixed_action_id3\")]),\n                    OptionGroup(label=\"test group2\",\n                                options=[Option(label=\"test label2\", action_id=\"mixed_action_id4\")]),\n                ],\n                query=SelectQuery(\n                    action_id=\"query_action_id_3\"\n                )\n            )\n\n    def test_filter_select(self):\n        select = Select(\n            trigger_on_input=True,\n            options=[\n                Option(\n                    label=\"test label1\",\n                    action_id=\"filter_action_1\",\n                ),\n                Option(\n                    label=\"test label2\",\n                    action_id=\"filter_action_2\"\n                ),\n            ],\n            query=SelectQuery(\n                query_server=False,\n                action_id=\"query_action_id_4\"\n            )\n        )\n\n        expected: dict = {\n            'type': 'select',\n            'multiselect': False,\n            'options': [{'action_id': 'filter_action_1', 'label': 'test label1'},\n                        {'action_id': 'filter_action_2', 'label': 'test label2'}],\n            'option_groups': [],\n            'trigger_on_input': True,\n            'query': {'query_server': False, 'disabled': False, 'action_id': 'query_action_id_4'}\n\n        }\n\n        self.assertEqual(expected, select.model_dump(exclude_none=True))\n\n    def test_select_option_groups_length(self):\n        with self.assertRaises(ValueError):\n            Select(\n                trigger_on_input=True,\n                option_groups=[\n                    OptionGroup(label=\"test group1\",\n                                options=[]),\n                    OptionGroup(label=\"test group2\",\n                                options=[Option(label=\"test label2\", action_id=\"mixed_action_id4\")]),\n                ],\n                query=SelectQuery(\n                    action_id=\"query_action_id_3\"\n                )\n            )\n\n    def test_select_no_options_reason(self):\n        select = Select(\n            trigger_on_input=True,\n            no_options_reason=NoOptionsReason(\n                message=\"test message\"\n            ),\n            query=SelectQuery(\n                query_server=False,\n                action_id=\"query_action_id_3\"\n            )\n        )\n\n        expected: dict = {\n            'type': 'select',\n            'multiselect': False,\n            'options': [],\n            'option_groups': [],\n            'trigger_on_input': True,\n            'no_options_reason': {'message': 'test message'},\n            'query': {'query_server': False, 'disabled': False, 'action_id': 'query_action_id_3'}\n        }\n\n        self.assertEqual(expected, select.model_dump(exclude_none=True))\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/ui/test_select.py b/tests/ui/test_select.py
--- a/tests/ui/test_select.py	(revision 3ce259ae7bf94f0e7b6094266c04f16308765fc1)
+++ b/tests/ui/test_select.py	(date 1712043132632)
@@ -1,6 +1,6 @@
 import unittest
 
-from switcore.ui.element_components import OpenLink, Tag, TagStyle, TagColorTypes, TagShapeTypes
+from switcore.ui.element_components import OpenLink, Tag, TagStyle
 from switcore.ui.image import Image
 from switcore.ui.select import Select, Option, OptionGroup, SelectQuery, NoOptionsReason
 
@@ -76,12 +76,12 @@
                 Option(
                     label="test label1",
                     action_id="action_id1",
-                    tag=Tag(content="tag1", style=TagStyle(color=TagColorTypes.danger))
+                    tag=Tag(content="tag1", style=TagStyle(color='danger'))
                 ),
                 Option(
                     label="test label2",
                     action_id="action_id2",
-                    tag=Tag(content="tag1", style=TagStyle(color=TagColorTypes.primary, shape=TagShapeTypes.rounded))
+                    tag=Tag(content="tag1", style=TagStyle(color='primary', shape='rounded'))
                 ),
             ]
         )
Index: pyproject.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[project]\nname = \"swit-core\"\nversion = \"4.0.0\"\nauthors = [\n    { name = \"ur-team\", email = \"developers@swit.io\" },\n]\ndescription = \"this is a switbuilder core package\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n]\ndependencies = [\n#    'pydantic == 2.6.4',\n    'httpx >=0.26.0',\n    'fastapi ~=0.109.2',\n    'SQLAlchemy >=2.0.27',\n    'PyMySQL >=1.1.0',\n    'ur-tunnel>=0.0.13',\n    'python-dotenv>=1.0.1',\n    'uvicorn>=0.27.1',\n    'PyJWT==2.8.0'\n]\n\n[project.urls]\n\"Homepage\" = \"https://github.com/pypa/sampleproject\"\n\"Bug Tracker\" = \"https://github.com/pypa/sampleproject/issues\"\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n[tool.hatch.build.targets.wheel]\npackages = [\"switcore\"]\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pyproject.toml b/pyproject.toml
--- a/pyproject.toml	(revision 3ce259ae7bf94f0e7b6094266c04f16308765fc1)
+++ b/pyproject.toml	(date 1712041435608)
@@ -1,6 +1,6 @@
 [project]
 name = "swit-core"
-version = "4.0.0"
+version = "4.0.1"
 authors = [
     { name = "ur-team", email = "developers@swit.io" },
 ]
Index: switcore/ui/element_components.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from enum import Enum\nfrom typing import Any\n\nfrom pydantic import model_validator\n\nfrom switcore.pydantic_base_model import SwitBaseModel\n\n\nclass TagColorTypes(str, Enum):\n    primary = \"primary\"\n    secondary = \"secondary\"\n    danger = \"danger\"\n\n\nclass TagShapeTypes(str, Enum):\n    rectangular = \"rectangular\"\n    rounded = \"rounded\"\n\n\nclass TagStyle(SwitBaseModel):\n    color: TagColorTypes = TagColorTypes.secondary\n    shape: TagShapeTypes = TagShapeTypes.rectangular\n\n    class Config:\n        use_enum_values = True\n\n    @model_validator(mode='before')\n    @classmethod\n    def check_color_and_shape(cls, values: dict[str, Any]) -> dict[str, Any]:\n        color: TagColorTypes | None = values.get('color')\n        shape: TagShapeTypes | None = values.get('shape')\n        if color is None and shape is None:\n            raise ValueError(\"color and shape cannot be None at the same time\")\n        return values\n\n\nclass Tag(SwitBaseModel):\n    type: str = \"tag\"\n    content: str\n    style: TagStyle | None = None\n\n\nclass SubText(SwitBaseModel):\n    type: str = \"subtext\"\n    content: str\n\n\nclass OpenOauthPopup(SwitBaseModel):\n    action_type: str = \"open_oauth_popup\"\n    link_url: str\n\n\nclass OpenLink(SwitBaseModel):\n    action_type: str = \"open_link\"\n    link_url: str\n\n\nclass CloseView(SwitBaseModel):\n    action_type: str = \"close_view\"\n\n\nclass WriteToClipboard(SwitBaseModel):\n    action_type: str = \"write_to_clipboard\"\n    content: str\n\n\nStaticAction = OpenOauthPopup | OpenLink | WriteToClipboard | CloseView\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/switcore/ui/element_components.py b/switcore/ui/element_components.py
--- a/switcore/ui/element_components.py	(revision 3ce259ae7bf94f0e7b6094266c04f16308765fc1)
+++ b/switcore/ui/element_components.py	(date 1712043142101)
@@ -1,25 +1,13 @@
-from enum import Enum
-from typing import Any
+from typing import Any, Literal
 
 from pydantic import model_validator
 
 from switcore.pydantic_base_model import SwitBaseModel
 
 
-class TagColorTypes(str, Enum):
-    primary = "primary"
-    secondary = "secondary"
-    danger = "danger"
-
-
-class TagShapeTypes(str, Enum):
-    rectangular = "rectangular"
-    rounded = "rounded"
-
-
 class TagStyle(SwitBaseModel):
-    color: TagColorTypes = TagColorTypes.secondary
-    shape: TagShapeTypes = TagShapeTypes.rectangular
+    color: Literal['primary', 'secondary', 'danger'] = 'secondary'
+    shape: Literal['rectangular', 'rounded'] = 'rectangular'
 
     class Config:
         use_enum_values = True
@@ -27,8 +15,8 @@
     @model_validator(mode='before')
     @classmethod
     def check_color_and_shape(cls, values: dict[str, Any]) -> dict[str, Any]:
-        color: TagColorTypes | None = values.get('color')
-        shape: TagShapeTypes | None = values.get('shape')
+        color: str | None = values.get('color')
+        shape: str | None = values.get('shape')
         if color is None and shape is None:
             raise ValueError("color and shape cannot be None at the same time")
         return values
Index: switcore/ui/collection_entry.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import Literal\nfrom enum import Enum\n\nfrom switcore.pydantic_base_model import SwitBaseModel\nfrom switcore.ui.element_components import SubText, Tag, StaticAction\nfrom switcore.ui.image import Image\nfrom switcore.ui.text_paragraph import TextParagraph\n\n\nclass TextStyle(SwitBaseModel):\n    bold: bool = False\n    color: str\n    size: str\n    max_lines: int\n\n\nclass BackgroundType(str, Enum):\n    none = \"none\"\n    lightblue = \"lightblue\"\n\n\nclass Background(SwitBaseModel):\n    color: BackgroundType = BackgroundType.none\n\n\nclass MetadataItem(SwitBaseModel):\n    type: str\n    content: str | None = None\n    style: dict | None = None\n    image_url: str | None = None\n\n\nclass TextSection(SwitBaseModel):\n    text: TextParagraph\n    metadata_items: list[SubText | Image | Tag] | None = None\n\n\nclass VerticalAlignmentTypes(str, Enum):\n    top = \"top\"\n    middle = \"middle\"\n    bottom = \"bottom\"\n\n\nclass CollectionEntry(SwitBaseModel):\n    type: Literal['collection_entry'] = 'collection_entry'\n    start_section: Image | None = None\n    text_sections: list[TextSection]\n    vertical_alignment: VerticalAlignmentTypes = VerticalAlignmentTypes.top\n    background: Background | None = None\n    action_id: str | None = None\n    static_action: StaticAction | None = None\n    draggable: bool = False\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/switcore/ui/collection_entry.py b/switcore/ui/collection_entry.py
--- a/switcore/ui/collection_entry.py	(revision 3ce259ae7bf94f0e7b6094266c04f16308765fc1)
+++ b/switcore/ui/collection_entry.py	(date 1712042305167)
@@ -14,13 +14,8 @@
     max_lines: int
 
 
-class BackgroundType(str, Enum):
-    none = "none"
-    lightblue = "lightblue"
-
-
 class Background(SwitBaseModel):
-    color: BackgroundType = BackgroundType.none
+    color: Literal['none', 'lightblue'] = 'none'
 
 
 class MetadataItem(SwitBaseModel):
@@ -35,17 +30,11 @@
     metadata_items: list[SubText | Image | Tag] | None = None
 
 
-class VerticalAlignmentTypes(str, Enum):
-    top = "top"
-    middle = "middle"
-    bottom = "bottom"
-
-
 class CollectionEntry(SwitBaseModel):
     type: Literal['collection_entry'] = 'collection_entry'
     start_section: Image | None = None
     text_sections: list[TextSection]
-    vertical_alignment: VerticalAlignmentTypes = VerticalAlignmentTypes.top
+    vertical_alignment: Literal['top', 'middle', 'bottom'] = 'top'
     background: Background | None = None
     action_id: str | None = None
     static_action: StaticAction | None = None
