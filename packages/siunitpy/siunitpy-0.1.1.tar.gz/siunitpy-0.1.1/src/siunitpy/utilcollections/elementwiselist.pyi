import sys
from typing import Any, Iterable, SupportsIndex, TypeVar, overload

__all__ = ['ElementWiseList']

T, S = TypeVar('T'), TypeVar('S')

if sys.version_info >= (3, 11):
    from typing import Self
else:
    Self = TypeVar('Self', bound=ElementWiseList[Any])


class ElementWiseList(list[T]):
    '''`ElementWiseList` inherits most of the function of built-in `list`, 
    while its operator overloading is elementwise. 
    It acts like 1-D array in numpy.

    Constructor
    ---
    You can construct a `ElementWiseList` object using iterable like `list`:
    >>> ElementWiseList()               # [], new empty List
    >>> ElementWiseList([0, 1, 2, 3])   # [0, 1, 2, 3]
    >>> ElementWiseList(range(4))       # [0, 1, 2, 3]

    You can also use classmethod `ElementWiseList.packup(*args)` 
    to write one less parenthesis.
    >>> ElementWiseList.packup(0, 1, 2, 3)  # [0, 1, 2, 3]

    Get items or sub-sequence
    ---
    You can get an item or sub-sequence from a `ElementWiseList` 
    exactly like `list`:
    >>> v = ElementWiseList(range(4))   # [0, 1, 2, 3]
    >>> v[3]                            # 3
    >>> v[-1]                           # 3
    >>> v[:2]                           # [0, 1]

    Moreover, you can use advanced-indexing and boolean-indexing like numpy:
    >>> v[0, -1, 2]             # [0, 3, 2]
    >>> v[True, False, True]    # [0, 2]

    Set items
    ---
    >>> u = v.copy()
    >>> u[:2] = range(1, 3)     # u = [1, 2, 2, 3]
    >>> u[u > 1] = 0            # u = [1, 0, 0, 0]

    Operation
    ---
    The operator is elementwise, meaning it acts on each element:
    >>> -v          # [0, -1, -2, -3]
    >>> u = v + 1   # [1, 2, 3, 4], like boardcast in numpy
    >>> u * v       # [0, 2, 6, 12]

    Meanwhile, `list` operator `+`, `+=`, `*`, `*=` and comparison 
    (like `==`, `>`) are overloaded. As replacement, see WARNING.

    WARNING
    ---
    This inheritance violates *the Liskov Substitution principle*. 
    If you want to replace `list` with `ElementWiseList`, you should make 5 
    types of adjustments:
    >>> a.extend(b)                 # list extend:  a += b
    >>> cls.cat(a, b, ..., z)       # list concatenat: a + b + ... + z
    >>> a.repeat(3)                 # list repeat: a * 3
    >>> a.irepeat(3)                # list inplace repeat: a *= 3
    >>> cls.equal(a, b)             # list comparison: a == b

    Comparison: `ElementWiseList` staticmethod `equal`.
    '''
    
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[T]) -> None: ...
    @classmethod
    def packup(cls: type[Self], *args: T) -> Self: ...
    @overload
    def __getitem__(self, index: SupportsIndex) -> T: ...
    @overload
    def __getitem__(self: Self, slice: slice) -> Self: ...
    @overload
    def __getitem__(self: Self, bool_index: Iterable[bool]) -> Self: ...
    @overload
    def __getitem__(self: Self, index_list: Iterable[SupportsIndex]) -> Self: ...
    @overload
    def __setitem__(self, index: SupportsIndex, value: T) -> None: ...
    @overload
    def __setitem__(self: Self, key: slice, value: T | Iterable[T]) -> None: ...
    @overload
    def __setitem__(self: Self, key: Iterable[bool], value: T | Iterable[T]) -> None: ...
    @overload
    def __setitem__(self: Self, key: Iterable[SupportsIndex], value: T | Iterable[T]) -> None: ...
    @overload
    def __delitem__(self, key: SupportsIndex) -> None: ...
    @overload
    def __delitem__(self, key: slice) -> None: ...
    @overload
    def __delitem__(self, key: Iterable[bool]) -> None: ...
    @overload
    def __delitem__(self, key: Iterable[SupportsIndex]) -> None: ...
    @classmethod
    def cat(cls: type[Self], left: Iterable[T], /, *rights: Iterable[T]) -> Self: ...
    def repeat(self: Self, repeat_time: int, /) -> Self: ...
    def irepeat(self: Self, repeat_time: int, /) -> Self: ...
    def erepeat(self: Self, repeat_time: int, /) -> Self: ...
    @classmethod
    def zeros(cls, length: int, /) -> ElementWiseList[int]: ...
    @classmethod
    def ones(cls, length: int, /) -> ElementWiseList[int]: ...
    def copy(self: Self) -> Self: ...
    # elementwise unary operation
    def __pos__(self: Self) -> Self: ...
    def __neg__(self: Self) -> Self: ...
    def __not__(self: Self) -> Self: ...
    def __invert__(self: Self) -> Self: ...
    def __abs__(self: Self) -> Self: ...
    # elementwise comparison operation
    def __eq__(self: Self, other: T | Self) -> ElementWiseList[bool]: ...
    def __ne__(self: Self, other: T | Self) -> ElementWiseList[bool]: ...
    def __gt__(self: Self, other: T | Self) -> ElementWiseList[bool]: ...
    def __lt__(self: Self, other: T | Self) -> ElementWiseList[bool]: ...
    def __ge__(self: Self, other: T | Self) -> ElementWiseList[bool]: ...
    def __le__(self: Self, other: T | Self) -> ElementWiseList[bool]: ...
    # elementwise binary operation
    def __add__(self: Self, other: T | Self) -> Self: ...
    def __sub__(self: Self, other: T | Self) -> Self: ...
    def __mul__(self: Self, other: T | Self) -> Self: ...
    def __matmul__(self: Self, other: T | Self) -> Self: ...
    def __pow__(self: Self, other: T | Self) -> Self: ...
    def __floordiv__(self: Self, other: T | Self) -> Self: ...
    def __truediv__(self: Self, other: T | Self) -> Self: ...
    def __mod__(self: Self, other: T | Self) -> Self: ...
    def __and__(self: Self, other: T | Self) -> Self: ...
    def __or__(self: Self, other: T | Self) -> Self: ...
    def __xor__(self: Self, other: T | Self) -> Self: ...
    def __lshift__(self: Self, other: T | Self) -> Self: ...
    def __rshift__(self: Self, other: T | Self) -> Self: ...
    # inplace
    def __iadd__(self: Self, other: T | Self) -> Self: ...
    def __isub__(self: Self, other: T | Self) -> Self: ...
    def __imul__(self: Self, other: T | Self) -> Self: ...
    def __imatmul__(self: Self, other: T | Self) -> Self: ...
    def __ipow__(self: Self, other: T | Self) -> Self: ...
    def __ifloordiv__(self: Self, other: T | Self) -> Self: ...
    def __itruediv__(self: Self, other: T | Self) -> Self: ...
    def __imod__(self: Self, other: T | Self) -> Self: ...
    def __iand__(self: Self, other: T | Self) -> Self: ...
    def __ior__(self: Self, other: T | Self) -> Self: ...
    def __ixor__(self: Self, other: T | Self) -> Self: ...
    def __ilshift__(self: Self, other: T | Self) -> Self: ...
    def __irshift__(self: Self, other: T | Self) -> Self: ...
    # right
    def __radd__(self: Self, other: T | Self) -> Self: ...
    def __rsub__(self: Self, other: T | Self) -> Self: ...
    def __rmul__(self: Self, other: T | Self) -> Self: ...
    def __rmatmul__(self: Self, other: T | Self) -> Self: ...
    def __rpow__(self: Self, other: T | Self) -> Self: ...
    def __rfloordiv__(self: Self, other: T | Self) -> Self: ...
    def __rtruediv__(self: Self, other: T | Self) -> Self: ...
    def __rmod__(self: Self, other: T | Self) -> Self: ...
    def __rand__(self: Self, other: T | Self) -> Self: ...
    def __ror__(self: Self, other: T | Self) -> Self: ...
    def __rxor__(self: Self, other: T | Self) -> Self: ...
    def __rlshift__(self: Self, other: T | Self) -> Self: ...
    def __rrshift__(self: Self, other: T | Self) -> Self: ...
    





