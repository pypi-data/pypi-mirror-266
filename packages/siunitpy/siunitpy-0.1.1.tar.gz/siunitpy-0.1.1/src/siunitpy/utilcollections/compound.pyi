from fractions import Fraction
from typing import Any, Generic, Iterable, Iterator, TypeVar, overload

from .utils import Number

K = TypeVar('K')


class Compound(Generic[K]):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[tuple[K, Number]], /) -> None: ...
    @overload
    def __init__(self, elements: dict[K, Fraction], /, *, move_dict=False) -> None: ...
    def __contains__(self, key: K) -> bool: ...
    def __getitem__(self, key: K) -> Fraction: ...
    def __setitem__(self, key: K, value: Fraction) -> None: ...
    def __delitem__(self, key: K) -> None: ...
    def __iter__(self) -> Iterator[K]: ...
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    def copy(self) -> Compound[K]: ...
    def keys(self) -> Iterable[K]: ...
    def values(self) -> Iterable[Fraction]: ...
    def items(self) -> Iterable[tuple[K, Fraction]]: ...
    def pop(self, key: K) -> Fraction: ...
    def clear(self) -> None: ...
    def __eq__(self, other: Compound[Any]) -> bool: ...
    def __pos__(self) -> Compound[K]: ...
    def __neg__(self) -> Compound[K]: ...
    def __add__(self, other: Compound[K]) -> Compound[K]: ...
    def __sub__(self, other: Compound[K]) -> Compound[K]: ...
    def __mul__(self, other: int | Fraction) -> Compound[K]: ...
    def __truediv__(self, other: int | Fraction) -> Compound[K]: ...
    def __iadd__(self, other: Compound[K]) -> Compound[K]: ...
    def __isub__(self, other: Compound[K]) -> Compound[K]: ...
    def __imul__(self, other: int | Fraction) -> Compound[K]: ...
    def __itruediv__(self, other: int | Fraction) -> Compound[K]: ...
    def __rmul__(self, other: int | Fraction) -> Compound[K]: ...

