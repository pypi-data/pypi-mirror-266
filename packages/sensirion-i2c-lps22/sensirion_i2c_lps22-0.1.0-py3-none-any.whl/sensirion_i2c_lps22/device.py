#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# (c) Copyright 2023 Sensirion AG, Switzerland
#
#     THIS FILE IS AUTOMATICALLY GENERATED!
#
# Generator:     sensirion-driver-generator 0.33.0
# Product:       lps22
# Model-Version: 1.0.1
#
"""
The class Lps22DeviceBase implements the low level interface of the sensor.
The class Lps22Device extends the Lps22DeviceBase. It provides additional functions to ease the use of the
sensor.
"""

from sensirion_driver_adapters.transfer import execute_transfer
from sensirion_driver_support_types.mixin_access import MixinAccess
from sensirion_i2c_lps22.commands import (CtrlRegOneT, CtrlRegThreeT, CtrlRegTwoT, GetCtrlReg1, GetCtrlReg2,
                                          GetCtrlReg3, ReadPressure, ReadPressureOutH, ReadPressureOutL,
                                          ReadPressureOutXl, ReadTemperature, ReadTemperatureH, ReadTemperatureL,
                                          ResetLowPass, SetCtrlReg1, SetCtrlReg2, SetCtrlReg3, Status, StatusT, Whoami)

from sensirion_i2c_lps22.result_types import (SignalPressure, SignalTemperature)


class Lps22DeviceBase:
    """Low level API implementation of LPS22"""

    def __init__(self, channel):
        self._channel = channel

    @property
    def channel(self):
        return self._channel

    def whoami(self):
        """
        Get the chip id.

        :return chip_id:
            id of the chip, expecting 0xB1 for LPS22
        """
        transfer = Whoami()
        return execute_transfer(self._channel, transfer)[0]

    def status(self):
        """
        Get the status bit. See datasheet for description of the bits.

        :return status_bit:

        """
        transfer = Status()
        return execute_transfer(self._channel, transfer)[0]

    def get_ctrl_reg1(self):
        """
        Get the control register 1.
        See datasheet for description of the options.

        :return register_value:

        """
        transfer = GetCtrlReg1()
        return execute_transfer(self._channel, transfer)[0]

    def set_ctrl_reg1(self, register_value):
        """
        Set the control register 1.
        See datasheet for description of the options.

        :param register_value:

        """
        transfer = SetCtrlReg1(register_value)
        return execute_transfer(self._channel, transfer)

    def get_ctrl_reg2(self):
        """
        Get the control register 3.
        See datasheet for description of the options.

        :return register_value:

        """
        transfer = GetCtrlReg2()
        return execute_transfer(self._channel, transfer)[0]

    def set_ctrl_reg2(self, register_value):
        """
        Set the control register 2.
        See datasheet for description of the options.

        :param register_value:

        """
        transfer = SetCtrlReg2(register_value)
        return execute_transfer(self._channel, transfer)

    def get_ctrl_reg3(self):
        """
        Get the control register 3.
        See datasheet for description of the options.

        :return register_value:

        """
        transfer = GetCtrlReg3()
        return execute_transfer(self._channel, transfer)[0]

    def set_ctrl_reg3(self, register_value):
        """
        Set the control register 3.
        See datasheet for description of the options.

        :param register_value:

        """
        transfer = SetCtrlReg3(register_value)
        return execute_transfer(self._channel, transfer)

    def read_pressure_out_xl(self):
        """
        Read current pressure from register, LSB

        :return pressure:

        """
        transfer = ReadPressureOutXl()
        return execute_transfer(self._channel, transfer)[0]

    def read_pressure_out_l(self):
        """
        Read current pressure from register, middle byte

        :return pressure:

        """
        transfer = ReadPressureOutL()
        return execute_transfer(self._channel, transfer)[0]

    def read_pressure_out_h(self):
        """
        Read current pressure from register, MSB

        :return pressure:

        """
        transfer = ReadPressureOutH()
        return execute_transfer(self._channel, transfer)[0]

    def read_pressure(self):
        """
        Read current pressure in register auto increment mode. The value returned is a two's complement and has a scale factor of 4096 to convert to hPa.

        :return pressure:
            pressurer, three bytes in little endian order
        """
        transfer = ReadPressure()
        return execute_transfer(self._channel, transfer)[0]

    def read_temperature_l(self):
        """
        Read temperature measurement from register, LOW byte

        :return temperature_l:
            temperature low byte
        """
        transfer = ReadTemperatureL()
        return execute_transfer(self._channel, transfer)[0]

    def read_temperature_h(self):
        """
        Read temperature measurement from register, high byte

        :return temperature_h:
            temperature high byte
        """
        transfer = ReadTemperatureH()
        return execute_transfer(self._channel, transfer)[0]

    def read_temperature(self):
        """
        Read current temperature from registers in auto increment mode.
        The value returned has a scale factor of 100 to convert to degC.

        :return temperature:
            temperature, two bytes in little endian order
        """
        transfer = ReadTemperature()
        return execute_transfer(self._channel, transfer)[0]

    def reset_low_pass(self):
        """
        Low-pass filter reset. If the LPFP is active, in order to avoid the transitory phase, the
        filter can be reset by reading this register before generating pressure measurements.
        """
        transfer = ResetLowPass()
        return execute_transfer(self._channel, transfer)


class Lps22Device(Lps22DeviceBase):
    """Driver class implementation of LPS22"""

    #: Access to base class
    lps22 = MixinAccess()

    def __init__(self, channel):
        super().__init__(channel)

    def get_ctrl_reg1(self):
        """
        Get control register 1.
        See datasheet for details about the bitfields.

        :return register_value:

        """
        reg1 = self.lps22.get_ctrl_reg1()
        return CtrlRegOneT(reg1)

    def get_ctrl_reg2(self):
        """
        Get control register 2.
        See datasheet for details about the bitfields.

        :return register_value:

        """
        reg2 = self.lps22.get_ctrl_reg2()
        return CtrlRegTwoT(reg2)

    def get_ctrl_reg3(self):
        """
        Get control register 3.
        See datasheet for details about the bitfields.

        :return register_value:

        """
        reg3 = self.lps22.get_ctrl_reg3()
        return CtrlRegThreeT(reg3)

    def activate_multi_byte_read(self):
        """
        Register address is automatically incremented during a multiple byte
        read access.
        """
        reg2 = self.lps22.get_ctrl_reg2()
        mask_enable = 1 << 4
        self.lps22.set_ctrl_reg2(reg2 | mask_enable)

    def deactivate_multi_byte_read(self):
        """
        Disable that Register address is automatically incremented.
        If this is disabled, use single-byte read functions.
        """
        reg2 = self.lps22.get_ctrl_reg2()
        mask_enable = 1 << 4
        mask_disable = ~mask_enable
        return self.lps22.set_ctrl_reg2(reg2 & mask_disable)

    def power_down_mode(self):
        """Switch to power down mode. In this mode one shot measurements can be done."""
        reg1 = self.lps22.get_ctrl_reg1()
        odr_clear = ~112
        self.lps22.set_ctrl_reg1(reg1 & odr_clear)

    def stop_continious_measurement(self):
        """
        Stop any running continious measurement.
        Sensor is in power down mode afterwards.
        """
        self.power_down_mode()

    def start_one_shot_measurement(self):
        """
        Start a one-shot measurement.
        Use read_pressure and read_temperature to get sensor values.
        """
        self.activate_multi_byte_read()
        self.power_down_mode()
        reg2 = self.lps22.get_ctrl_reg2()
        mask_enable = 1
        self.lps22.set_ctrl_reg2(reg2 | mask_enable)

    def start_continious_measurement(self, measurement_frequency):
        """
        Start continious measurement with given frequency. Available frequencies depend on the version
        of your LPS22 sensor, please check the datasheet for more details.
        Use read_pressure_single_bytes and read_temperature_signle_bytes to get sensor values as
        the multi byte read option is disabled when using the continious measurement.

        :param measurement_frequency:

        """
        self.deactivate_multi_byte_read()
        self.stop_continious_measurement()
        reg1 = self.lps22.get_ctrl_reg1()
        mask_enable = int(measurement_frequency) << 4
        self.lps22.set_ctrl_reg1(reg1 | mask_enable)

    def status(self):
        """
        Get current data ready status.

        :return a_status:

        """
        status = self.lps22.status()
        return StatusT(status)

    def read_pressure(self):
        """
        Read pressure value with multi byte read.
        Make sure you have the sensor in correct mode by runnin activate_multi_byte_read()

        :return a_pressure:
            measured pressure in hPa
        """
        raw_data = self.lps22.read_pressure()
        return SignalPressure(raw_data)

    def read_pressure_single_bytes(self):
        """
        Read temperature measurement from registers in single byte read mode.

        :return a_pressure:
            measured pressure in hPa
        """
        raw_data = (self.lps22.read_pressure_out_xl(), self.lps22.read_pressure_out_l(),
                    self.lps22.read_pressure_out_h())
        return SignalPressure(raw_data)

    def read_temperature(self):
        """
        Read temperature value with multi byte read.
        Make sure you have the sensor in correct mode by running activate_multi_byte_read()

        :return a_temperature:
            measured temperature in degC
        """
        raw_data = self.lps22.read_temperature()
        return SignalTemperature(raw_data)

    def read_temperature_single_bytes(self):
        """
        Read temperature measurement from registers in single byte read mode.

        :return a_temperature:
            measured temperature in degC
        """
        raw_data = (self.lps22.read_temperature_l(), self.lps22.read_temperature_h())
        return SignalTemperature(raw_data)

    def swreset(self):
        """
        The SWRESET bit resets the volatile registers to default value 0.
        It returns to 0 by hardware.
        """
        reg2 = self.lps22.get_ctrl_reg2()
        mask_enable = 1 << 2
        return self.lps22.set_ctrl_reg2(reg2 | mask_enable)
